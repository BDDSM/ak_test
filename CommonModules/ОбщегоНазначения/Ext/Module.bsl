// Получение представления для документа, удостоверяющего личность
//
// Параметры
//  ДанныеФизЛица  – Коллекция данных физ. лица (структура, строка таблицы, ...), содержащая значения: 
//                   ДокументВид, ДокументСерия, ДокументНомер, ДокументДатаВыдачи, ДокументКемВыдан  
//
// Возвращаемое значение:
//   Строка   – Представление документа, удостоверяющего личность
//
Функция ПолучитьПредставлениеДокументаФизЛица(ДанныеФизЛица)

	Возврат Строка(ДанныеФизЛица.ДокументВид) + " серия " +
			ДанныеФизЛица.ДокументСерия       + ", номер " +
			ДанныеФизЛица.ДокументНомер       + ", выданный " +
			Формат(ДанныеФизЛица.ДокументДатаВыдачи, "ДФ=dd.MM.yyyy")  + " " +
			ДанныеФизЛица.ДокументКемВыдан;

КонецФункции // ПолучитьПредставлениеДокументаФизЛица()

// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
//  либо по переданным строкам.
//  Если передан Объект, то извлеченная из него строка считается совокупностью 
//  Фамилия + Имя + Отчество, разделенными пробелами.
//
// Параметры
//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
//  Фамилия		- фамилия физ. лица.
//  Имя			- имя физ. лица.
//  Отчество	- отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
//  отдельным Фамилии,Имени и Отчеству
//
Функция ФамилияИнициалыФизЛица(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	ТипОбъекта = ТипЗнч(Объект);
	
	СписокТиповСсылок	= ОбщегоНазначенияПереопределяемый.ВернутьСписокТиповСсылокДляФормированияФИО();
	СписокТиповОбъектов	= ОбщегоНазначенияПереопределяемый.ВернутьСписокТиповОбъектовДляФормированияФИО();
	
	Если ТипОбъекта = Тип("Строка") Тогда
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
		
	ИначеЕсли ТипОбъекта <> Тип("Неопределено") И (СписокТиповСсылок.СодержитТип(ТипОбъекта) Или СписокТиповОбъектов.СодержитТип(ТипОбъекта)) Тогда
		Если СписокТиповСсылок.СодержитТип(ТипОбъекта) Тогда

			Наименование = ПолучитьЗначениеРеквизита(Объект, "Наименование");
		Иначе
			Наименование = Объект.Наименование;
		КонецЕсли;
	
		// Избавление от возможных выражений в скобках, например (осн.), (вн. совм.).
		НачальнаяПозиция	= Найти(Наименование,"(");
		КонечнаяПозиция		= Найти(Наименование,")");
		ДлинаСтроки			= СтрДлина(Наименование);
		Если НачальнаяПозиция > 0 Тогда
			СтрокаДляОбработки = Лев(Наименование, НачальнаяПозиция - 1) + ?(КонечнаяПозиция > 0,Прав(Наименование, ДлинаСтроки - КонечнаяПозиция),"")
		Иначе
			СтрокаДляОбработки = Наименование;
		КонецЕсли; 
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(СтрокаДляОбработки)," ");
		
		
	Иначе
		
		// используем возможно переданные отдельные строки
		Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"")
	КонецЕсли;
			
	КоличествоПодстрок = ФИО.Количество();
	Фамилия = ?(КоличествоПодстрок > 0,ФИО[0],"");
	Имя		= ?(КоличествоПодстрок > 1,ФИО[1],"");
	Отчество= ?(КоличествоПодстрок > 2,ФИО[2],"");
	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"");

КонецФункции

// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
//  либо по переданным строкам.
//  Если передан Объект, то извлеченная из него строка считается совокупностью 
//  Фамилия + Имя + Отчество, разделенными пробелами.
//
// Параметры
//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
//  Фамилия		- фамилия физ. лица.
//  Имя			- имя физ. лица.
//  Отчество	- отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
//  отдельным Фамилии,Имени и Отчеству
//
Функция ИнициалыФизЛицаФамилия(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	ТипОбъекта = ТипЗнч(Объект);
	
	Если ТипОбъекта = Тип("Строка") и Фамилия = "" Тогда
		
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
		
	ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или ТипОбъекта = Тип("СправочникОбъект.ФизическиеЛица") ИЛИ
			  ТипОбъекта = Тип("СправочникСсылка.СотрудникиОрганизаций") или ТипОбъекта = Тип("СправочникОбъект.СотрудникиОрганизаций") Тогда
	
		Если ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или 
			ТипОбъекта = Тип("СправочникСсылка.СотрудникиОрганизаций") Тогда
			Наименование = ПолучитьЗначениеРеквизита(Объект, "Наименование");
		Иначе
			Наименование = Объект.Наименование;
		КонецЕсли;
	
		// Избавление от возможных выражений в скобках, например (осн.), (вн. совм.).
		НачальнаяПозиция	= Найти(Наименование,"(");
		КонечнаяПозиция		= Найти(Наименование,")");
		ДлинаСтроки			= СтрДлина(Наименование);
		Если НачальнаяПозиция > 0 Тогда
			СтрокаДляОбработки = Лев(Наименование, НачальнаяПозиция - 1) + ?(КонечнаяПозиция > 0,Прав(Наименование, ДлинаСтроки - КонечнаяПозиция),"")
		Иначе
			СтрокаДляОбработки = Наименование;
		КонецЕсли; 
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(СтрокаДляОбработки)," ");
		
	Иначе
		
		// используем возможно переданные отдельные строки
		Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				"" + ?(НЕ ПустаяСтрока(Имя),Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), "") + " " + Фамилия ,
				"")
	КонецЕсли;
			
	КоличествоПодстрок = ФИО.Количество();
	Фамилия = ?(КоличествоПодстрок > 0,ФИО[0],"");
	Имя		= ?(КоличествоПодстрок > 1,ФИО[1],"");
	Отчество= ?(КоличествоПодстрок > 2,ФИО[2],"");
	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				"" + ?(НЕ ПустаяСтрока(Имя),Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+". ", ""), "") + " " + Фамилия,
				"");

КонецФункции

// Функция формирует фамилию и инициалы работника в заданном падеже 
// по переданным данным о работнике.
//  либо по переданным строкам.
//
// Параметры
//  Работник	- строка (Фамилия + Имя + Отчество, разделенными пробелами) 
//                или ссылка на элемент справочника ФизическиеЛица или Сотрудники.
//  Падеж (необязательный), тип число
//   Падеж, в который необходимо поставить ФИО.
//   1 - Именительный
//   2 - Родительный
//   3 - Дательный
//   4 - Винительный
//   5 - Творительный
//   6 - Предложный
//
//  Пол (необязательный), тип ПеречислениеСсылка.ПолФизическихЛиц
//   Данный параметр предназначен для разрешения возможных неоднозначностей
//   В остальных случаях рекомендуется опускать этот параметр.
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой.
//
Функция ПредставлениеРаботника(Работник, Знач Падеж = 1, Знач Пол = Неопределено) Экспорт

	ТипДанных = ТипЗнч(Работник);
	Если ТипДанных = Тип("Строка") Тогда
		РаботникФИО = Работник;
		РаботникПол = Пол;
	Иначе
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Работник", Работник);
		Если ТипДанных = Тип("СправочникСсылка.СотрудникиОрганизаций") Тогда
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	СотрудникиОрганизаций.Наименование,
			|	СотрудникиОрганизаций.Физлицо.Пол КАК Пол
			|ИЗ
			|	Справочник.СотрудникиОрганизаций КАК СотрудникиОрганизаций
			|ГДЕ
			|	СотрудникиОрганизаций.Ссылка = &Работник";
		Иначе
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	ФизическиеЛица.Наименование,
			|	ФизическиеЛица.Пол
			|ИЗ
			|	Справочник.ФизическиеЛица КАК ФизическиеЛица
			|ГДЕ
			|	ФизическиеЛица.Ссылка = &Работник";
		КонецЕсли;
		
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			РаботникФИО = Выборка.Наименование;
			РаботникПол = Выборка.Пол;
		Иначе
			Возврат ""
		КонецЕсли;
	КонецЕсли;
	
	ФИО = ОбщегоНазначения.ФамилияИнициалыФизЛица(РаботникФИО);
	
	ПозицияПервогоПробела = Найти(ФИО + " "," ");
	Фамилия  = Лев(ФИО,ПозицияПервогоПробела-1);
	Инициалы = Сред(ФИО,ПозицияПервогоПробела+1);
	
	РезультатСклонения = "";
	Если УниверсальныеМеханизмы.Просклонять(глЗначениеПеременной("глКомпонентаСклоненияФИО"), Фамилия, Падеж, РаботникПол, РезультатСклонения) Тогда
		ФИО = РезультатСклонения + " " + Инициалы;	
	КонецЕсли;
	
	Возврат ФИО
	
КонецФункции

// Функция возвращает совокупность данных о физическом лице в виде структуры, 
// В совокупность данных входит ФИО, должность в заданной организации, 
// паспортные данные и др.
//
// Параметры:
//  Организация  - СправочникСсылка.Организации - организация, по которой
//                 определяется должность и подразделение работника
//  ФизЛицо      - СправочникСсылка.ФизическиеЛица - физическое лицо,
//                 по которому возвращается совокупность данных
//  ДатаСреза    - Дата - дата, на которую считываются данные
//  ФИОКратко    - Булево - если Истина (по умолчанию), Представление физ.лица включает фамилию и инициалы, если Ложь - фамилию и полностью имя и отчество
//
// Возвращаемое значение:
//  Структура    - Структура с совокупностью данных о физическом лице:
//                 - Фамилия
//                 - Имя
//                 - Отчетсво
//                 - Представление (Фамилия И.О.)
//                 - Подразделение
//                 - ДокументВид
//                 - ДокументСерия
//                 - ДокументНомер
//                 - ДокументДатаВыдачи
//                 - ДокументКемВыдан
//                 - ДокументКодПодразделения
//
Функция ДанныеФизЛица(Организация, ФизЛицо, ДатаСреза, ФИОКратко = Истина) Экспорт
	
	ЗапросПоЛицам = Новый Запрос();
	ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
	ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
	ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
	ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество,
	|	РаботникиОрганизацийСрезПоследних.ТабельныйНомер,
	|	РаботникиОрганизацийСрезПоследних.Должность,
	|	РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКодПодразделения
	|ИЗ
	|	(ВЫБРАТЬ Ссылка КАК ФизЛицо ИЗ Справочник.ФизическиеЛица ГДЕ Ссылка = &ФизЛицо) КАК ФизЛица
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ФИОФизЛицСрезПоследних
	|	ПО ФизЛица.ФизЛицо = ФИОФизЛицСрезПоследних.ФизЛицо
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|	ПО ФизЛица.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо
	|	ЛЕВОЕ СОЕДИНЕНИЕ 
	|		(ВЫБРАТЬ 
	|			РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
	|			РаботникиОрганизацийСрезПоследних.Сотрудник.ФизЛицо КАК ФизЛицо,
	|			РаботникиОрганизацийСрезПоследних.Должность КАК Должность,
	|			РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации КАК ПодразделениеОрганизации
	|		ИЗ
	|			РегистрСведений.РаботникиОрганизаций.СрезПоследних(&ДатаСреза,	Сотрудник.ФизЛицо = &ФизЛицо И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	|		ГДЕ
	|			РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
	|		) КАК РаботникиОрганизацийСрезПоследних
	|	ПО ФизЛица.ФизЛицо = РаботникиОрганизацийСрезПоследних.Физлицо
	|";
	
	Данные = ЗапросПоЛицам.Выполнить().Выбрать();
	Данные.Следующий();
	
	Результат = Новый Структура("Фамилия, Имя, Отчество, Представление, 
								|ТабельныйНомер, Должность, ПодразделениеОрганизации, 
								|ДокументВид, ДокументСерия, ДокументНомер,  
								|ДокументДатаВыдачи, ДокументКемВыдан, ДокументКодПодразделения, 
								|ПредставлениеДокумента");

	ЗаполнитьЗначенияСвойств(Результат, Данные);

	Результат.Представление          = ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество, ФИОКратко);
	Результат.ПредставлениеДокумента = ПолучитьПредставлениеДокументаФизЛица(Данные);
	
	Возврат Результат;
	
КонецФункции // ДанныеФизЛица

// Функция возвращает совокупность данных о физических лицах в виде таблицы
// значений. В совокупность данных входит ФИО, должность в заданной 
// организации, паспортные данные и др.
//
// Параметры:
//  Организация  - СправочникСсылка.Организации - организация, по которой
//                 определяется должность и подразделение работника(ов)
//  ФизЛицо      - СправочникСсылка.ФизическиеЛица или Массив - физическое лицо
//                 или список физ. лиц, по которым возвращается совокупность 
//                 данных
//  ДатаСреза    - Дата - дата, на которую считываются данные
//
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица с совокупностью данных о физическом лице. 
//                  Колонки: возвращаемой таблицы:
//                  - Фамилия
//                  - Имя
//                  - Отчетсво
//                  - Представление (Фамилия И.О.)
//                  - Подразделение
//                  - ДокументВид
//                  - ДокументСерия
//                  - ДокументНомер
//                  - ДокументДатаВыдачи
//                  - ДокументКемВыдан
//                  - ДокументКодПодразделения
//
Функция ДанныеФизЛиц(Организация, ФизЛицо, ДатаСреза) Экспорт

	ЗапросПоЛицам = Новый Запрос();
	ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
	ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
	ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
	ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество,
	|	РаботникиОрганизацийСрезПоследних.ТабельныйНомер,
	|	РаботникиОрганизацийСрезПоследних.Должность,
	|	РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКодПодразделения
	|ИЗ
	|	(ВЫБРАТЬ Ссылка КАК ФизЛицо ИЗ Справочник.ФизическиеЛица ГДЕ Ссылка В (&ФизЛицо)) КАК ФизЛица
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В (&ФизЛицо)) КАК ФИОФизЛицСрезПоследних
	|	ПО ФизЛица.ФизЛицо = ФИОФизЛицСрезПоследних.ФизЛицо
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В (&ФизЛицо)) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|	ПО ФизЛица.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо
	|	ЛЕВОЕ СОЕДИНЕНИЕ 
	|		(ВЫБРАТЬ 
	|			РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
	|			РаботникиОрганизацийСрезПоследних.Сотрудник.ФизЛицо КАК ФизЛицо,
	|			РаботникиОрганизацийСрезПоследних.Должность КАК Должность,
	|			РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации КАК ПодразделениеОрганизации
	|		ИЗ
	|			РегистрСведений.РаботникиОрганизаций.СрезПоследних(&ДатаСреза,	Сотрудник.ФизЛицо В (&ФизЛицо) И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	|		ГДЕ
	|			РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
	|		) КАК РаботникиОрганизацийСрезПоследних
	|	ПО ФизЛица.ФизЛицо = РаботникиОрганизацийСрезПоследних.Физлицо
	|";
	
	Данные = ЗапросПоЛицам.Выполнить().Выбрать();
	
	ТабРезультат = Новый ТаблицаЗначений();
	ТабРезультат.Колонки.Добавить("Фамилия");
	ТабРезультат.Колонки.Добавить("Имя");
	ТабРезультат.Колонки.Добавить("Отчество");
	ТабРезультат.Колонки.Добавить("Представление");
	ТабРезультат.Колонки.Добавить("ТабельныйНомер");
	ТабРезультат.Колонки.Добавить("Должность");
	ТабРезультат.Колонки.Добавить("ПодразделениеОрганизации");
	ТабРезультат.Колонки.Добавить("ДокументВид");
	ТабРезультат.Колонки.Добавить("ДокументСерия");
	ТабРезультат.Колонки.Добавить("ДокументНомер");
	ТабРезультат.Колонки.Добавить("ДокументДатаВыдачи");
	ТабРезультат.Колонки.Добавить("ДокументКемВыдан");
	ТабРезультат.Колонки.Добавить("ДокументКодПодразделения");
	ТабРезультат.Колонки.Добавить("ПредставлениеДокумента");
								
	Пока Данные.Следующий() Цикл
		
		Результат = ТабРезультат.Добавить();
		
		ЗаполнитьЗначенияСвойств(Результат, Данные);

		Результат.Представление          = ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество);
		Результат.ПредставлениеДокумента = ПолучитьПредставлениеДокументаФизЛица(Данные);
		
	КонецЦикла;

	Возврат ТабРезультат;
	
КонецФункции // ДанныеФизЛиц

// Функция формирует фамилию и инициалы
//
// Параметры
//  Фамилия  - фамилия физ. лица.
//  Имя      - имя физ. лица.
//  Отчество - отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия, имя, отчество одной строкой.
//
Функция ПолучитьФамилиюИмяОтчество(Фамилия = " ", Имя = " ", Отчество = " ", ФИОКратко = Истина) Экспорт

	Если ФИОКратко Тогда
		Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + 
				?(НЕ ПустаяСтрока(Отчество) , 
				Лев(Отчество,1)+".", ""), ""), "");
	Иначе
		Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Имя + 
				?(НЕ ПустаяСтрока(Отчество) , " " + Отчество, ""), ""), "");
	КонецЕсли;

КонецФункции // ПолучитьФамилиюИмяОтчество()

Функция ПолучитьМассивПрефиксовРИБ()
	
	МассивПрефиксов = Новый Массив();
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ Различные
	               |	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
	               |ИЗ
	               |	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз";
	
	ВыборкаУзлов = Запрос.Выполнить().Выбрать();
	Пока ВыборкаУзлов.Следующий() Цикл
		
		Если Не ПустаяСтрока(ВыборкаУзлов.Префикс) Тогда
			
			МассивПрефиксов.Добавить(ВыборкаУзлов.Префикс);
			
		КонецЕсли;
		
	КонецЦикла;	
	
	Возврат МассивПрефиксов;
	
КонецФункции

Функция СформироватьМассивПрефиксовДляРИБИОрганизации(Организация) Экспорт
	
	МассивПрефиксов = ПолучитьМассивПрефиксовРИБ();	
	
	Если ЗначениеЗаполнено(Организация)
		И ТипЗнч(Организация) = Тип("СправочникСсылка.Организации") Тогда
		
		Префикс = СокрЛП(Организация.Префикс);
		
		Если Префикс <> "" Тогда
			МассивПрефиксов.Добавить(Префикс);
		КонецЕсли;
		
	КонецЕсли;
	
	Если МассивПрефиксов.Количество() = 0 Тогда
		МассивПрефиксов.Добавить("");
	КонецЕсли;
	
	Возврат МассивПрефиксов;
	
КонецФункции

// Заполнение отбора значениями из таблицы значений.
// Соответствие полей устанавливается по представлению и типам значений
//
// Параметры
//  Отбор  – Отбор           – Отбор, который требуется заполнить значениями
//  ТЗ     – ТаблицаЗначений – Таблица содержит значения для отбора.
//                             Структура колонок повторяет структуру отбора
//
Процедура ЗаполнитьОтборПоТаблицеЗначений(Отбор, ТЗ) Экспорт

	Для каждого ЭлементОтбора Из ТЗ Цикл
	
		СтрокаТаблицы = Неопределено;
		
		Для каждого стр Из Отбор Цикл
			
			Если стр.Представление = ЭлементОтбора.Представление
				И стр.ТипЗначения = ЭлементОтбора.ТипЗначения Тогда
				Если ПустаяСтрока(стр.Представление)
					И ПустаяСтрока(стр.ПутьКданным) Тогда
					
					Продолжить;
					
				КонецЕсли;
				СтрокаТаблицы = стр;
				
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если ПустаяСтрока(ЭлементОтбора.ПутьКданным) Тогда
			Продолжить;
		КонецЕсли;
		
		Если СтрокаТаблицы = Неопределено Тогда
			
			СтрокаТаблицы = Отбор.Добавить(ЭлементОтбора.ПутьКданным, ЭлементОтбора.Имя, ЭлементОтбора.Представление);		
					
		КонецЕсли;
		
		СтрокаТаблицы.ВидСравнения = ЭлементОтбора.ВидСравнения;
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, ЭлементОтбора, "Значение, ЗначениеПо, ЗначениеС, Использование");
			
	КонецЦикла;

КонецПроцедуры // УстановитьОтборИзТаблицы(Отбор, ТЗ)

// Функция выделяет первое слово в предложении
Функция ВыделитьСлово(ИсходнаяСтрока) Экспорт
	
	Буфер = СокрЛ(ИсходнаяСтрока);
	ПозицияПослПробела = Найти(Буфер, " ");

	Если ПозицияПослПробела = 0 Тогда
		ИсходнаяСтрока = "";
		Возврат Буфер;
	КонецЕсли;
	
	ВыделенноеСлово = СокрЛП(Лев(Буфер, ПозицияПослПробела));
	ИсходнаяСтрока = Сред(ИсходнаяСтрока, ПозицияПослПробела + 1);
	
	Возврат ВыделенноеСлово;
	
КонецФункции

// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - форма слова в ед числе      ("шкаф")
//  Слово2 - форма слова для числит 2-4  ("шкафа")
//  Слово3 - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - целое число
//
// Возвращаемое значение:
//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, Знач ЦелоеЧисло) Экспорт
	
	// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться
	Если ЦелоеЧисло < 0 Тогда
		ЦелоеЧисло = -1 * ЦелоеЧисло;
	КонецЕсли;
	
	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции

// Процедура вычисляет количество лет, месяцев и дней между двумя датами
//
// Параметры
//  Дата1	– дата, первая дата (более поздняя, часто текущая, стаж определяется по состоянию на эту дату)
//  Дата2	– дата, вторая дата (ранняя дата, с нее начинается "течение" стажа)
//  Лет		– Число, в этот параметр будет записано кол-во лет между двумя датами (Дата1-Дата2)
//  Месяцев	– Число, в этот параметр будет записано кол-во месяцев между двумя датами (Дата1-Дата2)
//  Дней	– Число, в этот параметр будет записано кол-во дней между двумя датами (Дата1-Дата2)
//
Процедура РазобратьРазностьДат(Дата1, Дата2, Лет = 0, Месяцев = 0, Дней = 0) Экспорт
	
	Лет		= 0;
	Месяцев	= 0;
	Дней	= 0;
	Если Дата1 > Дата2 Тогда
		
		ВременнаяДата = Дата1;
		Если День(ВременнаяДата) < День(Дата2) Тогда
			Дней = (ВременнаяДата - ДобавитьМесяц(ВременнаяДата,-1))/86400;
			ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-1);
		КонецЕсли;
		Если Месяц(ВременнаяДата) < Месяц(Дата2) Тогда
			ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-12);
			Месяцев = 12;
		КонецЕсли;
		Лет		= Макс(			 Год(ВременнаяДата)		- Год(Дата2),	0);
		Месяцев	= Макс(Месяцев	+ Месяц(ВременнаяДата)	- Месяц(Дата2),	0);
		Дней	= Макс(Дней		+ День(ВременнаяДата)	- День(Дата2),	0);
		
		// скорректируем отображаемое значение, если "вмешалось" разное количество дней в месяцах
		Если Дата2 <> (ДобавитьМесяц(Дата1,-Лет*12-Месяцев)-Дней*86400) Тогда
			Дней = Дней + ((ДобавитьМесяц(Дата1,-Лет*12-Месяцев)-Дней*86400) - Дата2)/86400;
			//(День(КонецМесяца(Дата2)) - День(НачалоМесяца(Дата2))) - (День(КонецМесяца(ДобавитьМесяц(Дата1,-1))) - День(НачалоМесяца(ДобавитьМесяц(Дата1,-1))));
		КонецЕсли;
		
	КонецЕсли;

КонецПроцедуры	// РазобратьРазностьДат

// Функция определяет дату и время начала календарной декады для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьНачалоДекады(ИсходнаяДата) Экспорт

	ДеньМесяца = День(ИсходнаяДата);

	Если ДеньМесяца <= 10 Тогда
		Результат = НачалоМесяца(ИсходнаяДата);
	ИначеЕсли ДеньМесяца <= 20 Тогда
		Результат = НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 10;
	Иначе
		Результат = НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 20;
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьНачалоДекады()

// Функция определяет дату и время конца календарной декады для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьКонецДекады(ИсходнаяДата) Экспорт

	ДеньМесяца = День(ИсходнаяДата);

	Если ДеньМесяца <= 10 Тогда
		Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 9);
	ИначеЕсли ДеньМесяца <= 20 Тогда
		Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 19);
	Иначе
		Результат = КонецМесяца(ИсходнаяДата);
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьКонецДекады()

// Функция определяет дату и время начала полугодия для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьНачалоПолугодия(ИсходнаяДата) Экспорт

	Если Месяц(ИсходнаяДата) < 7 Тогда
		Результат = НачалоГода(ИсходнаяДата);
	Иначе
		Результат = ДобавитьМесяц(НачалоГода(ИсходнаяДата), 6);
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьНачалоПолугодия()

// Функция определяет дату и время конца полугодия для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьКонецПолугодия(ИсходнаяДата) Экспорт

	Если Месяц(ИсходнаяДата) < 7 Тогда
		Результат = ДобавитьМесяц(КонецГода(ИсходнаяДата), -6);
	Иначе
		Результат = КонецГода(ИсходнаяДата);
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьКонецПолугодия()

// функция из исходной строки формирует строку для поиска данных в запросе
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");

	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Функция формирует представление заголовка документа
//
// Возвращаемое значение:
//  Строка - представление номера документа
//
Функция СформироватьЗаголовокДокумента(ДокументОбъект, НазваниеДокумента = "") Экспорт

	Если ДокументОбъект = Неопределено Тогда
		Возврат "";
	Иначе
			Возврат ?(НЕ ЗначениеЗаполнено(НазваниеДокумента), ДокументОбъект.Метаданные().Синоним, НазваниеДокумента ) + " № " + ПолучитьНомерНаПечать(ДокументОбъект)
	                          + " от " + Формат(ДокументОбъект.Дата, "ДФ='дд ММММ гггг'");
	КонецЕсли;

КонецФункции // СформироватьЗаголовокДокумента()

// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция СформироватьСуммуПрописью(Сумма, Валюта) Экспорт

	Если Валюта.ПараметрыПрописиНаРусском = "" Тогда
		Возврат ФорматСумм(Сумма);
	Иначе
		Возврат ЧислоПрописью(Сумма, "L=ru_RU", Валюта.ПараметрыПрописиНаРусском);
	КонецЕсли;

КонецФункции // СформироватьСуммуПрописью()

Процедура ДобавитьПрефиксОрганизации(ДокументОбъект, Префикс) Экспорт
 	
	// Если в документе нет реквизита "Организация" или для организации не задан префикс,
	// то используем пустой префикс, иначе используем префикс организации.
	Префикс = "0";
	
	Если ДокументОбъект.Метаданные().Реквизиты.Найти("Организация") <> Неопределено Тогда
		ПрефиксОрганизации = ПолучитьЗначениеРеквизита(ДокументОбъект.Организация, "Префикс");
		Если ЗначениеЗаполнено(ПрефиксОрганизации) Тогда
			Префикс = ПрефиксОрганизации;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры
	
// процедура формирования номера документа
Процедура ПриУстановкеНовогоНомераДляДокументов(Источник, СтандартнаяОбработка, Префикс) Экспорт
	ДобавитьПрефиксОрганизации(Источник, Префикс);
//	ДобавитьПрефиксУзла(Префикс);
КонецПроцедуры

//Процедура выполняет удаление движений документа по регистрам при отмене проведения
//	Является обработчиком подписки на событие "ОбработкаУдаленияПроведенияДокумента"
//
Процедура ОбработкаУдаленияПроведенияДокумента(Источник, Отказ) Экспорт
	
	УдалитьДвиженияРегистратора(Источник, Отказ);
	
КонецПроцедуры

Процедура ПриУстановкеНовогоКодаДляСправочникаИлиПВХ(Источник, СтандартнаяОбработка, Префикс) Экспорт
 	ДобавитьПрефиксУзла(Префикс);
КонецПроцедуры

// Проверяет дату на заполненность по аналогии с системной функцией "ПустаяСтрока".
// 
Функция ПустаяДата(ПроверяемаяДата) Экспорт
	
	Если ТипЗнч(ПроверяемаяДата) = Тип("Дата") 
	   И ПроверяемаяДата = Дата(1,1,1) Тогда
	   
		Возврат Истина;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции // ПустаяДата()

// Функция возвращает массив вышестоящих групп указанного элемента.
// 
// Переметры:
//  Элемент      - Элемент справочника, для которого ищется родитель
//
// Возвращаемое значение
//  Массив вышестояших групп
//
Функция ПолучитьСписокВышеСтоящихГрупп(ЭлементСправочника) Экспорт
	
	Результат = Новый Массив;		
	
	Если НЕ ЗначениеЗаполнено(ЭлементСправочника) Тогда
		Возврат Результат;
	КонецЕсли;
	
	МетаданныеСправочника = ЭлементСправочника.Метаданные();
	Если НЕ МетаданныеСправочника.Иерархический Тогда
		Возврат Результат;
	КонецЕсли;
	ИмяСправочника = МетаданныеСправочника.Имя;	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Справочник1.Родитель КАК Родитель1,
	|	Справочник2.Родитель КАК Родитель2,
	|	Справочник3.Родитель КАК Родитель3,
	|	Справочник4.Родитель КАК Родитель4,
	|	Справочник5.Родитель КАК Родитель5
	|ИЗ
	|	Справочник." + ИмяСправочника + " КАК Справочник1
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник2
	|		ПО (Справочник2.Ссылка = Справочник1.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник3
	|		ПО (Справочник3.Ссылка = Справочник2.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник4
	|		ПО (Справочник4.Ссылка = Справочник3.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник5
	|		ПО (Справочник5.Ссылка = Справочник4.Родитель)
	|ГДЕ
	|	Справочник1.Ссылка = &Ссылка";
	
	ТекущийЭлемент = ЭлементСправочника;
	
	Пока ЗначениеЗаполнено(ТекущийЭлемент) Цикл		
		Запрос.УстановитьПараметр("Ссылка", ТекущийЭлемент);
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			Для Индекс = 1 по 5 Цикл
				ТекущийЭлемент = Выборка["Родитель" + Индекс];
				Если ЗначениеЗаполнено(ТекущийЭлемент) Тогда
					Результат.Добавить(ТекущийЭлемент);
				Иначе
					Прервать;
				КонецЕсли;				
			КонецЦикла;
		Иначе
			ТекущийЭлемент = Неопределено;
		КонецЕсли;
	КонецЦикла;	
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПИСИ НАБОРОВ ЗАПИСЕЙ РЕГИСТРОВ, КОНСТАНТ

// Проверяет значения констант из коллекции с текущим значением в ИБ,
// не проверяется для типа данных ХранилищеЗначений
// 
// Параметры: 
//  КоллекцияКонстантДляПроверки  - структура
//									ключ 		- строка, имя константы
//									значение 	- значение константы
//
// Возвращаемое значение:
//  Массив констант значение которых изменилось по сравнению с переданной коллекцией
//
Функция СоздатьМассивИзмененныхКонстант(КоллекцияКонстантДляПроверки) Экспорт
	
	МассивИзмененныхКонстант = Новый Массив;
	
	Для каждого ЭлементКоллекции Из КоллекцияКонстантДляПроверки Цикл
		
		ИмяКонстанты 	  = ЭлементКоллекции.Ключ;
		ЗначениеКонстанты = ЭлементКоллекции.Значение;
		
		ТекущееЗначение   = Константы[ИмяКонстанты].Получить();
		Если  ТипЗнч(ТекущееЗначение) = Тип("ХранилищеЗначения") Тогда
			// не сравниваем значения констант, у которых Тип данных - Хранилище значений
			Продолжить;
		КонецЕсли;	
		
		Если ЗначениеКонстанты <> ТекущееЗначение Тогда
			МассивИзмененныхКонстант.Добавить(Метаданные.Константы[ИмяКонстанты]);
		КонецЕсли;
	
	КонецЦикла;
	
	Возврат МассивИзмененныхКонстант;
	
КонецФункции

// Функция выполняет запись переданного набора записей и 
// формирует сообщение об ошибке, если не удалось записать набор
//
// Параметры
//  НаборЗаписей  - набор записей регистра сведений, который необходимо записать
//
// Возвращаемое значение:
//   Булево   - Истина, когда набор записей записан
//
Функция ЗаписатьНабор(НаборЗаписей) Экспорт

	Попытка
		НаборЗаписей.Записать();
	Исключение
		ВывестиИнформациюОбОшибке(ПолучитьПричинуОшибки(ИнформацияОбОшибке()).Описание);
		Возврат Ложь;
	КонецПопытки;

	Возврат Истина;
	
КонецФункции
//АК БЕЛН 25.03.2016++
Функция ПолучитьЗначениеКонстанты(ИмяКонстанты) Экспорт
	УстановитьПривилегированныйРежим(Истина);
    Возврат Константы[ИмяКонстанты].Получить();
КонецФункции // ()
//АК БЕЛН 25.03.2016--
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ НАСТРОЙКИ ПОРЯДКА ЭЛЕМЕНТОВ СПРАВОЧНИКА

// Вспомогательная функция для определнения условий запроса в механизме
// изменения порядка следования элементов. Ставит условия на родителя и владельца
//
// Параметры
//  Элемент - СправочникСсылка, для которого необходимо изменить порядок
//  Запрос - Запрос, в который дописываем условия
// 
//  Возвращаемое значение:
//   Строка - условие запроса
// 
Функция ПолучитьДополнениеЗапроса(Элемент, Запрос, БезПервогоИ = Ложь)

	ТекстЗапроса = "";
	
	Если Элемент.Метаданные().Иерархический = Истина Тогда
		Запрос.УстановитьПараметр("ТекущийРодитель", Элемент.Родитель);
		Если НЕ БезПервогоИ Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Родитель = &ТекущийРодитель
		|";
	КонецЕсли; 
	
	Если Элемент.Метаданные().Владельцы.Количество() > 0 Тогда
		Запрос.УстановитьПараметр("ТекущийВладелец", Элемент.Владелец);
		Если НЕ (ПустаяСтрока(ТекстЗапроса) И БезПервогоИ) Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Владелец = &ТекущийВладелец
		|";
	КонецЕсли; 

	Возврат ТекстЗапроса;
	
КонецФункции

// Возвращает значение порядка для нового элемента справочника.
//
// Параметры
//  ЭлементОбъект - СправочникОбъект - новый объект
//
// Возвращаемое значение:
//   Число - новый порядок
//
Функция НазначитьНовыйПорядок(ЭлементОбъект)

	ИмяТаблицы = ЭлементОбъект.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	СправочникПорядка.Порядок
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка";
	
	ДополнениеЗапроса = ПолучитьДополнениеЗапроса(ЭлементОбъект, Запрос, Истина);
	
	Если НЕ ПустаяСтрока(ДополнениеЗапроса) Тогда
		Запрос.Текст = Запрос.Текст + "
		|ГДЕ
		|" + ДополнениеЗапроса + "
		|";
	КонецЕсли; 
	
	Запрос.Текст = Запрос.Текст + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок УБЫВ
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат (Выборка.Порядок + 1)
	КонецЕсли; 

КонецФункции

// Процедура вызывается перед записью объекта, для которого необходимо
// контролировать порядок элементов.
// 
// Параметры
//  Отказ - Булево, отказ от записи объекта
//  ЭтотОбъект - СправочникОбъект
//  КонтролироватьПорядок - Булево, контролировать порядок при записи объекта или нет
//
Процедура ПередЗаписьюОбъектаПорядка(Отказ, ЭтотОбъект, КонтролироватьПорядок) Экспорт

	Если ЭтотОбъект.ЭтоНовый() Тогда
		ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
	Иначе
		Если ЭтотОбъект.Ссылка.Родитель <> ЭтотОбъект.Родитель ИЛИ ЭтотОбъект.Ссылка.Владелец <> ЭтотОбъект.Владелец Тогда
			ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
		КонецЕсли;
	КонецЕсли;
	
	Если КонтролироватьПорядок Тогда
	
		ИмяТаблицы = ЭтотОбъект.Метаданные().Имя;
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ЭтотОбъект.Порядок);
		
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Порядок
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок = &ТекущийПорядок
		|";
		
		Если НЕ ЭтотОбъект.ЭтоНовый() Тогда
			Запрос.УстановитьПараметр("ТекущаяСсылка", ЭтотОбъект.Ссылка);
			Запрос.Текст = Запрос.Текст + "
			|И
			|	СправочникПорядка.Ссылка <> &ТекущаяСсылка
			|";
		КонецЕсли; 
		
		Запрос.Текст = Запрос.Текст + ПолучитьДополнениеЗапроса(ЭтотОбъект, Запрос);
		
		Если НЕ Запрос.Выполнить().Пустой() Тогда
			Отказ = Истина;
			#Если Клиент Тогда
				Сообщить("Не уникальный порядок элемента справочника.");
			#КонецЕсли
		КонецЕсли;
	
	КонецЕсли; 

КонецПроцедуры

// Процедура изменяет порядок следования объектов с настраиваемым из ВЯ
// порядком следования.
// 
// Параметры:
//  ЭлементСсылка - СправочникСсылка, элемент для которого необходимо изменить порядок
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
Процедура ИзменитьПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг = Истина) Экспорт
	
	ЭлементЗамены = ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг);
	
	Если ЭлементЗамены = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НовыйПорядокЗамены   = ЭлементЗамены.Порядок;
	НовыйПорядокЭлемента = ЭлементСсылка.Порядок;
	
	Если НаправлениеПорядка = "Вверх" Тогда
		Если НовыйПорядокЗамены < НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены + 1;
		КонецЕсли; 
	Иначе
		Если НовыйПорядокЗамены > НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены - 1;
		КонецЕсли;
	КонецЕсли;
	
	НачатьТранзакцию();
	
	ФиксироватьТранзакцию = Истина;
	
	Если НовыйПорядокЗамены <> ЭлементЗамены.Порядок Тогда
		ОбъектЗамены = ЭлементЗамены.ПолучитьОбъект();
		ОбъектЗамены.Порядок = НовыйПорядокЗамены;
		ОбъектЗамены.КонтролироватьПорядок = Ложь;
		Попытка
			ОбъектЗамены.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли; 
	
	Если ФиксироватьТранзакцию Тогда
		ОбъектЭлемента = ЭлементСсылка.ПолучитьОбъект();
		ОбъектЭлемента.Порядок = НовыйПорядокЭлемента;
		Попытка
			ОбъектЭлемента.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Если ФиксироватьТранзакцию Тогда
		ЗафиксироватьТранзакцию();
	Иначе
		ОтменитьТранзакцию();
	КонецЕсли; 
	
КонецПроцедуры

// Функция определяет элемент справочника, с которым необходимо
// произвести "рокировку" текущего элемента
//
// Параметры
//  ЭлементСсылка - СпраовочникСсылка, элемент для изменения порядка
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
// Возвращаемое значение:
//   СправочникСсылка
//
Функция ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг)

	ТекущийПорядок = ЭлементСсылка.Порядок;
	
	ИмяТаблицы = ЭлементСсылка.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	СправочникПорядка.Ссылка
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
	|ГДЕ
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "<", ">") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
		
	ИначеЕсли ЦиклическийСдвиг Тогда
		// Текущий элемент или первый (при движении вверх)
		// или последний (при движении вниз)
		// или вообще единственный
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Ссылка
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", ">", "<") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
		|УПОРЯДОЧИТЬ ПО
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
		|";
		
		РезультатЗапроса = Запрос.Выполнить();
		
		Если РезультатЗапроса.Пустой() Тогда
			Возврат Неопределено;
		Иначе
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			Возврат Выборка.Ссылка;
		КонецЕсли; 
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

//Предназначена для получения массива пустых значений, содержащих значение Неопределено и значения переданного типа или описания типов
Функция МассивПустыхЗначений(ОписаниеТипов) Экспорт
	МассивЗначений = новый Массив;
	МассивЗначений.Добавить(неопределено);
	Если ТипЗнч(ОписаниеТипов)=Тип("ОписаниеТипов") Тогда
		Для каждого Тип из ОписаниеТипов.Типы() Цикл
			МассивЗначений.Добавить(ПустоеЗначениеТипа(Тип));
		КонецЦикла;
	ИначеЕсли ТипЗнч(ОписаниеТипов)=Тип("Тип") Тогда	
		МассивЗначений.Добавить(ПустоеЗначениеТипа(ОписаниеТипов));
	КонецЕсли;
	
	Возврат МассивЗначений;

КонецФункции

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
	// есть таб. часть в документе
	Возврат ТабЧасть <> Неопределено И ТабЧасть.Реквизиты.Найти(ИмяРеквизита) <> Неопределено

КонецФункции // ЕстьРеквизитТабЧастиДокумента()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

	СписокКодовЧисел = Новый СписокЗначений;
	Для а = 48 По 57 Цикл
		СписокКодовЧисел.Добавить(а);
	КонецЦикла; 
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			Если СписокКодовЧисел.НайтиПоЗначению(КодСимвола(Сред(СтрокаПроверки, а, 1))) = Неопределено Тогда
				Возврат Истина;
			КонецЕсли; 
		КонецЦикла; 
		
	КонецЕсли; 

	Возврат Ложь;
	
КонецФункции

// Если в шапке переданного документа есть реквизит с указанным именем, то возвращается его значение.
// Если такого реквизита нет - возвращается Неопределено.
//
// Параметры:
//  ИмяРеквизита - Строка. Имя искомого реквизита.
//  ДокументОбъект - объект переданного документа.
//  МетаданныеДокумента - Метаданные переданного документа.
//  ПустоеЗначение - значение, которое должно вернуться, если в шапке нет такого реквизита,
//  если не передано, то возвращается значение Неопределено.
//
// Возвращаемое значение:
//  Значение реквизита - значение найденного реквизита или ПустоеЗначение.
//
Функция ПолучитьРеквизитШапки(ИмяРеквизита, ДокументОбъект, МетаданныеДокумента, ПустоеЗначение = Неопределено) Экспорт

	ЗначениеРеквизита = ?(МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) <> Неопределено,
	                      ДокументОбъект[ИмяРеквизита], ПустоеЗначение);

	Возврат ЗначениеРеквизита;

КонецФункции // ПолучитьРеквизитШапки()

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ЗАГРУЗКИ КЛАССИФИКАТОРОВ

Процедура ЗагрузитьКлассификаторИзXML(ПустойЭлементСправочника, ИмяФайлаПоУмолчанию) Экспорт
	
	ФормаЗагрузки = ПолучитьОбщуюФорму("ФормаЗагрузкиКлассификатораИзXML");
	ФормаЗагрузки.ПустойЭлементСправочника = ПустойЭлементСправочника;
	ФормаЗагрузки.ИмяФайлаПоУмолчанию = ИмяФайлаПоУмолчанию;
	ФормаЗагрузки.Открыть();
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Функнция проверяет заполнения обязательных параметров для отправки сообщения
//  в отдел технической поддержки.
//
// Параметры
//  ТаблицаДанных - Таблица значений
//
// Возвращаемое значение:
//   Булево - результат корректости проверки
//
Функция ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(ТаблицаДанных, ПубликоватьСообщения = Истина) Экспорт

	ЗначениеПроверки = Истина;
	СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";
	
	СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
	СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
	СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
	
	Для каждого СтрокаРаздела Из ТаблицаДанных Цикл
		Для каждого ЭлементЗначения Из СтрокаРаздела.ДанныеРаздела Цикл
			Если СписокИменОбязательныхРеквизитов.НайтиПоЗначению(ЭлементЗначения.Ключ) <> Неопределено И НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
				Если ПубликоватьСообщения Тогда
					СообщитьОбОшибке("Не указан """ + Лев(ЭлементЗначения.Значение[0], (СтрДлина(ЭлементЗначения.Значение[0]) - 1)) + """.",, СтрокаЗаголовкаОшибки);
				КонецЕсли; 
				ЗначениеПроверки = Ложь;
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
	Возврат ЗначениеПроверки;

КонецФункции // ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()

// Процедура формирует таблицу значений со структурой для заполнения данными
// с информацией обращения в отдел технической поддержки
//
// Параметры:
//  ТаблицаДанных - таблица значений для заполнения
//  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
//
Процедура ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(ТаблицаДанных, ФормаНастройкиПараметров = Неопределено) Экспорт

	// Структура данных - таблица значений:
	//  Колонки:
	//   ИмяРездела
	//   ПредставлениеРаздела
	//   ДанныеРаздела
	
	// Структура данных раздела
	//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
	//  Значение - Массив значений
	// 
	// Массив значений:
	//  [0] - Представление наименования параметра для печати
	//  [1] - Значение параметра

	Если ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений") Тогда
		ТаблицаДанных = Новый ТаблицаЗначений;
	КонецЕсли;
	
	Если ТаблицаДанных.Колонки.Количество() = 0 Тогда
		ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));
		ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));
	КонецЕсли;
	
	ТаблицаДанных.Индексы.Добавить("ИмяРаздела");
	
	Если ФормаНастройкиПараметров = Неопределено Тогда
		ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");
	КонецЕсли;
	
	Для каждого ЭлементФормы Из ФормаНастройкиПараметров.ЭлементыФормы Цикл
		
		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеВвода")
		   И ТипЗнч(ЭлементФормы) <> Тип("ПолеВыбора")
		   И ТипЗнч(ЭлементФормы) <> Тип("Флажок") Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияРазделителяРаздела = Найти(ЭлементФормы.Имя, "_");
		Если ПозицияРазделителяРаздела = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяРаздела = Сред(ЭлементФормы.Имя, 1, (ПозицияРазделителяРаздела - 1));
		СтрокаРаздела = ТаблицаДанных.Найти(ИмяРаздела, "ИмяРаздела");
		Если СтрокаРаздела = Неопределено Тогда
			СтрокаРаздела = ТаблицаДанных.Добавить();
			СтрокаРаздела.ИмяРаздела           = ИмяРаздела;
			Попытка
				СтрокаРаздела.ПредставлениеРаздела = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела].Заголовок;
				СтрокаРаздела.ИндексСортировки     = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы.Индекс(ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела]);
			Исключение
				СтрокаРаздела.ПредставлениеРаздела = ИмяРаздела;
			КонецПопытки;
		КонецЕсли;
		
		МассивЗначений = Новый Массив;
		Попытка
			Если ТипЗнч(ЭлементФормы) = Тип("Флажок") Тогда
				МассивЗначений.Добавить((ЭлементФормы.Заголовок + ":"));
			Иначе
				МассивЗначений.Добавить(ФормаНастройкиПараметров.ЭлементыФормы["Надпись_" + ЭлементФормы.Имя].Заголовок);
			КонецЕсли; 
		Исключение
			МассивЗначений.Добавить(ЭлементФормы.Имя);
		КонецПопытки;
		МассивЗначений.Добавить("");
		
		СтрокаРаздела.ДанныеРаздела.Вставить(ЭлементФормы.Имя, МассивЗначений);
		
	КонецЦикла;
	
	ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");
	
КонецПроцедуры

// Функция формирует текст сообщения на линию техподдержки
//
// Параметры
//  НЕТ
//
// Возвращаемое значение:
//   Текст сообщения
//
Функция ПолучитьТекстСообщенияВОтделТехническойПоддержки() Экспорт

	ТекстВозврата = "";
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "============ Сведения об использовании ПП 1С:Предприятие 8 ============";
	
	ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
	
	// Сформируем обязательный информационный раздел
	
	СистемИнфо = Новый СистемнаяИнформация;
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8: "   + СистемИнфо.ВерсияПриложения;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия конфигурации: "       + Метаданные.Версия;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;

	НомерСтрокиРаздела = 1;
	
	Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицыРаздела Из ТаблицаДанных Цикл
			
			СтрокаРаздела = "";
			
			Если СтрокаТаблицыРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения" Тогда
				Продолжить;
			КонецЕсли;
			
			Для каждого ЭлементЗначения Из СтрокаТаблицыРаздела.ДанныеРаздела Цикл
				Если НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
					Продолжить;
				КонецЕсли; 
				СтрокаРаздела = СтрокаРаздела + Символы.ПС + ЭлементЗначения.Значение[0] + " " + ?(ТипЗнч(ЭлементЗначения.Значение[1]) = Тип("Булево"), ?(ЭлементЗначения.Значение[1], "Да", "Нет"), ЭлементЗначения.Значение[1]);
			КонецЦикла; 
			
			Если НЕ ЗначениеЗаполнено(СтрокаРаздела) Тогда
				Продолжить;
			КонецЕсли;
			
			НомерСтрокиРаздела = НомерСтрокиРаздела + 1;
			
			СтрокаРаздела = Строка(НомерСтрокиРаздела) + ". " + ВРег(СтрокаТаблицыРаздела.ПредставлениеРаздела) + СтрокаРаздела;
			
			ТекстВозврата = ТекстВозврата + Символы.ПС;
			ТекстВозврата = ТекстВозврата + Символы.ПС + СтрокаРаздела;
		
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТекстВозврата;

КонецФункции // ПолучитьТекстСообщенияВОтделТехническойПоддержки()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт

	Возврат Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная));

КонецФункции // ПолучитьОписаниеТиповСтроки()

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт

	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;

	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));

КонецФункции // ПолучитьОписаниеТиповДаты()

// Проверить, что значение имеет ссылочный тип данных.
//
// Параметры:
//  Значение       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  Булево       - Истина, если тип значения ссылочный.
//
Функция ЗначениеСсылочногоТипа(Значение) Экспорт
	
	Если Значение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Задачи.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

//функция выполняет приведение строки к числу
// Параметры:
//  ЧислоСтрокой           - Строка - Строка приводимая к числу
//  ВозвращатьНеопределено - Булево - Если Истина и строка содержит некорректное значение, то возвращать Неопределено
//
// Возвращаемое значение:
//  Число
//
Функция ПривестиСтрокуКЧислу(ЧислоСтрокой, ВозвращатьНеопределено = Ложь) Экспорт
	
	ОписаниеТипаЧисла = Новый ОписаниеТипов("Число");
	ЗначениеЧисла = ОписаниеТипаЧисла.ПривестиЗначение(ЧислоСтрокой);
	
	Если ВозвращатьНеопределено И (ЗначениеЧисла = 0) Тогда
		
		Стр = Строка(ЧислоСтрокой);
		Если Стр = "" Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Стр = СтрЗаменить(СокрЛП(Стр), "0", "");
		Если (Стр <> "") И (Стр <> ".") И (Стр <> ",") Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЗначениеЧисла;	
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СВОЙСТВАМИ И КАТЕГОРИЯМИ ОБЪЕКТОВ

//Функция возвращает список доступных назначений для "Свойств и категорий объектов" 
//по переданной ссылке
// Параметры:
//	Ссылка - Ссылка на справочник или документ
//
// Возвращаемое значение:
// Список значений: доступные назначения для свойств и категорий
Функция ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке(Ссылка) Экспорт

	Результат = Новый СписокЗначений;
	
	//Если Ссылка = Неопределено Тогда
	//	Возврат Результат;
	//КонецЕсли;

	//ТипСсылки = ТипЗнч(Ссылка);
	//ЭтоХарактеристика = (ТипСсылки = Тип("СправочникСсылка.ХарактеристикиНоменклатуры"));

	//Запрос = Новый Запрос;
	//Запрос.УстановитьПараметр("НазначениеХарактеристика", ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ХарактеристикиНоменклатуры);

	//ТекстЗапроса = "
	//|ВЫБРАТЬ
	//|	Назначения.Ссылка КАК Ссылка,
	//|	Назначения.ТипЗначения КАК ТипЗначения
	//|ИЗ
	//|	ПланВидовХарактеристик.НазначенияСвойствКатегорийОбъектов КАК Назначения
	//|ГДЕ
	//|	НЕ Назначения.ЭтоГруппа
	//|";

	//Если ЭтоХарактеристика Тогда
	//	ТекстЗапроса = ТекстЗапроса + "
	//	|	И Назначения.Ссылка = &НазначениеХарактеристика
	//	|";
	//Иначе
	//	ТекстЗапроса = ТекстЗапроса + "
	//	|	И Назначения.Ссылка <> &НазначениеХарактеристика
	//	|";
	//КонецЕсли;

	//Запрос.Текст = ТекстЗапроса;

	//Выборка = Запрос.Выполнить().Выбрать();
	//Пока Выборка.Следующий() Цикл
	//	Если ЭтоХарактеристика Или Выборка.ТипЗначения.СодержитТип(ТипСсылки) Тогда
	//		Результат.Добавить(Выборка.Ссылка);
	//	КонецЕсли;
	//КонецЦикла;

	Возврат Результат;

КонецФункции // ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 
	
	Если МассивДанные = Неопределено Тогда
		Возврат -1;
	КонецЕсли;
	
	Для ИндексЭлемента = 0 По МассивДанные.ВГраница() Цикл
		
		Если  (МассивДанные[ИндексЭлемента] = Элемент) Тогда
			Возврат ИндексЭлемента;
		КонецЕсли;	
		
	КонецЦикла;
	
	// не нашли элемент
	Возврат -1;
	
КонецФункции

// Удаление из массива пустых элементов
//
// Параметры:
//   МассивЭлементов - Массив
//
Процедура УдалитьНеЗаполненныеЭлементыМассива(МассивЭлементов) Экспорт

	Колво = МассивЭлементов.Количество();
	Для н=1 По Колво Цикл
		Если НЕ ЗначениеЗаполнено(МассивЭлементов[Колво-н]) Тогда
			МассивЭлементов.Удалить(Колво-н);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
//  ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УНИВЕРСАЛЬНЫМИ КОЛЛЕКЦИЯМИ ЗНАЧЕНИЙ

// Создает копию переданного массива, структуры или соответствия
//
// Параметры:
//  КоллекцияИсходная: тип Массив, Структура, Соответствие - исходная коллекция
// Возвращаемое значение:
//  КоллекцияКопия:  тип Массив, Структура, Соответствие - копия исходной коллекции
//
Функция СкопироватьУниверсальнуюКоллекцию(КоллекцияИсходная) Экспорт
	
	Если ТипЗнч(КоллекцияИсходная)=Тип("Массив") Тогда
		
		КоллекцияКопия=Новый Массив;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Добавить(Элемент);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Структура") Тогда
		
		КоллекцияКопия=Новый Структура;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия; 
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Соответствие") Тогда
		
		КоллекцияКопия=Новый Соответствие;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	Иначе
		
		Сообщить("Неверный тип универсальной коллекции для копирования");
		Возврат Неопределено
		
	КонецЕсли;
	
КонецФункции // СкопироватьУниверсальнуюКоллекцию()

// Разворачивает таблицу  значений по вложенной таблице
//
// Параметры
//  ТаблицаЗначений  – <ТаблицаЗначений> – базовая таблица
//  КолонкаВложеннойТаблицы  – <Строка> – Наименование колонки влолженной таблицы
//  СписокРаспределяемыхКолонок  – <Структура> – Структура с именами колонок базовой таблицы, значения которых будут распределяться по колонке вложенной таблицы
//         						Ключ - Имя колонки базовой таблицы
//         						Значение - Имя колонки вложенной таблицы. Если во вложенной таблице колонка не обнаружена - обработка прекращается.
// Возвращаемое значение:
//   <ТаблицаЗначений>   – таблица значений, развернутая по значениям вложенной таблицы.
//
// При совпадении имен базовой и вложенной таблиц - если  
Функция РазвернутьПоВложеннойТаблице(ТаблицаЗначений, КолонкаВложеннойТаблицы,СписокРаспределяемыхКолонок, СписокИсключаемыхКолонок, СообщатьОбОшибке = Истина) Экспорт

	Если ТаблицаЗначений.Количество()=0 Тогда
		// Таблица не заполнена, софрмировать новую таблицу не представляется возможнным
		// Отсуттствует вложенная таблица, структуру данных выходной таблицы сформировать невозможно
		Если СообщатьОбОшибке Тогда
			СообщитьОбОшибке("Отсутствуют строки в базовой таблице, распределение по вложенной таблице невозможно.",,,СтатусСообщения.Внимание);
		КонецЕсли; 
		Возврат Неопределено;
	КонецЕсли; 
	
	КолонкиВложеннойТаблицы = ТаблицаЗначений[0][КолонкаВложеннойТаблицы].Колонки;
	//Заполним значения по тем колонкам, по которым не были заполены значения ранее
	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
		Если НЕ ЗначениеЗаполнено(Колонка.Значение) Тогда
			СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
		КонецЕсли;
		Если КолонкиВложеннойТаблицы.Найти(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено Тогда
			// Во вложенной таблице не обнаружена колонка, по которой производится распределение.
			Если СообщатьОбОшибке Тогда
				СообщитьОбОшибке("Во вложенной таблице не обнаружена колонка ("+?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+"), по которой производится распределение.",,,СтатусСообщения.Внимание);
			КонецЕсли; 
			Возврат Неопределено;
		КонецЕсли; 
	КонецЦикла;
	
	НоваяТаблицаЗначений = Новый ТаблицаЗначений();
	Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
	    Если Колонка.Имя = КолонкаВложеннойТаблицы Тогда
			Продолжить;
	    ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
	КонецЦикла; 
	
	Для каждого Колонка Из КолонкиВложеннойТаблицы Цикл
		Если не НоваяТаблицаЗначений.Колонки.Найти(Колонка.Имя) = неопределено Тогда
			Продолжить;
		ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
	КонецЦикла; 
	
	Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 

		ТаблицаДляРаспределения = СтрокаБазовойТаблицы[КолонкаВложеннойТаблицы];

		Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл

			СтрокаНовойТаблицы = НоваяТаблицаЗначений.Добавить();

			Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл

				Если СписокРаспределяемыхКолонок.Свойство(Колонка.Имя) тогда
					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[СписокРаспределяемыхКолонок[Колонка.Имя]];

				ИначеЕсли не КолонкиВложеннойТаблицы.Найти(Колонка.Имя) = Неопределено тогда
					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[Колонка.Имя];

				ИначеЕсли Не(ТаблицаЗначений.Колонки.Найти(Колонка.Имя)=Неопределено) тогда
					СтрокаНовойТаблицы[Колонка.Имя] = СтрокаБазовойТаблицы[Колонка.Имя];

				Иначе
					// Колонка не найдена - ошибка при выполнении распределения по вложенной таблице
		  			Если СообщатьОбОшибке Тогда
						СообщитьОбОшибке("при распределении по вложенной таблице невозможно определить значение для колонки :"+Колонка.Имя+".",,,СтатусСообщения.Внимание);
					КонецЕсли; 

				КонецЕсли;

			КонецЦикла; // Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл

		КонецЦикла; // Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл

	КонецЦикла; // Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 
	
	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
		СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
	КонецЦикла;
	
	// Распределение базовых данных по распределяемым колонкам
	НоваяТаблицаЗначений = СформироватьКорректирующиеЗаписи(ТаблицаЗначений,НоваяТаблицаЗначений,СписокРаспределяемыхКолонок);
	
	Возврат НоваяТаблицаЗначений;

КонецФункции // РазвернутьПоВложеннойТаблице()

// Сравнивает данные сложной структуры с учетом вложенности.
//
// Параметры:
//  Данные1 - Структура,    ФиксированнаяСтруктура.
//          - Соответствие, ФиксированноеСоответствие.
//          - Массив,       ФиксированныйМассив.
//          - ХранилищеЗначения, ТаблицаЗначений.
//          - Простые типы, которые можно сравнивать на равно,
//            например, Строка, Число, Булево.
//
//  Данные2 - те же типы, что и для параметра Данные1.
//
// Возвращаемое значение:
//  Булево.
//
Функция ДанныеСовпадают(Данные1, Данные2) Экспорт
	
	Если ТипЗнч(Данные1) <> ТипЗнч(Данные2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Данные1) = Тип("Структура")
	 ИЛИ ТипЗнч(Данные1) = Тип("ФиксированнаяСтруктура") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			СтароеЗначение = Неопределено;
			
			Если НЕ Данные2.Свойство(КлючИЗначение.Ключ, СтароеЗначение)
			 ИЛИ НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
			
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Соответствие")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированноеСоответствие") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		КлючиНовогоСоответствия = Новый Соответствие;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			КлючиНовогоСоответствия.Вставить(КлючИЗначение.Ключ, Истина);
			СтароеЗначение = Данные2.Получить(КлючИЗначение.Ключ);
			
			Если НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого КлючИЗначение Из Данные2 Цикл
			Если КлючиНовогоСоответствия[КлючИЗначение.Ключ] = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Массив")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированныйМассив") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Индекс = Данные1.Количество()-1;
		Пока Индекс >= 0 Цикл
			Если НЕ ДанныеСовпадают(Данные1.Получить(Индекс), Данные2.Получить(Индекс)) Тогда
				Возврат Ложь;
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ТаблицаЗначений") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Данные1.Колонки.Количество() <> Данные2.Колонки.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Колонка Из Данные1.Колонки Цикл
			Если Данные2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Индекс = Данные1.Количество()-1;
			Пока Индекс >= 0 Цикл
				Если НЕ ДанныеСовпадают(Данные1[Индекс][Колонка.Имя], Данные2[Индекс][Колонка.Имя]) Тогда
					Возврат Ложь;
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ХранилищеЗначения") Тогда
	
		Если НЕ ДанныеСовпадают(Данные1.Получить(), Данные2.Получить()) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Возврат Истина;
	КонецЕсли;
	
	Возврат Данные1 = Данные2;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ВЫВОДА СООБЩЕНИЙ


Функция ОпределитьВажностьСобытияЖурналаРегистрации(Статус)
	ВидСобытия = УровеньЖурналаРегистрации.Информация;
	Если Статус = СтатусСообщения.Внимание Тогда
		ВидСобытия = УровеньЖурналаРегистрации.Предупреждение;
	ИначеЕсли Статус = СтатусСообщения.Важное или  Статус = СтатусСообщения.ОченьВажное Тогда
		ВидСобытия = УровеньЖурналаРегистрации.Ошибка;
	КонецЕсли;
    Возврат  ВидСобытия;
КонецФункции

//Процедура проверяет необходимость вывода сообщения в журнал регистрации, при необходимости выводит сообщение в журнал регистрации
// Параметры:
//	ТекстСообщения - Строка - Текст сообщения
//	Статус - ПеречислениеСсылка.ВидыСообщений - Вид сообщения
//		   - СтатусСообщения - Статус сообщения (используется для совместимости со старыми вызовами процедуры Сообщить)
//	Заголовок - Строка - Текст заголовка
//
Процедура ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок="")
	//Если сообщение выводится во внешнем соединении, оно всегда должно быть выведено в журнал регистрации (независимо от настроек)
	//Это необходимо для того, чтобы в ЖР были видны сообщения при автоматическом обновлении
	#Если НЕ ВнешнееСоединение Тогда
	ДублироватьСообщенияВЖурналРегистрации = глЗначениеПеременной("ДублироватьСообщенияВЖурналРегистрации");
	Если НЕ ДублироватьСообщенияВЖурналРегистрации Тогда
		Возврат;
	КонецЕсли;
	#КонецЕсли
	Важность = ОпределитьВажностьСобытияЖурналаРегистрации(Статус);
	Если Заголовок <> "" Тогда
		//вывод заголовка как отдельной записи в журнал
		ЗаписьЖурналаРегистрации("Сообщение", УровеньЖурналаРегистрации.Примечание, , ,Заголовок);
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации("Сообщение", Важность, , ,ТекстСообщения);

КонецПроцедуры

Функция ПолучитьУровеньСобытияПоПредставлению(ПредставлениеУровня)
	Если ПредставлениеУровня = "Информация" Тогда
		Возврат УровеньЖурналаРегистрации.Информация;
	ИначеЕсли ПредставлениеУровня = "Ошибка" Тогда
		Возврат УровеньЖурналаРегистрации.Ошибка;
	ИначеЕсли ПредставлениеУровня = "Предупреждение" Тогда
		Возврат УровеньЖурналаРегистрации.Предупреждение; 
	ИначеЕсли ПредставлениеУровня = "Примечание" Тогда
		Возврат УровеньЖурналаРегистрации.Примечание;
	КонецЕсли;	
КонецФункции

// Процедура пакетной записи сообщений в журнал регистрации
// 
// Параметры: СобытияДляЖурналаРегистрации - массив структур, клиентская глобальная переменная 
// Каждая структура - сообщение для журнала регистрации.
// После записи переменная очищается.
Процедура ЗаписатьСобытияВЖурналРегистрации(СобытияДляЖурналаРегистрации) Экспорт
	
	Если ТипЗнч(СобытияДляЖурналаРегистрации) <> Тип("СписокЗначений") Тогда
		Возврат;
	КонецЕсли;	
	
	Если СобытияДляЖурналаРегистрации.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого СообщениеЖурнала Из СобытияДляЖурналаРегистрации Цикл
		ЗначениеСообщения = СообщениеЖурнала.Значение;
		
		ИмяСобытия = ЗначениеСообщения.ИмяСобытия;
		УровеньСобытия = ПолучитьУровеньСобытияПоПредставлению(ЗначениеСообщения.ПредставлениеУровня);
		Попытка
			ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ЗначениеСообщения.ОбъектМетаданных);
		Исключение
			ОбъектМетаданных = Неопределено;
		КонецПопытки;
		ИмяДанных = ?(Найти(ЗначениеСообщения.ОбъектМетаданных, "Справочник") > 0, СтрЗаменить(ЗначениеСообщения.ОбъектМетаданных, "Справочник", "Справочники"), СтрЗаменить(ЗначениеСообщения.ОбъектМетаданных, "Документ", "Документы"));
		Попытка
			Данные = Вычислить(ИмяДанных+".ПолучитьСсылку("+ЗначениеСообщения.Данные+")");
		Исключение
			Данные = Неопределено;	
		КонецПопытки ;
		Комментарий = ЗначениеСообщения.Комментарий;
		
		РежимТранзакции = РежимТранзакцииЗаписиЖурналаРегистрации.Независимая;
		
		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньСобытия, ОбъектМетаданных, 
			Данные, Комментарий, РежимТранзакции);			
		
	КонецЦикла;
	
	СобытияДляЖурналаРегистрации.Очистить();
	
КонецПроцедуры

// Процедура выводит пользователю сообщение: в журнал регистрации, в панель комментариев, в окно сообщений (в зависимости от настроек).
//
// Параметры:
//	ТекстСообщения - Строка - Текст сообщения
//	Статус - ПеречислениеСсылка.ВидыСообщений - Вид сообщения
//		   - СтатусСообщения - Статус сообщения (используется для совместимости со старыми вызовами процедуры Сообщить)
//	Заголовок - Строка - Текст заголовка
//	РасшифровкаСообщения - Массив - Массив с данными расшифровки
//						 - Ссылка - Ссылка на объект
//	СтрокаРодитель - Родительская строка дерева значений для вывода сообщения
//	РаскрытьСообщение - Булево - Признак раскрытия строки дерева сообщений
//
// Возвращаемое значение:
//	СтрокаДереваЗначенний - Строка дерева значений, в которую записано текущее сообщение
//Если вывод сообщений в панель комментариев не предусмотрен, возвращается Неопределено
Функция Сообщение(Знач ТекстСообщения, Статус = Неопределено, Заголовок = "", РасшифровкаСообщения = Неопределено, СтрокаРодитель = Неопределено, РаскрытьСообщение = Истина, ЭтоСообщениеОбОшибке = Ложь) Экспорт
	
	ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок);
	СтрокаДереваЗначений = ВыводСообщений.ВывестиСообщениеВПанельКомментариев(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, СтрокаРодитель, РаскрытьСообщение);
	Если СтрокаДереваЗначений = Неопределено Тогда //Сообщение в панель комментариев не выведено, значит необходимо вывести его в окно сообщений
		ВыводСообщений.ВывестиСообщениеВОкноСообщений(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, ЭтоСообщениеОбОшибке);
	КонецЕсли;
	
	Возврат СтрокаДереваЗначений;
	
КонецФункции // Сообщение()

////////////////////////////////////////////////////////////////////////////////
// ВЫВОД ТРАССИРОВОЧНЫХ СООБЩЕНИЙ
Процедура СообщитьОСостоянииОбновления(Подсистема, Действие, Комментарий="", Уровень=0, флЗавершающее=ложь) Экспорт
	СтрокаТабуляций = "";
	Для ш = 1 По Уровень Цикл
		СтрокаТабуляций = СтрокаТабуляций + Символы.Таб;
	КонецЦикла;	
	Если флЗавершающее Тогда
		ВидСообщенияе = СтатусСообщения.Информация;
	Иначе
		ВидСообщения = СтатусСообщения.Внимание;
	КонецЕсли;
	
	ОбщегоНазначения.Сообщение(СтрокаТабуляций + Подсистема + ": " + Действие + ?(Комментарий = "",""," (" + Комментарий + ")"),ВидСообщения);
КонецПроцедуры	


Процедура СообщитьОСостоянииИзмененияНастройки(ИмяНастройки,Действие, Комментарий="", Уровень=0,текСтатусСообщения=неопределено) Экспорт
	Если текСтатусСообщения = неопределено Тогда
		СтатусСообщенияДляВывода = СтатусСообщения.Информация;
	Иначе
		СтатусСообщенияДляВывода = текСтатусСообщения;
	КонецЕсли;
		
	СтрокаТабуляций = "";
	Для ш = 1 По Уровень Цикл
		СтрокаТабуляций = СтрокаТабуляций + Символы.Таб;
	КонецЦикла;	
	ОбщегоНазначения.Сообщение(СтрокаТабуляций + "Настройка учета: "+ИмяНастройки+". "+Действие + ?(Комментарий = "",""," (" + Комментарий + ")"),СтатусСообщенияДляВывода);
КонецПроцедуры	

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте вывобит сообщение в обработку комментирования
// на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения  - строка, текст сообщения.
//					  Строка может содержать символы %%, которые при формировании 
//					  сообщения заменяются на представления элементов расшифровки
//  Отказ           - булево, признак отказа (необязательный).
//  Заголовок	    - Заголовок сообщения, для вывода сообщения если работа на сервере или внешнее соединение
//	Расшифровки 	- массив расшифровок для переданного ТекстСообщения
//					  Представляет собой массив структур с полями Представление и Расшифровка
//					  Поле Представление - текст, дополняющий ТекстСообщения
//					  Поле Расшифровка - действие, выполняемое по расшифровке
//
Процедура ВывестиИнформациюОбОшибке(Знач ТекстСообщения, Отказ = Истина, Заголовок = "", ВидСообщения = Неопределено, Расшифровки = Неопределено, РодительскаяСтрока = НеОпределено, РаскрытьСообщение = Истина) Экспорт
	
	Отказ = Истина;
	
	#Если Клиент Тогда
	
		Если ВидСообщения = Неопределено Тогда
			ВидСообщения = Перечисления.ВидыСообщений.Ошибка;
		КонецЕсли;
		Обработка = глЗначениеПеременной("глОбработкаСообщений");
		Обработка.ДобавитьСообщение(ТекстСообщения, ВидСообщения, Расшифровки, РодительскаяСтрока, РаскрытьСообщение);
		
	#ИначеЕсли ВнешнееСоединение Тогда
		
		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
		Сообщить(ТекстСообщения, СтатусСообщения.Важное);
		
	#КонецЕсли
	
КонецПроцедуры // ВывестиИнформациюОбОшибке()

// Функция убирает из текста сообщения служебную информацию.
//
// Параметры:
//  ТекстСообщения, Строка, исходный текст сообщения
//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции

Процедура СообщитьИнформациюПользователю(СтрокаСообщенияПользователю) Экспорт
	
	#Если Клиент Тогда
	Сообщить(СтрокаСообщенияПользователю);
	#КонецЕсли
	
КонецПроцедуры

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//	Заголовок - Строка - Текст заголовка
//          (выводится пользователю в режиме обычного приложения; 
//           в заголовке должен быть описан контекст выполняемых действий, например "Проведение документа №... от ...")
//	Статус - СтатусСообщения - Статус сообщения
//	РасшифровкаСообщения - Массив - Массив с данными расшифровки
//						 - Ссылка - Ссылка на объект
//
Процедура СообщитьОбОшибке(
	Знач ТекстСообщения, 
	Отказ = Ложь, 
	Заголовок = "",
	Статус = Неопределено,
	РасшифровкаСообщения = Неопределено
	) Экспорт

	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);

	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		//Для клиента и сервера запись в журнал регистрации попадет внутри процедуры Сообщение
		ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок);
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#Иначе
		
		Сообщение(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, Неопределено, Истина, Истина);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

Процедура ПоказатьДиалогСИнформациейОбОшибке(ИнформацияОбОшибке) Экспорт
	
	#Если Клиент Тогда
		ПоказатьИнформациюОбОшибке(ИнформацияОбОшибке);
	#Иначе
		СообщитьОбОшибке(ПолучитьПричинуОшибки(ИнформацияОбОшибке).Описание);
	#КонецЕсли
	
КонецПроцедуры

// Выводит сообщение "пользовательского" вида о невозможности заблокировать объект
//
Процедура СообщитьОбъектЗаблокирован(ПредставлениеОбъекта, ПредставлениеТипа, Отказ = Ложь) Экспорт
	
	ТекстСообщения = "Не удалось записать " + ПредставлениеТипа + " " + ПредставлениеОбъекта + "!" + Символы.ПС + "Возможно, его данные редактируются другим пользователем.";
	ТекстЗаголовка = "Ошибка блокировки объекта";
	
	Отказ = Истина;
	
	#Если Клиент Тогда
		РаботаСДиалогами.ВывестиПредупреждение(ТекстСообщения, ТекстЗаголовка);
	#Иначе
		СообщитьОбОшибке(ТекстСообщения, , ТекстЗаголовка);
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбъектЗаблокирован

// Формирует строку представления документа для сообщений при проведении.
//
// Параметры
//  Источник - структура шапки или ссылка на проводимый документ.
//
// Возвращаемое значение
//  Строка с представлением документа
//
Функция ПредставлениеДокументаПриПроведении(Источник) Экспорт
	
	Если ТипЗнч(Источник) = Тип("Структура") Тогда
		ПредставлениеДокумента = Источник.ПредставлениеДокумента;
		Если Источник.Свойство("ВидОперации") Тогда
			ПредставлениеДокумента = ПредставлениеДокумента + " (" + Источник.ВидОперации + ")";
		КонецЕсли; 
	Иначе
		МетаданныеДокумента = Источник.Метаданные();
		ВидОперацииСтр = "";
		Если МетаданныеДокумента.Реквизиты.Найти("ВидОперации") <> Неопределено Тогда
			ВидОперацииСтр = " (" + Источник.ВидОперации + ")";
		КонецЕсли;
		ПредставлениеДокумента = СокрЛП(Источник) + ВидОперацииСтр;
	КонецЕсли; 
	
	ПредставлениеДокумента = "Проведение документа: " + ПредставлениеДокумента;
	
	Возврат ПредставлениеДокумента;
	
КонецФункции // ПредставлениеДокументаПриПроведении


// Предназначена для получения запросом представлений объектов
// Поддерживает два синтаксиса
// 1.
// Параметры:
//	СсылкиОбъектовПарам - массив ссылок
// Возвращаемое значение
//	Соответствие в котором ключ - одна из переданных ссылок, 
//  а значение - представление этой ссылки
// 2. 
// Параметры:
//	СсылкиОбъектовПарам - ссылка
// Возвращаемое значение
//	Строка предсатвления ссылки
//
// Пример использования:
// 	МассивСсылок = Новый Массив;
// 	МассивСсылок.Добавить(НоваяОрганизация);
// 	МассивСсылок.Добавить(СтараяОрганизация);
// 	Представления = ПолучитьПредставленияОбъектов(МассивСсылок);
//	НоваяОрганизацияСтрокой = Представления[НоваяОрганизация];
//	СтараяОрганизацияСтрокой = Представления[СтараяОрганизация];
//
Функция ПолучитьПредставленияОбъектов(СсылкиОбъектовПарам) Экспорт
	// соответствие возвращается если передан массив ссылок
	ПереданМассив = Истина;
	
	// Если передано одиночное значение - "превратим" его в массив
	Если ТипЗнч(СсылкиОбъектовПарам) <> Тип("Массив") Тогда
		Ссылка = СсылкиОбъектовПарам;
		СсылкиОбъектов = Новый Массив;
		СсылкиОбъектов.Добавить(Ссылка);
		ПереданМассив = Ложь;
		
	Иначе
		СсылкиОбъектов = СсылкиОбъектовПарам;
		
	КонецЕсли;
	
	// Обработаем массив СсылкиОбъектов и сформируем 
	// соответствие ссылок по их типам
	СсылкиПоТипам = Новый Соответствие;
	Для Каждого СсылкаНаОбъект Из СсылкиОбъектов Цикл
		ПолноеИмя = СсылкаНаОбъект.Метаданные().ПолноеИмя();
		Если СсылкиПоТипам[ПолноеИмя] = НеОпределено Тогда
			СсылкиПоТипам[ПолноеИмя] = Новый Массив;
		КонецЕсли;
		СсылкиПоТипам[ПолноеИмя].Добавить(СсылкаНаОбъект);
	КонецЦикла;
	
	// формирование запроса
	ТекстЗапроса = "";
	Запрос = Новый Запрос;
	ПервоеЗначение = Истина;
	Для Каждого ЭлементСоответствия Из СсылкиПоТипам Цикл
		ИмяПараметра = "Массив" + СтрЗаменить(ЭлементСоответствия.Ключ, ".", "_");
		Если Не ПервоеЗначение Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|ОБЪЕДИНИТЬ ВСЕ";
			
		КонецЕсли;
		ТекстЗапроса = ТекстЗапроса + "
		|ВЫБРАТЬ 
		|	Ссылка КАК Ссылка,
		|	ПРЕДСТАВЛЕНИЕ(Ссылка) КАК Представление
		|ИЗ " + ЭлементСоответствия.Ключ + "
		|ГДЕ Ссылка В (&" + ИмяПараметра + ")";
		Запрос.УстановитьПараметр(ИмяПараметра, ЭлементСоответствия.Значение);
		ПервоеЗначение = Ложь;
	КонецЦикла;
	// обработка запроса
	Запрос.Текст = ТекстЗапроса;
	Выборка = Запрос.Выполнить().Выбрать();
	Если ПереданМассив Тогда
		ВозвращаемоеСоответствие = Новый Соответствие;
		Пока Выборка.Следующий() Цикл
			ВозвращаемоеСоответствие[Выборка.Ссылка] = Выборка.Представление;
		КонецЦикла;
		
		// дополним пустыми представлениями неполученных запросом ссылок
		Для Каждого СсылкаНаОбъект Из СсылкиОбъектов Цикл
			Если ВозвращаемоеСоответствие[СсылкаНаОбъект] = НеОпределено Тогда
				ВозвращаемоеСоответствие[СсылкаНаОбъект] = "";
			КонецЕсли;
			
		КонецЦикла;
		Возврат ВозвращаемоеСоответствие;
		
	Иначе
		Если Выборка.Следующий() Тогда
			Возврат Выборка.Представление;
		Иначе
			// если ссылки не нашлось - пустое представление
			Возврат "";
		КонецЕсли;
		
	КонецЕсли; 
	
КонецФункции

// Проверяет принадлежность документа к видам учета
//
// Параметры: 
//  СтруктураШапкиДокумента - структура, содержащая реквизиты шапки документа
//  Отказ                   - флаг отказа в проведении.
//  Заголовок               - строка, заголовок сообщения об ошибке проведения.
//  МожетБытьТолькоНалоговый- строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь) Экспорт
	
	Перем Упр, Бух, Нал;
	
	ЕстьУпр = СтруктураШапкиДокумента.Свойство("ОтражатьВУправленческомУчете", Упр);
	ЕстьБух = СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете", Бух);
	ЕстьНал = СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете", Нал);
	
	Если ЕстьУпр ИЛИ ЕстьБух ИЛИ ЕстьНал Тогда
		Если НЕ МожетБытьТолькоНалоговый Тогда
			Если Упр <> Истина И Бух <> Истина  Тогда
				СообщитьОбОшибке("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"" и (или)  ""Бухгалтерский"".", Отказ, Заголовок);
			ИначеЕсли Бух <> Истина И Нал = Истина Тогда
				СообщитьОбОшибке("Документ не может проводиться  по налоговому учету, если он не проводится по бухгалтерскому учету." , Отказ, Заголовок);
			КонецЕсли;
		Иначе
			Если Упр <> Истина И Бух <> Истина И Нал <> Истина Тогда
				СообщитьОбОшибке("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"", ""Бухгалтерский"", ""Налоговый"".", Отказ, Заголовок);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт

	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;

КонецФункции // ПолучитьСписокЭлементовПеречисления()

// Процедура проверяет переданный параметр, если он не соответствует значению, 
// то присваивает ему указанное значение.
//
// Параметры:
//  Параметр - параметр, значение которого проверяется и заполняется.
//  Значение - значение для заполнения пустого параметра.
//
Процедура УстановитьНовоеЗначение(Параметр, Значение) Экспорт

	Если Параметр <> Значение Тогда
		Параметр = Значение;
	КонецЕсли;

КонецПроцедуры

// Предназначена для получения имени элемента перечисления по значению.
//
// Параметры:
//	Элемент перечисления.
//
// Возвращаемое значение:
//	Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьИмяЭлементаПеречисленияПоЗначению(ЗначениеПеречисления) Экспорт
	
	ИмяЭлемента = Строка(ЗначениеПеречисления);
	Для каждого ЭлементПеречисления Из Метаданные.Перечисления[ЗначениеПеречисления.Метаданные().Имя].ЗначенияПеречисления Цикл
		Если ЭлементПеречисления.Синоним = Строка(ЗначениеПеречисления) Тогда
			ИмяЭлемента = ЭлементПеречисления.Имя;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат ИмяЭлемента;
	
КонецФункции // ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()

Функция ПолучитьИмяЗначенияПеречисленияПоСсылке(Ссылка1) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Ссылка1) Тогда
		Возврат "";
	КонецЕсли;
	
	ИмяПеречисления = Ссылка1.Метаданные().Имя;
	Индекс = Перечисления[ИмяПеречисления].Индекс(Ссылка1);
	Возврат Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления[Индекс].Имя;
	
КонецФункции // ()

// сравнение значений перечислений на больше/меньше
// применяется для перечислений, для которых последовательность 
// значений имеет определяющее значение
//
// Параметры:
//  Значение1, Значение2 - сравниваемые значения перечислений
//
// Возвращаемое значение: число
//   1 - если Значение1 > Значение2
//  -1 - если Значение1 < Значение2
//   0 - если Значение1 = Значение2
//
Функция СравнениеПеречислений(Значение1, Значение2) Экспорт
    ИмяПеречисления = Метаданные.НайтиПоТипу(ТипЗнч(Значение1)).Имя;
    Менеджер = Перечисления[ИмяПеречисления];
    Если Менеджер.Индекс(Значение1) > Менеджер.Индекс(Значение2) Тогда
        Возврат 1;
    ИначеЕсли Менеджер.Индекс(Значение1) < Менеджер.Индекс(Значение2) Тогда
        Возврат -1;
    Иначе
        Возврат 0;
    КонецЕсли;
    
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

// Функция возвращает имя табличной части, к которой принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Строка - имя табличной части, как оно задано в конфигураторе
//
Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	ИмяТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;
	Возврат ИмяТабличнойЧасти;

КонецФункции // ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Функция возвращает массив, который содержит имена регистров 
// движения которых не надо удалять при очистке движений перед перепроведением
//	Остатки, движения по таким регистрам не используются 
// 		ни в процедурах контроля остатков (товаров, задолженностей)
// 		ни в логике формирования других движений (например, партии, авансы)
//
Функция ПолучитьРегистрыДляОптимизацииПерезаписиДвижений(ТекущийРежимПроведенияДокумента)
	
	МассивРегистров = Новый Массив;
	
	//В список регистров могут быть включены только те, движения которых записываются через коллекцию движений (Движения.<...>), 
	//а не через набор записей 
	
	// Регистры вида "Обороты", которые 
	//- не используются для формирования движений 
	//- двигаются документами, для которых применяется выборочное удаление движений
	МассивРегистров.Добавить("ДвиженияДенежныхСредств");
	МассивРегистров.Добавить("Закупки");
	МассивРегистров.Добавить("Продажи");

	// Далее перечислены регистры, которые используются для контроля остатков, формирования движений 
	// только при оперативном проведении. Их 
	// - следует очищать если документ проводится оперативно
	// - можно не очищать, если документ проводится неоперативно
	Если ТекущийРежимПроведенияДокумента = РежимПроведенияДокумента.Неоперативный Тогда
		МассивРегистров.Добавить("ВзаиморасчетыСКонтрагентами");
		МассивРегистров.Добавить("ДенежныеСредства");
		МассивРегистров.Добавить("ЗаказыПоставщикам");
		МассивРегистров.Добавить("РазмещениеЗаказовПокупателей");
		МассивРегистров.Добавить("РасчетыСКонтрагентами");
		МассивРегистров.Добавить("ТоварыВНТТ");
		МассивРегистров.Добавить("ТоварыВРезервеНаСкладах");
		МассивРегистров.Добавить("ТоварыВРознице");
		МассивРегистров.Добавить("ТоварыКПередачеОрганизаций");
		МассивРегистров.Добавить("ТоварыКПередачеСоСкладов");
		МассивРегистров.Добавить("ТоварыКПеремещениюВНТТ");
		МассивРегистров.Добавить("ТоварыКПолучениюНаСклады");
		МассивРегистров.Добавить("ТоварыНаСкладах");
		МассивРегистров.Добавить("ТоварыОрганизаций");
		МассивРегистров.Добавить("ТоварыПереданные");
		МассивРегистров.Добавить("ТоварыПолученные");
	КонецЕсли;
	
	Возврат МассивРегистров;
	
КонецФункции // ПолучитьРегистрыДляОптимизацииПерезаписиДвижений

// Процедура удаления движений документа при перепроведении (отмене проведения)
//
// Параметры:
//	ДокументОбъект 				- документ, движения которого удаляются
//	Отказ 						- булево, признак отказа
//	ВыборочноОчищатьРегистры 	- булево, признак выборочной очистки наборов записей 
//								Если Истина - часть наборов записей не будут очищены, будут очищены только коллекции движений
//	РежимПроведенияДокумента 	- режим проведения (оперативный / неоперативный), 
//								нужен для составления списка регистров, которые не надо очищать
//	Для документа ПринятиеКУчетуОС предусмотрена отдельная процедура УдалитьДвиженияПринятиеКУчетуОС
Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ, ВыборочноОчищатьРегистры = Ложь, РежимПроведенияДокумента = Неопределено, РазрешитьЗаписьБезПроверки = Ложь) Экспорт
	
	// Удалим те движения, которые уже записаны
	УдалитьЗаписанныеДвиженияДокумента(ДокументОбъект, Отказ, ВыборочноОчищатьРегистры, РежимПроведенияДокумента, РазрешитьЗаписьБезПроверки);
	
	// Очистим непустые коллекции движений документа
	ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект);
	
	// Удаление записей регистрации из всех последовательностей - после удаления движений по регистрам
	УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, Истина);
	
КонецПроцедуры

// Процедура очистки записанных движений документа
//
// Параметры:
//	ДокументОбъект 				- документ, движения которого удаляются
//	Отказ 						- булево, признак отказа
//	ВыборочноОчищатьРегистры 	- булево, признак выборочной очистки наборов записей 
//								Если Истина - часть наборов записей не будут очищены, будут очищены только коллекции движений
//	РежимПроведенияДокумента 	- режим проведения (оперативный / неоперативный), 
//								нужен для составления списка регистров, которые не надо очищать
Процедура УдалитьЗаписанныеДвиженияДокумента(ДокументОбъект, Отказ, ВыборочноОчищатьРегистры, РежимПроведенияДокумента, РазрешитьЗаписьБезПроверки)
	
	// Получим перечень регистров, движения по которым нужно очистить
	МассивРегистров = ПроведениеДокументов.МассивРегистровНужноОчистить(ДокументОбъект);
	Если МассивРегистров.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Если очищать регистры надо выборочно, то подготовим список таких регистров, 
	//	которые можно не очищать при перепроведении
	Если ВыборочноОчищатьРегистры Тогда
		РегистрыДляОптимизацииПерезаписиДвижений = ПолучитьРегистрыДляОптимизацииПерезаписиДвижений(РежимПроведенияДокумента);
	КонецЕсли;
	
	// Переменные логики отложенного проведения
	ДокументИспользуетсяВОтложенномПроведении = Ложь;
	ВыполняетсяДопроведение                   = Ложь;
	ПроведениеПоВсемВидамУчета                = Ложь;
	
	СтруктураПараметровПроведения = ОтложенноеПроведениеДокументов.ПолучитьПараметрыПроведенияДокумента(ДокументОбъект);
	ДокументИспользуетсяВОтложенномПроведении = СтруктураПараметровПроведения.ДокументИспользуетсяВОтложенномПроведении;
	
	Если ДокументИспользуетсяВОтложенномПроведении Тогда
		ВыполняетсяДопроведение 		= СтруктураПараметровПроведения.ВыполняетсяДопроведение;
		ПроведениеПоВсемВидамУчета 		= СтруктураПараметровПроведения.ПроведениеПоВсемВидамУчета;
		РегистрыОтложенногоПроведения = ОтложенноеПроведениеДокументов.ПолучитьРегистрыОтложенногоПроведения();
	КонецЕсли;
	
	//Обойдем список регистров, по которым существуют движения, и выполним очистку необходимых регистров
	Для Каждого ПолноеИмяРегистра ИЗ МассивРегистров Цикл
		
		// Имя регистра передается как значение, 
		// полученное с помощью функции ПолноеИмя() метаданных регистра
		ПозицияТочки = Найти(ПолноеИмяРегистра, ".");
		ТипРегистра = Лев(ПолноеИмяРегистра, ПозицияТочки - 1);
		ИмяРегистра = СокрП(Сред(ПолноеИмяРегистра, ПозицияТочки + 1));
		
		// Используется для оптимизации перезаписи движений платформой
		//	Если значение Ложь, набор записей не будет очищен
		// По умолчанию все движения надо удалять
		УдалятьДвижения = Истина;
		
		Если ВыборочноОчищатьРегистры И РегистрыДляОптимизацииПерезаписиДвижений.Найти(ИмяРегистра) <> Неопределено Тогда
			УдалятьДвижения = Ложь;
		КонецЕсли;
		
		Если ДокументИспользуетсяВОтложенномПроведении Тогда
			Если ВыполняетсяДопроведение Тогда
				//	Если выполняется допроведение, то удаляются только движения по регистрам, 
				//	которые формируются при отложенном проведении
				Если РегистрыОтложенногоПроведения.Найти(СокрЛП(ПолноеИмяРегистра)) = Неопределено Тогда
					Продолжить;
				КонецЕсли;
			Иначе
				// Документ проводится в режиме отложенного проведения
				
				// Если для документа выключен режим проведения "по всем видам учета", 
				// то всегда удаляются движения по регистрам, которые формируются при допроведении
				//	(независимо от того, входят ли они в список РегистрыДляОптимизацииПерезаписиДвижений)
				Если НЕ УдалятьДвижения
					И НЕ ПроведениеПоВсемВидамУчета 
					И РегистрыОтложенногоПроведения.Найти(СокрЛП(ПолноеИмяРегистра)) <> Неопределено Тогда
					
					УдалятьДвижения = Истина;
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли; 
		
		Если УдалятьДвижения Тогда
			// Удаление движений происходит без контроля доступа - передаем пустую таблицу движений
			ПолныеПрава.ЗаписатьНаборЗаписейНаСервере(ИмяРегистра, ДокументОбъект.Ссылка,, ТипРегистра, РазрешитьЗаписьБезПроверки);
		Иначе
			//Установим признак модифицированности набора записей, чтобы записались все коллекции движений, по которым
			//были записи на момент проведения
			ДокументОбъект.Движения[ИмяРегистра].Очистить();
		КонецЕсли;
		
	КонецЦикла;	
	
КонецПроцедуры


// Процедура очищает коллекцию движений документа
//
Процедура ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект)
		
	Если ДокументОбъект.Движения.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
		// Очистим не пустые коллекции движений
		Если Движение.Количество() > 0 Тогда
			Движение.Очистить();
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	// Заполним значения в совпадающих колонках.
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл

		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);

	КонецЦикла;

КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Проверяет наличие требуемых данных в источнике и Формирует таблицу значений
//
// Параметры
//  Источник  – ТаблицаЗначений или ТабличнаяЧасть или КоллекцияСтрокДереваЗначений с исходными данными
//
//  Реквизиты – структура – Структура реквизитов. 
//							Ключ 		- Наименование колонки в источнике
//							Значение    - Наименование колонки в получаемой ТЗ
//							Если значение опущено - приравнивается ключу.
//	ПолучитьНомерСтрокиДокумента - булево
//	                        Используется только при выгрузке из табличной части документа.
//							В формируемой таблице создает новую колонку "НомерСтрокиДокумента"
//								и заполняет её реальными номерами строк
//
//  КоллекцияКолонокДереваЗначений - только для коллекции строк дерева значений.
// Возвращаемое значение:
//  Таблица значений или Неопределено (если не хватает реквизитов)
//
Функция СформироватьТаблицуЗначений(Источник,Реквизиты=Неопределено,ПолучитьНомерСтрокиДокумента = ложь,ФормироватьОтстутствующиеКолонки=Ложь,КоллекцияКолонокДереваЗначений=Неопределено) экспорт

	ЭтоТаблицаЗначений=(ТипЗнч(Источник)= тип("ТаблицаЗначений"));
	ЭтоСтрокиДереваЗначений=(ТипЗнч(Источник)= тип("КоллекцияСтрокДереваЗначений"));
	Если ЭтоСтрокиДереваЗначений и КоллекцияКолонокДереваЗначений = Неопределено тогда
		Возврат Неопределено;
	Конецесли;
	
	Если НЕ ЗначениеЗаполнено(Реквизиты) тогда
		Если ЭтоТаблицаЗначений тогда
			НоваяТЗ = Источник.Скопировать();
	  		Возврат НоваяТЗ;
		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			Реквизиты = Новый Структура();
			Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
				Реквизиты.Вставить(Колонка.Имя);
			КонецЦикла;
		Иначе
			НоваяТЗ = Источник.Выгрузить();
	  		Возврат НоваяТЗ;
		КонецЕслИ;
	Конецесли;
	
	Если не ЭтоТаблицаЗначений  и не ЭтоСтрокиДереваЗначений тогда
		РеквизитыТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(Источник)).Реквизиты;
	Конецесли;
	
	НоваяТЗ= Новый ТаблицаЗначений();
	
	Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
 		НоваяТЗ.Колонки.Добавить("НомерСтрокиДокумента",Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5,0)));
	КонецЕсли;

	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл
		Строка = НоваяТЗ.Добавить();
		Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
			Строка.НомерСтрокиДокумента = НоваяТЗ.Количество();
		КонецЕсли;
	КонецЦикла;
	
	Для каждого ТекРеквизит из Реквизиты Цикл
		ИскомыйРеквизит = ТекРеквизит.Ключ;
		НовыйРеквизит 	= ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);
		Если ЭтоТаблицаЗначений тогда
			ИсточникКолонка = Источник.Колонки.Найти(ИскомыйРеквизит);
		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);
		Иначе
			ИсточникКолонка = РеквизитыТабличнойЧасти.Найти(ИскомыйРеквизит);
		Конецесли;
		Если ИсточникКолонка= неопределено тогда
			//недостаточно реквизитов
			Если ФормироватьОтстутствующиеКолонки тогда
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			Иначе
				Возврат Неопределено;
			КонецЕсли;	
		Иначе
			Если ЭтоТаблицаЗначений ИЛИ ЭтоСтрокиДереваЗначений тогда
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит, ИсточникКолонка.ТипЗначения);
			Иначе
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит, ИсточникКолонка.Тип);
			КонецЕсли;
			НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);
		Конецесли;
	КонецЦикла;
	
    Возврат НоваяТЗ;
КонецФункции // СформироватьТаблицуОплаты()

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки. 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
	
	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата",   ДокументОбъект.Дата);
	
	ТипДокумента = ТипЗнч(ДокументОбъект);
	
	МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипДокумента);
	СтруктураШапкиДокумента.Вставить("ВидДокумента",  				МетаданныеДокумента.Имя);
	СтруктураШапкиДокумента.Вставить("ПредставлениеДокумента", 		СокрЛП(ДокументОбъект));
	СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());
	
	Для Каждого Реквизит Из МетаданныеДокумента.Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
	КонецЦикла;
	
	// Вставим свойства в структуру и далее при необходимости установим некоторые значения в Истину.
	СтруктураШапкиДокумента.Вставить("ОрганизацияПрименяетУСН", 		 Ложь);
	СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСНДоходы", Ложь);
	СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСН", 		 Ложь);
	СтруктураШапкиДокумента.Вставить("ПоддержкаПБУ18", 					 Ложь);

	Если СтруктураШапкиДокумента.Свойство("Организация")
	 И ЗначениеЗаполнено(СтруктураШапкиДокумента.Организация)
	 И СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете") 
	 И СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете Тогда
			
		УчетнаяПолитика = ПолучитьПараметрыУчетнойПолитикиРегл(СтруктураШапкиДокумента.Дата, СтруктураШапкиДокумента.Организация);
		
		Если ЗначениеЗаполнено(УчетнаяПолитика) Тогда
			
			СтруктураШапкиДокумента.ОрганизацияПрименяетУСН = УчетнаяПолитика.УСН;	
		
			Если СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете") 
			 И СтруктураШапкиДокумента.ОтражатьВНалоговомУчете Тогда
				
				Если УчетнаяПолитика.УСН Тогда
					СтруктураШапкиДокумента.ОтражатьВНалоговомУчете = Ложь;
					Если УчетнаяПолитика.ОбъектНалогообложенияУСН = Перечисления.ОбъектыНалогообложенияПоУСН.Доходы Тогда 
						СтруктураШапкиДокумента.ОтражатьВНалоговомУчетеУСНДоходы = Истина;
					Иначе 
						СтруктураШапкиДокумента.ОтражатьВНалоговомУчетеУСН = Истина;
					КонецЕсли;
				Иначе  
					СтруктураШапкиДокумента.ПоддержкаПБУ18 = УчетнаяПолитика.ПоддержкаПБУ18; 			
				КонецЕсли;
				
			КонецЕсли;	
			
		КонецЕсли;
		
	КонецЕсли;	
	
	Возврат СтруктураШапкиДокумента;
	
КонецФункции

//Формирует структуру, содержащую значения реквизитов шапки документа.
//Проверяет признаки отражения в учете
//При необходимости корректирует признаки отражения в учете в связи с отложенным проведением или допроведением документа
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//	Отказ - признак отказа от проведения документа
//	Заголовок - строка, заголовок для формирования сообщений об ошибках
//	МожетБытьТолькоНалоговый - булево, признак того что флаг отражения в НУ может быть установлен независимо от флага отражения в БУ
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокументаИПроверитьОтражениеВУчете(ДокументОбъект, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь) Экспорт
	СтруктураШапкиДокумента = СформироватьСтруктуруШапкиДокумента(ДокументОбъект);
	
	ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок);
	Если Отказ Тогда
		Возврат СтруктураШапкиДокумента;
	КонецЕсли;
	
	//Проверяем - возможно, документ должен проводиться отложенно
	Если ОтложенноеПроведениеДокументов.ДокументПодерживаетОтложенноеПроведение(ДокументОбъект,СтруктураШапкиДокумента) Тогда
		ОтложенноеПроведениеДокументов.ПодготовитьКПроведениюПоВидамУчета(ДокументОбъект.ДополнительныеСвойства, СтруктураШапкиДокумента);
	КонецЕсли;
	Возврат СтруктураШапкиДокумента;
КонецФункции


// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений               - набор движений регистра,
//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
//  реквизитов составного типа, которые могут содержать пустые ссылки.
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
	                                  ПустыеКолонкиСоставногоТипа = Неопределено) Экспорт

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	//
	КолонкиТаблицы = ТаблицаДвижений.Колонки;
	
	//
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	ИзмеренияСостТипаСтр = "";
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаИзм.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаИзм.Имя;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаРек.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаРек.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРек.Имя;
			КонецЕсли; 
			
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаРес.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаРес.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРес.Имя;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	
	Если ИзмеренияСостТипаСтр <> "" Тогда
		ИзмеренияСостТипаСтр = Сред(ИзмеренияСостТипаСтр, 3);
	КонецЕсли;
	
	ТипЧисло = Тип("Число");
	ТипСтрока = Тип("Строка");
	ТипДата = Тип("Дата");
	
	ЕстьПериод = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;

	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		Движение = НаборДвижений.Добавить();
		ЗаполнитьЗначенияСвойств(Движение, СтрокаДвижения, ,ИзмеренияСостТипаСтр);
		
		Если ВидДвижения <> Неопределено Тогда
			Движение.ВидДвижения = ВидДвижения;
		КонецЕсли;
		
		Если ЕстьПериод И НЕ СтрокаДвижения.Период = '00010101000000' Тогда
			Движение.Период = СтрокаДвижения.Период;
		ИначеЕсли НаборДвижений.мПериод <> Неопределено Тогда
			Движение.Период = НаборДвижений.мПериод;
		КонецЕсли; 
		Движение.Активность = Истина;
		
		Для Каждого КлючИЗначение ИЗ ИзмеренияСостТипа Цикл
			ЗначениеВКолонке = СтрокаДвижения[КлючИЗначение.Ключ];
			
			Если ЗначениеВКолонке = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗначенияВКолонке = ТипЗнч(ЗначениеВКолонке);
			
			Если ТипЗначенияВКолонке = ТипЧисло Тогда
				Если ЗначениеВКолонке = 0 Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗначенияВКолонке = ТипСтрока Тогда
				Если ЗначениеВКолонке = "" Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗначенияВКолонке = ТипДата Тогда
				Если ЗначениеВКолонке = '00010101000000' Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ЗначениеВКолонке.Пустая() Тогда
				Продолжить;
			КонецЕсли;
			
			Движение[КлючИЗначение.Ключ] = ЗначениеВКолонке;
			
		КонецЦикла;
		
	КонецЦикла;

КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Заполняет набор записей регистра СвободныеОстатки по данным базового регистра
//
// Параметры:
//  НаборСвободныеОстатки	- таблица движений регистра СвободныеОстатки, которую нужно заполнить
//  НаборБазовыйРегистр		- таблица движений регистра (базовый регистр) на основании которого необходимо заполнить регистр СвободныеОстатки
//  ВидРегистраОснования	- перечисление <ВидыРегистровОснованийРегистраСвободныеОстатки>
//
Процедура ЗаполнитьСвободныеОстаткиПоДаннымБазовогоРегистра(НаборСвободныеОстатки, НаборБазовыйРегистр, ВидРегистраОснования) Экспорт

	Если НаборБазовыйРегистр.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
		
	ДатаНачалаИспользованияРегистраСвободныеОстатки = глЗначениеПеременной("ДатаНачалаИспользованияРегистраСвободныеОстатки");
	
	// Сначала проверим период записей, потом выполним заполнение
	// Считаем, что период всех записей одинаковый
	Если НаборБазовыйРегистр[0].Период < ДатаНачалаИспользованияРегистраСвободныеОстатки Тогда
		Возврат;
	КонецЕсли;
	
	ОбратныйВидДвижения = (ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыВРезервеНаСкладах
							ИЛИ ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыКПередачеСоСкладов);
			
	Для каждого ЭлДвижение Из НаборБазовыйРегистр Цикл
		
		ЭлЗапись = НаборСвободныеОстатки.Добавить();
		ЭлЗапись.РегистрОснование = ВидРегистраОснования;
		ЗаполнитьЗначенияСвойств(ЭлЗапись, ЭлДвижение);
		
		Если ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыВРезервеНаСкладах Тогда
			ЭлЗапись.Качество = Справочники.Качество.Новый;
		КонецЕсли;
		
		Если ОбратныйВидДвижения Тогда
			Если ЭлЗапись.ВидДвижения = ВидДвиженияНакопления.Приход Тогда
				ЭлЗапись.ВидДвижения = ВидДвиженияНакопления.Расход;
			Иначе
				ЭлЗапись.ВидДвижения = ВидДвиженияНакопления.Приход;
			КонецЕсли; 
		КонецЕсли;
		
		Если ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыВРезервеНаСкладах Тогда
			// Резервирование зависит от обособленного учета (ОУ)
			// если ведется ОУ, то резервирование влияет на количество с учетом серии
			// если ОУ не ведется, количество с учетом серии не изменяется
			Если глЗначениеПеременной("ИспользоватьУказаниеСерийНоменклатурыПриРезервировании") Тогда
				ТипДокументСсылкаЗаказПокупателя = Тип("ДокументСсылка.ЗаказПокупателя");
				Если ТипЗнч(ЭлДвижение.ДокументРезерва) = ТипДокументСсылкаЗаказПокупателя 
					И ЭлДвижение.ДокументРезерва.ДоговорКонтрагента.ОбособленныйУчетТоваровПоЗаказамПокупателей Тогда
					
					ЭлЗапись.КоличествоСУчетомСерии = ЭлЗапись.Количество;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			ЭлЗапись.КоличествоСУчетомСерии = ЭлЗапись.Количество;
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры //
 
// Выполняет движения по регистру СвободныеОстатки.
//
// Параметры:
//  НаборДвижений			- таблица движений регистра (базовый регистр) на основании которого необходимо заполнить регистр СвободныеОстатки
//  Регистратор				- документ, регистратор движений
//  Замещение				- булево, замещать записи регистра	
//  ВидРегистраОснования	- перечисление <ВидыРегистровОснованийРегистраСвободныеОстатки>
//
Процедура ВыполнитьДвиженияПоРегиструСвободныеОстатки(НаборДвижений, Регистратор, Замещение, ВидРегистраОснования, Отказ = Ложь) Экспорт
	
	Если НЕ глЗначениеПеременной("ИспользоватьРегистрСвободныеОстатки") Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Регистратор) = Тип("ДокументСсылка.КорректировкаЗаписейРегистров") Тогда
		// При изменении базовых регистров документом "Корректировка записей регистров"
		// не выполняется автоматическое формирование движений по регистру
		Возврат;
	КонецЕсли; 
	
	НаборСвободныеОстатки = РегистрыНакопления.СвободныеОстатки.СоздатьНаборЗаписей();
	НаборСвободныеОстатки.Отбор.Регистратор.Установить(Регистратор);
	
	ЗаполнитьСвободныеОстаткиПоДаннымБазовогоРегистра(НаборСвободныеОстатки, НаборДвижений, ВидРегистраОснования);
	
	Попытка
		
		// Набор может не измениться
		Если НаборСвободныеОстатки.Модифицированность() Тогда
			НаборСвободныеОстатки.Записать(Ложь);
		КонецЕсли; 
	
	Исключение
		СообщитьОбОшибке(ОписаниеОшибки(), Отказ); 
		ВызватьИсключение "Операция не выполнена";
	КонецПопытки;	
	
КонецПроцедуры // ВыполнитьДвиженияПоРегиструСвободныеОстатки
 
// Процедура сворачивает движения по регистру накопления
//
Процедура СвернутьТаблицуДвиженийРегистраНакопления(НаборДвижений, ТабДвижений = Неопределено, УдалятьПустыеДвижения = Ложь) Экспорт
	
	Если ТипЗнч(НаборДвижений) = Тип("Строка") Тогда
		МетаРег = Метаданные.РегистрыНакопления[НаборДвижений];
		ТаблицаДвижений = ТабДвижений;
	Иначе
		МетаРег = НаборДвижений.Метаданные();
		Если ТабДвижений = Неопределено Тогда
			ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
		Иначе
			ТаблицаДвижений = ТабДвижений;
		КонецЕсли;
	КонецЕсли;
	
	
	Если ТаблицаДвижений = Неопределено ИЛИ ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Измерения = "Период,Регистратор,Активность";
	Если МетаРег.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
		Измерения = Измерения + ",ВидДвижения";
	КонецЕсли;
	
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Измерения = Измерения + "," + МетаИзм.Имя;
	КонецЦикла;
	Для Каждого МетаИзм Из МетаРег.Реквизиты Цикл
		Измерения = Измерения + "," + МетаИзм.Имя;
	КонецЦикла;
	
	Ресурсы = "";
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Ресурсы = Ресурсы + МетаРес.Имя + ",";
	КонецЦикла;
	
	ТаблицаДвижений.Свернуть(Измерения, Ресурсы);
	
	Если УдалятьПустыеДвижения Тогда
		
		СтруктРесурсы   = Новый Структура(Ресурсы);
		МассивПустСтрок = Новый Массив;
		СтруктПоиска    = Новый Структура;
		
		Для Каждого РесурсКлюч Из СтруктРесурсы Цикл
			СтруктПоиска.Вставить( РесурсКлюч.Ключ, 0);
		КонецЦикла;
		
		МассивПустСтрок = ТаблицаДвижений.НайтиСтроки(СтруктПоиска);
		Для К = 0 По МассивПустСтрок.ВГраница() Цикл
			ТаблицаДвижений.Удалить(МассивПустСтрок[К]);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры // СвернутьТаблицуДвиженийРегистраНакопления()

// Получить движение(набор записей) для документа-объекта
//
// Параметры
//  Объект  – 	ДокументОбъект – Документ. для которого производится поиск движения
//  ТипДвижения  – Регистр<...>Менеджер – менеджер регистра, движение по которому пытаемся сформировать
//             или <Строка> - имя регистра, движение по которому пытаемся сформировать
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей   – набор записей для объекта
//   или Неопределено - если такого регистра не существует или документ не является регистратором регистра
//
Функция ПолучитьДвижение(Объект, ТипДвижения, Сообщать=Ложь) Экспорт
	
	Если ТипЗнч(ТипДвижения) = Тип("Строка") Тогда
		Движение = Объект.Движения.Найти(ТипДвижения);
		ДвижениеНевозможно = Движение = Неопределено;
	Иначе
		ТипТипаДвижения = ТипЗнч(ТипДвижения.СоздатьНаборЗаписей());
		ДвижениеНевозможно = Истина;
		Для каждого Движение Из Объект.Движения Цикл
			Если ТипЗнч(Движение) = ТипТипаДвижения Тогда
				ДвижениеНевозможно = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ДвижениеНевозможно Тогда
			Движение = Неопределено;
		КонецЕсли; 
	КонецЕсли;
	
	Если Сообщать И ДвижениеНевозможно Тогда
		Если ТипЗнч(ТипДвижения) = Тип("Строка") Тогда
			ПредставлениеТипаДвижения = ТипДвижения;
		Иначе
			ПредставлениеТипаДвижения = Строка(ТипЗнч(ТипДвижения));
		КонецЕсли;
		СообщитьОбОшибке("Требуется подключение """ + ТипЗнч(Объект) + """ к формированиям движения по регистру """ + ПредставлениеТипаДвижения + """!");
	КонецЕсли;
	
	Возврат Движение;
	
КонецФункции // ПолучитьДвижение()

// Получить набор записей по регистру по ссылке на документ
//
// Параметры
//  Ссылка  		– ДокументСсылка		– Ссылка на документ, для которого производится поиск движений по регистру (набора записей)
//  РегистрДвижения – Регистр<...>Менеджер	– менеджер регистра, движение по которому пытаемся обнаружить
//  ПрочитатьЗаписи - Булево 				- Прочитать существующий набор записей для документа (если документ может формировать движения по указанному регистру).
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей – Набор записей по регистру с отбором по документу,
//	 Неопределено 				в случае если документ не может формировать движений по регистру.
//
Функция ПолучитьНаборЗаписейПоСсылке(Ссылка, РегистрДвижения, ПрочитатьЗаписи = Ложь, Сообщать=Ложь) Экспорт
	Движения = неопределено;
	Если Ссылка.Метаданные().Движения.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(РегистрДвижения))) тогда
        Движения = РегистрДвижения.СоздатьНаборЗаписей();
		Движения.Отбор.Регистратор.Установить(Ссылка);
		Если ПрочитатьЗаписи тогда
			Движения.Прочитать();
		КонецЕсли;
	ИначеЕсли Сообщать тогда
			СообщитьОбОшибке("Требуется подключение документа """+Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).Представление()+""" к формированию движений по регистру """+
			СтрЗаменить(Лев(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":"))," менеджер","")+Сред(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":")+1)+
			"""!");
	КонецЕсли;
	
	Возврат Движения;
КонецФункции // ПолучитьНаборЗаписейПоСсылке()

// Процедура сворачивает переданный набор записей регистра бухгалтерии по измерениям и реквизитам
// Параметры: НаборЗаписейРегистраБухгалтерии, тип - набор записей регистров бухгалтерии Налоговый или Основной
//            СтрокаГруппировка, тип - строка - список колонок таблицы значений по которым будет выполняться группировка
//            СтрокаСуммирование, тип - строка - список колонок таблицы значений которые будут суммироваться
//            ВестиРеглУчетРасчетовСПерсоналомСводно, тип - булево - признак ведения сводного учета расчетов с персоналом
//            МассивСчетовРасчетовСПерсоналом, тип - массив - список счетов учета расчетов с персоналом
Процедура СвернутьНаборЗаписейРегистраБухгалтерии(НаборЗаписейРегистраБухгалтерии,
							СтрокаГруппировка, СтрокаСуммирование,
							ВестиРеглУчетРасчетовСПерсоналомСводно = Ложь, МассивСчетовРасчетовСПерсоналом = Неопределено) Экспорт
	Перем ТаблицаЗаписейРегистраБухгалтерии;
	
	КоличествоЗаписейНабораЗаписей = НаборЗаписейРегистраБухгалтерии.Количество();
	// Если количество записей равно 0 - не требуется выполнять сворачивание
	Если КоличествоЗаписейНабораЗаписей = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаЗаписейРегистраБухгалтерии = НаборЗаписейРегистраБухгалтерии.Выгрузить();
	// Данная колонка в таблице не нужна
	ТаблицаЗаписейРегистраБухгалтерии.Колонки.Удалить("НомерСтроки");
	
	// Признак наличия проводок по счетам учета расчетов с персоналом
	ЕстьСчетаУчетаРасчетовСПерсоналом = Ложь;
	// Признак произведенной очистки субконто
	ЕстьОчищенныеСубконто = Ложь;
	
	// Если способ ведения расчетов с персоналом - сводно,
	// то перед сворачиванием могут потребоваться дополнительные действия по очистке аналитики в проводках
	Если ВестиРеглУчетРасчетовСПерсоналомСводно = Истина Тогда
		
		ТаблицаЗаписейРегистраБухгалтерии.Индексы.Добавить("СчетДт");
		ТаблицаЗаписейРегистраБухгалтерии.Индексы.Добавить("СчетКт");
		// Определим, есть ли проводки со счетами учета расчетов с персоналом
		// Для таких проводок потребуется выполнить очистку значений субконто
		Для Каждого Счет Из МассивСчетовРасчетовСПерсоналом Цикл
			Если ТаблицаЗаписейРегистраБухгалтерии.Найти(Счет, "СчетДт,СчетКт") <> Неопределено Тогда
				ЕстьСчетаУчетаРасчетовСПерсоналом = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		// Обнаружены проводки, у которых указаны счета расчетов с персоналом
		Если ЕстьСчетаУчетаРасчетовСПерсоналом Тогда
			
			// Создаем массив префиксов имен колонок таблицы записей регистра
			// С его помощью будем обращатся к именам колонок счетов и субконто Дт и Кт в цикле
			// чтобы не дублировать код, различающийся только именами колонок таблицы записей регистра
			ПрефиксыКолонок = Новый Массив;
			ПрефиксыКолонок.Добавить("Дт");
			ПрефиксыКолонок.Добавить("Кт");
			
			// Готовим соответствие счета расчетов и количества субконто счета
			СоответствиеКоличествоСубконтоСчета = Новый Соответствие;
			Для Каждого СчетРасчетов Из МассивСчетовРасчетовСПерсоналом Цикл
				СоответствиеКоличествоСубконтоСчета.Вставить(СчетРасчетов, СчетРасчетов.ВидыСубконто.Количество());
			КонецЦикла;
			
			// Готовим соответствие видов очищаемых субконто и пустых значений субконто
			СоответствиеПустыхЗначенийСубконто = Новый Соответствие;
			ВидСубконто = ПланыВидовХарактеристик.ВидыСубконто.РаботникиОрганизации;
			СоответствиеПустыхЗначенийСубконто.Вставить(ВидСубконто,
				Новый Структура("ПустоеЗначениеСубконто", ВидСубконто.ТипЗначения.ПривестиЗначение()));
			ВидСубконто = ПланыВидовХарактеристик.ВидыСубконто.ВидНачисленийОплатыТрудаПоСтатье255НК;
			СоответствиеПустыхЗначенийСубконто.Вставить(ВидСубконто,
				Новый Структура("ПустоеЗначениеСубконто", ВидСубконто.ТипЗначения.ПривестиЗначение()));
			
			Для Каждого СтрокаТаблицы Из ТаблицаЗаписейРегистраБухгалтерии Цикл
				// Проверка счетов дебета и кредита
				Для Каждого ПрефиксКолонки Из ПрефиксыКолонок Цикл
					
					КоличествоСубконто = СоответствиеКоличествоСубконтоСчета[СтрокаТаблицы["Счет" + ПрефиксКолонки]];
					Если КоличествоСубконто <> Неопределено Тогда
						
						// Если в дебете или кредите стоит счет расчетов с персоналом - очистим некоторые аналитики
						Для НомерСубконто = 1 По КоличествоСубконто Цикл
							
							ВидСубконто = СтрокаТаблицы["ВидСубконто" + ПрефиксКолонки + НомерСубконто];
							СтруктураПустоеСубконто = СоответствиеПустыхЗначенийСубконто[ВидСубконто];
							Если СтруктураПустоеСубконто <> Неопределено Тогда
								ТекущееЗначениеСубконто = СтрокаТаблицы["Субконто" + ПрефиксКолонки + НомерСубконто];
								Если ТекущееЗначениеСубконто <> СтруктураПустоеСубконто.ПустоеЗначениеСубконто Тогда
									СтрокаТаблицы["Субконто" + ПрефиксКолонки + НомерСубконто] = СтруктураПустоеСубконто.ПустоеЗначениеСубконто;
									ЕстьОчищенныеСубконто = Истина;
								КонецЕсли;
							КонецЕсли;
							
						КонецЦикла;
						
					КонецЕсли;
					
				КонецЦикла;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ТаблицаЗаписейРегистраБухгалтерии.Свернуть(СтрокаГруппировка,СтрокаСуммирование);
	// Если аналитика не очищалась и количество записей осталось без изменений 
	//	- не требуется загружать свернутую таблицу в набор записей 
	Если НЕ ЕстьОчищенныеСубконто
	 И ТаблицаЗаписейРегистраБухгалтерии.Количество() = КоличествоЗаписейНабораЗаписей Тогда
		Возврат;
	КонецЕсли;
	
	// Поиск и удаление проводок с пустым  количеством и суммой
	
	// Готовим структуру поиска - нулевые значения колонок, которые входят в список суммируемых колонок
	СтруктураПоиска = Новый Структура(СтрокаСуммирование);
	Для Каждого ЭлементСтруктуры Из СтруктураПоиска Цикл
		СтруктураПоиска[ЭлементСтруктуры.Ключ] = 0;
	КонецЦикла;
	
	// Удаление строк с пустыми значениями суммируемых колонок
	МассивСтрокКУдалению = ТаблицаЗаписейРегистраБухгалтерии.НайтиСтроки(СтруктураПоиска);
	Для Каждого ЭлементМассива Из МассивСтрокКУдалению Цикл
		 ТаблицаЗаписейРегистраБухгалтерии.Удалить(ЭлементМассива);
	КонецЦикла;
	
	НаборЗаписейРегистраБухгалтерии.Загрузить(ТаблицаЗаписейРегистраБухгалтерии);
	
КонецПроцедуры

// Возвращает рабочую дату
//
// Возвращаемое значение:
//   Дата - рабочая дата
//
Функция ПолучитьРабочуюДату() Экспорт

#Если Клиент Тогда
	Дата = РабочаяДата;
#Иначе
	Дата = ТекущаяДата();
#КонецЕсли

	Возврат Дата;

КонецФункции // ПолучитьРабочуюДату()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Истина;
	
КонецФункции


// Процедура заполняет субконто в строке набора записей
// Параметры 
// Запись - Строка набора записей регистра бухгалтерии
// Строка - Структура, содержащая значения субконто
//
Процедура ЗаполнитьСубконтоВНабореЗаписей(Запись,Строка)
	
	Для НомерСчета = 1 по 2 Цикл
		
		Если НомерСчета = 1 тогда 
			СчетДтКТ = "Дт"
		Иначе
			СчетДтКТ = "Кт"
		КонецЕсли;
		
		Для НомерСубконто = 1 по 3 цикл
			
			ЗначениеСубконто = Строка["Субконто"+СчетДтКТ+НомерСубконто];

			ВидСубконто = Строка["ВидСубконто"+СчетДтКТ+НомерСубконто];
			Если ВидСубконто.ТипЗначения <> Неопределено Тогда
				Запись["Субконто"+СчетДтКТ].Вставить(ВидСубконто, ЗначениеСубконто);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;

КонецПроцедуры // ЗаполнитьСубконтоВНабореЗаписей

// Добавляет записи из таблицы движений в набор записей
// Параметры 
// НаборЗаписей - Набор записей регистра накопления или регистра бухгалтерии
// Таблица - таблица значений содержащая движения соответствующего регистра (таблица движений)
//
Процедура ДобавитьСтрокиВНаборЗаписей(НаборЗаписей, Таблица) Экспорт
	
	НаборМетаданные = НаборЗаписей.Метаданные();
		
	ЭтоРегистрБухгалтерии = (Метаданные.РегистрыБухгалтерии.Найти(НаборМетаданные.Имя)<>Неопределено);
	
	Регистратор = НаборЗаписей.Отбор.Регистратор.Значение;
	
	Период = Неопределено;
	
	Для Каждого Строка Из Таблица Цикл
		
		Запись = НаборЗаписей.Добавить();
			
		ЗаполнитьЗначенияСвойств(Запись,Строка);
			
		Запись.Активность = Истина;

		Если Запись.Период = '00010101' Тогда
			
			Если Период = Неопределено Тогда
				
				Период = Регистратор.Дата;
			
			КонецЕсли;
			
			Запись.Период = Период;
			
		КонецЕсли;
			
		Если ЭтоРегистрБухгалтерии тогда
			ЗаполнитьСубконтоВНабореЗаписей(Запись,Строка)
		КонецЕсли;
		
	КонецЦикла;

КонецПроцедуры // ДобавитьСтрокиВНаборЗаписей

////////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИКА

// возвращает "количество полных и неполных рублей"
// Параметры:
//	Сумма - число
// Возвращаемое значение:
//  число, равное ближайшему целому "сверху"
Функция ЦелМаксимальное(Сумма) Экспорт
	Возврат ?(Цел(Сумма) = Сумма, Сумма, Цел(Сумма) + 1);
	
КонецФункции // ЦелМаксимальное()

Функция ДесятичноеВШестнадцатиричное(Источник) Экспорт
	
	ШеснадцатиричныеСимволы = "0123456789ABCDEF";
	
	Если Источник < 0 Тогда
		Возврат "00";
	КонецЕсли;
	Если Источник > 255 Тогда
		Возврат "FF";
	КонецЕсли;
	
	ПервыйСимвол	= Цел(Источник / 16) + 1;
	ВтройСимвол		= Источник % 16 + 1;
	
	Возврат Сред(ШеснадцатиричныеСимволы, ПервыйСимвол, 1) + Сред(ШеснадцатиричныеСимволы, ВтройСимвол, 1);
	
КонецФункции


// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УЧЕТНОЙ ПОЛИТИКОЙ

// Функция возвращает структуру с параметрами учетной политики (Упр) на заданную дату.
//
// Параметры:
//	Период					- дата на которую необходимо получить учетную политику
//	СообщатьОбОшибке		- булево, если Истина, то вывести сообщение,
//							когда на дату нет учетной политики
// Возвращаемое значение:
// <Структура>				- если на дату нет учетной политики, то Неопределено
//
Функция ПолучитьПараметрыУчетнойПолитикиУпр(Период, СообщатьОбОшибке = Истина) Экспорт

	Если НЕ ЗначениеЗаполнено(Период) Тогда
		Возврат Неопределено;	
	КонецЕсли;
	
	УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаУпр");
	
	Для каждого СтрокаУчетнойПолитики Из УчетнаяПолитика Цикл
		// Строки таблицы УчетнаяПолитика упорядочены по убыванию,
		// поэтому необходимо найти строку с периодом раньше даты, 
		// на которую необходимо получить УП
		Если СтрокаУчетнойПолитики.Период <= Период Тогда
			Результат = Новый Структура;
			
			Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
				Результат.Вставить(Колонка.Имя, СтрокаУчетнойПолитики[Колонка.Имя]);
			КонецЦикла;
			
			Возврат Результат;	
		КонецЕсли; 
	КонецЦикла;
	
	Если СообщатьОбОшибке Тогда
		ТекстОшибки = "Не указаны параметры учетной политики (управленческий учет) на " + Формат(Период, "ДЛФ=DD");
		СообщитьОбОшибке(ТекстОшибки);
	КонецЕсли; 
	
	Возврат Неопределено;	
	
КонецФункции // ПолучитьПараметрыУчетнойПолитикиУпр

// Функция возвращает структуру с параметрами учетной политики (регл учета)
// на заданную дату по указанной организации.
//
// Параметры:
//	Период					- дата на которую необходимо получить учетную политику
//	Организация				- Организация по которой необходимо получить учетную политику
//	СообщатьОбОшибке		- булево, если Истина, то вывести сообщение,
//
// Возвращаемое значение:
// <Структура>				- если на дату нет учетной политики, то Неопределено
//
Функция ПолучитьПараметрыУчетнойПолитикиРегл(Период, Организация, СообщатьОбОшибке = Истина) Экспорт

	Если НЕ ЗначениеЗаполнено(Период) 
		ИЛИ НЕ ЗначениеЗаполнено(Организация)  Тогда
		
		Возврат Неопределено;	
	КонецЕсли;
	
	//Запрос = Новый Запрос;
	//ТекстЗапроса = "ВЫБРАТЬ
	//			   |	Организации.ОтражатьВРегламентированномУчете КАК ОтражатьВРегламентированномУчете
	//			   |ИЗ
	//			   |	Справочник.Организации КАК Организации
	//			   |ГДЕ
	//			   |	Организации.Ссылка = &Ссылка";
	//Запрос.Текст = ТекстЗапроса;
	//Запрос.УстановитьПараметр("Ссылка", Организация);
	//Выборка = Запрос.Выполнить().Выбрать();
	//Если Выборка.Следующий() Тогда
	//	Если НЕ Выборка.ОтражатьВРегламентированномУчете Тогда
	//		Возврат Неопределено;	
	//	КонецЕсли;
	//КонецЕсли;
	
	УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаРегл");
	
	Для каждого СтрокаУчетнойПолитики Из УчетнаяПолитика Цикл
		// Строки таблицы УчетнаяПолитика упорядочены по убыванию,
		// поэтому необходимо найти строку с периодом раньше даты, 
		// на которую необходимо получить УП
		Если СтрокаУчетнойПолитики.Организация = Организация
			И СтрокаУчетнойПолитики.Период <= Период Тогда
			
			Результат = Новый Структура;
			
			Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
				Результат.Вставить(Колонка.Имя, СтрокаУчетнойПолитики[Колонка.Имя]);
			КонецЦикла;
			
			// Для сохранения совместимости со старой версией хранения параметра УСН
			Результат.Вставить("УСН", СтрокаУчетнойПолитики.СистемаНалогообложения = Перечисления.СистемыНалогообложения.Упрощенная);
			
			// Начиная с 01.01.2006 "Момент определения налоговой базы НДС" всегда "По отгрузке"
			Если Период>= '20060101' 
				И Результат.Свойство("МоментОпределенияНалоговойБазыНДС") 
				И Результат.МоментОпределенияНалоговойБазыНДС = Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОплате Тогда			
				
				Результат.Вставить("МоментОпределенияНалоговойБазыНДС", Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОтгрузке);
			КонецЕсли; 
			
			// Начиная с 01.01.2008 "Налоговый период" всегда "Квартал"
			Если Период>= '20080101' 
				И Результат.Свойство("НДСНалоговыйПериод") 
				И Результат.НДСНалоговыйПериод = Перечисления.Периодичность.Месяц Тогда
				
				Результат.Вставить("НДСНалоговыйПериод", Перечисления.Периодичность.Квартал);
			КонецЕсли; 
			
			Возврат Результат;	
		КонецЕсли; 
	КонецЦикла;
	
	Если СообщатьОбОшибке Тогда
		ТекстОшибки = "Не указаны параметры учетной политики (бухгалтерский и налоговый учет) на " + Формат(Период, "ДЛФ=DD") + " для организации " + Организация;
		СообщитьОбОшибке(ТекстОшибки);
	КонецЕсли; 
	
	Возврат Неопределено;	

КонецФункции // ПолучитьПараметрыУчетнойПолитикиРегл

// Временная функция. Необходимо использовать функции ПолучитьПараметрыУчетнойПолитикиУпр и ПолучитьПараметрыУчетнойПолитикиРегл
//
Функция ПолучитьПараметрыУчетнойПолитики(КонДата, УчетнаяПолитикаНеЗадана, Организация = Неопределено, Учет = "регл", СообщатьОбОшибке = Истина) Экспорт
	
	//Если НРег(Учет) = "упр" Тогда
	//	ПараметрыУчетнойПолитки = ПолучитьПараметрыУчетнойПолитикиУпр(КонДата, СообщатьОбОшибке);
	//Иначе
		ПараметрыУчетнойПолитки = ПолучитьПараметрыУчетнойПолитикиРегл(КонДата, Организация, СообщатьОбОшибке);
	//КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ПараметрыУчетнойПолитки) Тогда
		УчетнаяПолитикаНеЗадана = Истина;
	КонецЕсли; 
	
	Возврат ПараметрыУчетнойПолитки;
	
КонецФункции // ПолучитьПараметрыУчетнойПолитики

// Процедура выводить сообщение о необходимости перезапуска программы при изменении учетной политики
// если в ИБ работают другие пользователи.
//
Процедура СообщитьОбИзмененииУчетнойПолитики() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы() ;
	Для Каждого ТекСоединение Из МассивСоединений Цикл
		Если (ТекСоединение.ИмяПриложения = "1CV8") 
		   И (НЕ ТекСоединение.НомерСоединения = НомерСоединенияИнформационнойБазы())
		   И (НЕ ТекСоединение.Пользователь = неопределено) Тогда
			  
				Сообщить("Внимание! Вы изменили настройки учетной политики.
						 |В настоящий момент в базе работают пользователи. 
						 |Для того чтобы новые настройки начали действовать у других пользователей
						 |им необходимо перезапустить программу. 
						 |Для Вас новые настройки уже вступили в силу, перезапускать программу не требуется.", СтатусСообщения.Важное);
						 
				Возврат;
							
		КонецЕсли;
	КонецЦикла;			
	
КонецПроцедуры

// Функция дополняет структуру шапки документа положениями учетной политики.
//
Процедура ДополнитьПоложениямиУчетнойПолитики(СтруктураШапкиДокумента, КонДата, Отказ, Организация, Учет = "Нал", СтруктураПолейУчетнойПолитикиНУ = неопределено) Экспорт
	
	Если Учет = "Упр" Тогда
		СтруктураУП = ПолучитьПараметрыУчетнойПолитикиУпр(КонДата);
	Иначе
		СтруктураУП = ПолучитьПараметрыУчетнойПолитикиРегл(КонДата, Организация);
	КонецЕсли; 
	Если НЕ ЗначениеЗаполнено(СтруктураУП) Тогда
		Отказ = Истина;
		Возврат;
	КонецЕсли;
	
	Для каждого ПараметрУП Из СтруктураУП Цикл
		Если (ТипЗнч(СтруктураПолейУчетнойПолитикиНУ) = Тип("Структура"))
		   И НЕ (СтруктураПолейУчетнойПолитикиНУ.Количество() = 0) Тогда
		   
		   // Заполнение определенными параметрами учетной политики
			Если СтруктураПолейУчетнойПолитикиНУ.Свойство(ПараметрУП.Ключ) Тогда
				Если НЕ ЗначениеЗаполнено(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ]) Тогда
					СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);
				Иначе
					СтруктураШапкиДокумента.Вставить(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ],ПараметрУП.Значение);
				КонецЕсли; 
			КонецЕсли; 
			
		Иначе	
			
			// Заполнение всеми параметрами учетной политики
			СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);  
			
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры // ДополнитьПоложениямиУчетнойПолитики()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

#Если Клиент Тогда

// Процедура выполняет открытие HTML-страницы 
// по указанному URL
Процедура Интерфейс1Действие() Экспорт
	Форма = Обработки.Обозреватель.ПолучитьФорму("Форма",,"Опрос");
	Форма.Заголовок = "Отзыв о программе";
	Форма.СтартоваяСтраница = "www.1c.ru/usability/inquirer/upp.jsp";
	Форма.Открыть();
КонецПроцедуры

#КонецЕсли

////////////////////////////////////////////////////////////////////////////////
// РАБОТА С ПЕРЕМЕННЫМИ

// Меняет местами значения двух доступных для записи переменных
//
// Параметры
//  Источник - первая переменная
//  Приемник – вторая переменная
//
Процедура ПоменятьПеременныеМестами(Источник, Приемник) Экспорт

	тмп = Источник;
	Источник = Приемник;
	Приемник = Тмп;

КонецПроцедуры // ПоменятьПеременныеМестами()

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока Истина Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока Истина Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // глРазложить

// Возвращает строку, полученную из массива элементов, разделенных символом разделителя
//
// Параметры:
//  Массив - Массив - массив элементов из которых необходимо получить строку
//  Разделитель - Строка - любой набор символов, который будет использован как разделитель между элементами в строке
//
// Возвращаемое значение:
//  Результат - Строка - строка, полученная из массива элементов, разделенных символом разделителя
// 
Функция ПолучитьСтрокуИзМассиваПодстрок(Массив, Разделитель = ",") Экспорт
	
	// возвращаемое значение функции
	Результат = "";
	
	Для Каждого Элемент ИЗ Массив Цикл
		
		Подстрока = ?(ТипЗнч(Элемент) = Тип("Строка"), Элемент, Строка(Элемент));
		
		РазделительПодстрок = ?(ПустаяСтрока(Результат), "", Разделитель);
		
		Результат = Результат + РазделительПодстрок + Подстрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Функция раскладывает Наименование в массив из трех элементов
//
// Параметры
//  ФИО  - строка - наименование
//
// Возвращаемое значение:
//   Массив   - массив из трех элементов, Фамилия, Имя, Отчество
//
Функция ПолучитьМассивФИО(ФИО) Экспорт

	МассивФИО = Новый Массив;
	МассивФИО.Добавить("");
	МассивФИО.Добавить("");
	МассивФИО.Добавить("");
	
	МассивПодсток = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(ФИО, " ");
	Для Индекс = 0 По МассивПодсток.ВГраница() Цикл
		Если Индекс < 3 Тогда
			МассивФИО[Индекс] = МассивПодсток[Индекс];
		Иначе
			МассивФИО[2] = МассивФИО[2] + " " + МассивПодсток[Индекс];
		КонецЕсли;
	КонецЦикла;

	Возврат МассивФИО;
	
КонецФункции // ПолучитьМассивФИО()

// Отбирает из переданной таблицы строки по заданным критериям.
//
// Параметры:
//  Источник - ТаблицаЗначений, РезультатЗапроса, ОбластьЯчеекТабличногоДокумента. Таблица-источник.
//  СтруктураКритериев - Структура. Названия отборов и значения, по которым нужно отобрать строки.
//  СтруктураСложныхКритериев - Структура. Если свойство передано, то значение содержит вид сравнения.
//
// Возвращаемое значение:
//  РезультатЗапроса - таблица с нужными строками.
//
Функция ОтобратьСтрокиПоКритериям(Источник, СтруктураКритериев, СтруктураСложныхКритериев = Неопределено) Экспорт

	Перем ВидСравненияСложный;

	Если СтруктураСложныхКритериев = Неопределено Тогда
		СтруктураСложныхКритериев = Новый Структура;
	КонецЕсли;

	ПостроительЗапроса = Новый ПостроительЗапроса;
	ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(Источник);

	Для Каждого Критерий Из СтруктураКритериев Цикл
		НовыйОтбор = ПостроительЗапроса.Отбор.Добавить(Критерий.Ключ);

		СтруктураСложныхКритериев.Свойство(Критерий.Ключ, ВидСравненияСложный);

		Если ВидСравненияСложный = Неопределено Тогда
			НовыйОтбор.Установить(Критерий.Значение);
		Иначе
			НовыйОтбор.Использование = Истина;
			НовыйОтбор.ВидСравнения = ВидСравненияСложный;
			НовыйОтбор.Значение = Критерий.Значение;
		КонецЕсли;
	КонецЦикла;

	Возврат ПостроительЗапроса.Результат;

КонецФункции // ОтобратьСтрокиПоКритериям()

// Возвращает дату начала периода по имеющимся данным о:
// дате окончании периода, значении перечисления Период, количестве периодов
// 
Функция ПолучитьДатуНачалаПериодаПоДатеОкончанияКоличествуПериодов(ДатаОкончания, ПериодСсылка, КоличествоПериодов) Экспорт
	
	Если КоличествоПериодов = 0 Тогда
		КоличествоПериодов = 1;
	КонецЕсли;
	
	Если ДатаОкончания = Неопределено Тогда
		
		Если КоличествоПериодов > 0 Тогда
			ДатаОкончания = КонецДня(ТекущаяДата());
		ИначеЕсли КоличествоПериодов < 0 Тогда
			ДатаОкончания = НачалоДня(ТекущаяДата());
		КонецЕсли;
		
	КонецЕсли;
	
	Если (ПериодСсылка = Перечисления.Периодичность.День) Тогда
		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24 * КоличествоПериодов);
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Неделя) Тогда
		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24*7 * КоличествоПериодов);
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Декада) Тогда
		ДеньМесяца = День(ДатаОкончания);
		НачМесяца = НачалоМесяца(ДатаОкончания);
		Если ДеньМесяца <= 10 Тогда
			НомерДекады = 1;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НомерДекады = 2;
		Иначе
			НомерДекады = 3;
		КонецЕсли;
		
		НомерДекады = НомерДекады - КоличествоПериодов + ?(КоличествоПериодов > 0, 1 , -1);
		Если НомерДекады > 0 Тогда
			Месяцев = Цел((НомерДекады-1)/3);
		Иначе
			Месяцев = -1 - Цел((-НомерДекады)/3);
		КонецЕсли;
		
		НомерДекады = НомерДекады - 3*Месяцев;
		Дт = ДобавитьМесяц(НачМесяца, Месяцев) + (НомерДекады-1) * 10 * 24 * 60 * 60;
		
		Возврат ?(КоличествоПериодов>0, Дт, ПолучитьКонецДекады(Дт));
		
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Месяц) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Квартал) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(3 * КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Полугодие) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(6 * КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Год) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(12 * КоличествоПериодов)));
	КонецЕсли;
	
	Если КоличествоПериодов > 0 Тогда
		Возврат ДатаНачала + 60*60*24;
	ИначеЕсли КоличествоПериодов < 0 Тогда
		Возврат КонецДня(ДатаНачала - 60*60*24);
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ФОРМИРОВАНИЕ КПП НА БАЗЕ ИНН

#Если Клиент Тогда
// Процедура заполняет КПП на базе ИНН
Процедура ЗаполнитьКППпоИНН(Знач ИНН, КПП, БезусловноеЗаполнениеКПП = Истина) Экспорт
	
	//	Если КПП формируется стандартным образом по ИНН, то для КПП берутся 
	//первые 4 цифры ИНН + 01001, например:
	//ИНН 7712563009
	//КПП 771201001
		
	// если не указано ИНН или заполнено КПП то прерываем выполнение операции
	Если (СтрДлина(ИНН) < 4) Тогда
		Возврат;
	КонецЕсли;
	
	ПревыеСимволыИНН = Лев(ИНН, 4);
	НовоеЗначениеКПП = ПревыеСимволыИНН + "01001";
	
	// если новое значение КПП и старое значение КПП совпадают, то прерываем выполнение операции
	Если (НовоеЗначениеКПП = КПП) Тогда
		Возврат;
	КонецЕсли;
	
	// если безусловно нужно поменять - меняем
	Если БезусловноеЗаполнениеКПП ИЛИ НЕ ЗначениеЗаполнено(КПП) Тогда
		КПП = НовоеЗначениеКПП;
		Возврат;
	КонецЕсли;
	
	ОтветНужноМенятьКПП = (Вопрос("Изменить КПП автоматически на """ + НовоеЗначениеКПП + """?", РежимДиалогаВопрос.ДаНет) = КодВозвратаДиалога.Да);
	Если ОтветНужноМенятьКПП Тогда
		КПП = НовоеЗначениеКПП;
	КонецЕсли;
	
КонецПроцедуры

#КонецЕсли


Функция ПолучитьОсновнойДоговорКонтрагента(Контрагент) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	ДоговорыКонтрагентов.Ссылка КАК ДоступныйДоговорКонтрагента
	|ИЗ
	|	Справочник.ДоговорыКонтрагентов КАК ДоговорыКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновнойДоговорКонтрагента = ДоговорыКонтрагентов.Ссылка
	|ГДЕ
	|	ДоговорыКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновнойДоговорКонтрагента ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";
	
	Запрос.УстановитьПараметр("Контрагент", Контрагент);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ДоступныйДоговорКонтрагента;		
	Иначе
		Возврат Справочники.ДоговорыКонтрагентов.ПустаяСсылка();		
	КонецЕсли;	
		
КонецФункции

Функция ПолучитьОсновноеКонтактноеЛицоКонтрагента(Контрагент) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	КонтактныеЛицаКонтрагентов.Ссылка КАК ДоступноеКонтактноеЛицоКонтрагента
	|ИЗ
	|	Справочник.КонтактныеЛицаКонтрагентов КАК КонтактныеЛицаКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновноеКонтактноеЛицо = КонтактныеЛицаКонтрагентов.Ссылка
	|ГДЕ
	|	КонтактныеЛицаКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновноеКонтактноеЛицо ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";
	
	Запрос.УстановитьПараметр("Контрагент", Контрагент);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ДоступноеКонтактноеЛицоКонтрагента;		
	Иначе
		Возврат Справочники.КонтактныеЛицаКонтрагентов.ПустаяСсылка();		
	КонецЕсли;	
		
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	// Префикс узла распределенной информационной базы добавляется к префиксу-параметру процедуры
	// если есть хоть один периферийный узел в любом из планов обмена:
	// Полный, ОбменУППУПП, ОбменУправлениеПредприятиемУправлениеТорговлей
	//
	// Установка значений параметров сеанса ИспользованиеРИБ, НаличиеОбменаУТУПП
	// выполняется в процедуре ПолныеПрава.ОпределитьФактИспользованияРИБ()
	//Если ПараметрыСеанса.ИспользованиеРИБ
	// ИЛИ ПараметрыСеанса.НаличиеОбменаУТУПП Тогда
	//	Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
	//КонецЕсли;
	
КонецПроцедуры

Функция ОпределитьТекущийРежимРаботыМонопольный() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл
		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ

Процедура ПредупреждениеОбОшибке(ТекстСообщения) Экспорт
	 
	#Если Клиент Тогда
		
		Предупреждение(ТекстСообщения);
	
	#Иначе
		
		ВызватьИсключение(ТекстСообщения);
		
	#КонецЕсли
	 
КонецПроцедуры // ПредупреждениеОбОшибке()

Процедура ЗапуститьПрограмму(ПутьКПрограмме, РабочийКаталог = Неопределено) Экспорт
	
	#Если Клиент Тогда
		
		ЗапуститьПриложение(ПутьКПрограмме, РабочийКаталог);
	
	#КонецЕсли
	
КонецПроцедуры // ЗапуститьПрограмму()

///////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С XML

// Функция осуществляет построение дерева XML.
//
// Параметры
//  XML             - <ЧтениеXML>
//                  - Объект, при помощи которого осуществляется чтение
//                    файла отчета.
//
//  Дерево          - <Структура>
//                  - Дерево XML.
//
//  ПервыйВызов     - <Булево>
//                  - Служебный параметр.
//
// Возвращаемое значение:
//  <Булево>        - Результат выполнения.
//
Функция ПостроитьДеревоXML(XML, Дерево, ПервыйВызов = Истина)

	Результат = Истина;
	Имя       = "";
	Врем      = Неопределено;
	Врем2     = Неопределено;
	Врем3     = Неопределено;

	Если ПервыйВызов Тогда
		Дерево = Новый Структура();
	КонецЕсли;

	Если XML.Прочитать() Тогда
		Если XML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Имя  = XML.ЛокальноеИмя;
			Врем = Новый Структура();
			Пока ПостроитьДеревоXML(XML, Врем, Ложь) Цикл
			КонецЦикла;
			Пока XML.Имя <> Имя Цикл
				Если XML.ТипУзла = ТипУзлаXML.Текст Тогда
					Врем = XML.Значение;
				КонецЕсли;
				Если Не XML.Прочитать() Тогда
					Результат = Ложь;
					Возврат Результат;
				КонецЕсли;
			КонецЦикла;
			Дерево.Свойство(Имя, Врем2);
			Если Врем2 = Неопределено Тогда
				Врем2 = Врем;
			Иначе
				Если ТипЗнч(Врем2) = Тип("Массив") Тогда
					Врем2.Добавить(Врем);
				Иначе
					Врем3 = Новый Массив();
					Врем3.Добавить(Врем2);
					Врем3.Добавить(Врем);
					Врем2 = Врем3;
				КонецЕсли;
			КонецЕсли;
			Дерево.Вставить(Имя, Врем2);
		Иначе
			Результат = Ложь;
		КонецЕсли;
	Иначе
		Результат = Ложь;
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПостроитьДеревоXML()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ

Процедура УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, ПроверятьДвижения=ложь)
	//Очистим коллекцию движений документа
	ТаблицаСтаройРегистрацииВПоследовательности = Новый ТаблицаЗначений();
	ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("ИмяПоследовательности");
	ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("Организация");
	ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("Период");
	
	КоллекцияПоследовательностей = ДокументОбъект.ПринадлежностьПоследовательностям;
	Для Каждого НаборЗаписейРегистрацииВПоследовательности ИЗ КоллекцияПоследовательностей Цикл
		Если (НаборЗаписейРегистрацииВПоследовательности.Количество() > 0) Тогда
			Если НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя = "ПартионныйУчет"  
			  ИЛИ НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя = "ПартионныйУчетБУ" Тогда
			    НаборЗаписейРегистрацииВПоследовательности.Прочитать();
				Для Каждого ЗаписьВПоследовательности Из НаборЗаписейРегистрацииВПоследовательности Цикл
					НоваяЗаписьРегистрации = ТаблицаСтаройРегистрацииВПоследовательности.Добавить();
					НоваяЗаписьРегистрации.ИмяПоследовательности = НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя;
					НоваяЗаписьРегистрации.Организация = ЗаписьВПоследовательности.Организация;
					НоваяЗаписьРегистрации.Период = ЗаписьВПоследовательности.Период;
				КонецЦикла;	
				НаборЗаписейРегистрацииВПоследовательности.Очистить();
			КонецЕсли;	
		   	НаборЗаписейРегистрацииВПоследовательности.Записать();
		КонецЕсли;
	КонецЦикла;
	
	//Если коллекция пуста, то привилегированно очистим набор записей
	ТаблицаСтаройРегистрацииВПоследовательности.Свернуть("ИмяПоследовательности,Организация,Период"); 
	ДокументОбъект.ДополнительныеСвойства.Вставить("ТаблицаСтаройРегистрацииВПоследовательности",ТаблицаСтаройРегистрацииВПоследовательности);
	
КонецПроцедуры//УдалитьРегистрациюДокументаВПоследовательностях

// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ФОРМИРОВАНИЯ ДВИЖЕНИЙ ДОКУМЕНТОВ

// Функция загружает таблицы документа в таблицы соответствующие структуре регистров
//	Параметры:
//		- Движение - движение документа (т.е. регистр)
//		- СтруктТаблицДокумента - структура содержашая таблицы документа. ключ - имя таблицы, значение - таблица значений с данными документа.
//
//	Возврат:
//		- Структура, в которой ключ - это имя таблицы документа, соответствующий параметру СтруктТаблицДокумента,
//		  значение - таблица значений, со структурой соответствующей структуре параметра (т.е. регистра) Движение
//		  В таблицы значений данные загружаются по соответствию с имен полей.
//
Функция ЗагрузитьТаблицыДокументаВСтруктуру(Движение, СтруктТаблицДокумента) Экспорт
	
	ПустаяТабРегистра = Движение.Выгрузить();
	ПустаяТабРегистра.Очистить();
	
	СтруктДанных = Новый Структура;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
	
		ТабРегистра = ПустаяТабРегистра.Скопировать();
		
		Если ТабЧасть.Значение <> Неопределено И ТабЧасть.Значение.Количество() > 0 Тогда
			ЗагрузитьВТаблицуЗначений( ТабЧасть.Значение, ТабРегистра);
		КонецЕсли;
		
		СтруктДанных.Вставить( ТабЧасть.Ключ, ТабРегистра);
		
	КонецЦикла;
	
	Возврат СтруктДанных;

КонецФункции // ЗагрузитьТаблицыДокументаВСтруктуру()

// Процедура заполняет структуру таблиц документа, значением которое будет одинаковым для всех таблиц (например значением шапки документа)
//	Параметры:
//		- СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//		- ИмяПоля - имя колонки в таблицах локумента, в которую будет установлено новое значение
//		- УстанавливаемоеЗначение - значение, которое надо установить в таблицы документа
//		- СтрТабЧасти - имена таб. частей документа в которые необходимо установить новое значение. строка, в которой
//						имена таб. частей разделены запятыми. необязательный параметр, по умолчанию - все таблицы.
//
Процедура УстановитьЗначениеВТаблицыДокумента(СтруктТаблицДокумента, ИмяПоля, УстанавливаемоеЗначение, СтрТабЧасти = "") Экспорт
	
	СтруктТабЧасти = ?( ПустаяСтрока(СтрТабЧасти), СтруктТаблицДокумента, Новый Структура(СтрТабЧасти));
	Для Каждого ТабЧасть Из СтруктТабЧасти Цикл
	
		Если СтруктТаблицДокумента[ТабЧасть.Ключ].Количество() > 0 Тогда
		    СтруктТаблицДокумента[ТабЧасть.Ключ].ЗаполнитьЗначения( УстанавливаемоеЗначение, ИмяПоля);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры // УстановитьЗначениеВТаблицыДокумента()

// Процедура формирует движение в регистр на основании данных в таблицах документов
//	Параметры:
//		- Движение - движение документа, в которое необходимо произвести добавление записей (т.е. регистр)
//		- ВидДвижения - вид движения накопления (приход/расход)
//		- СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//		- ДатаДвижения - дата на которую будут формироваться записи
//
Процедура ЗаписатьТаблицыДокументаВРегистр(Движение, ВидДвижения, СтруктТаблицДокумента, ДатаДвижения) Экспорт
	
	Движение.мПериод = ДатаДвижения;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
	
		Если ТабЧасть.Значение.Количество() = 0 Тогда
			Продолжить; // Пропускаем пустые табличные части
		КонецЕсли;
		
		Движение.мТаблицаДвижений = ТабЧасть.Значение;
		Если ВидДвижения = Неопределено Тогда // Регистр сведений
			ВыполнитьДвижениеПоРегистру(Движение);
		Иначе // Регистр накопления
			ВыполнитьДвижениеПоРегистру(Движение, ВидДвижения);
		КонецЕсли;
	
	КонецЦикла;

КонецПроцедуры // ЗаписатьТаблицыДокументаВРегистр()

// Процедура удаляет строки с пустыми значениями из структуры таблиц документа
//	Параметры:
//		- ТаблицыДляДвиженийПоЗаказам - структура таблиц документа
//		- ИмяПоля - имя поля, значение которого проверяет на пустое значение.
//
Процедура УдалитьСтрокиИзТаблицДокумента(ТаблицыДляДвиженийПоЗаказам, ИмяПоля) Экспорт

	Для Каждого ТабЧасть Из ТаблицыДляДвиженийПоЗаказам Цикл
		КолвоСтрок = ТабЧасть.Значение.Количество(); 
		Для Инд = 1 По КолвоСтрок Цикл 
		     ТекСтрока = ТабЧасть.Значение[КолвоСтрок - Инд]; 

		     Если НЕ ЗначениеЗаполнено(ТекСтрока[ИмяПоля]) Тогда 
		          ТабЧасть.Значение.Удалить(ТекСтрока); 
		     КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
КонецПроцедуры // УдалитьСтрокиИзТаблицДокумента()

// Процедура переименовывает колонку таблицы значений, с сохранением истории переименований для возможности последующего "отката"
//
//	Параметры:
//		- ТабЗначений - таблица значений в которой производится переименование колонок
//		- ТабИмен - таблица с историей переименований. Новые сведения о переименованных колонках добавляются сюда и возвращаются в вызвавшую процедуру
//		- ТекИмяКолонки - имя колонки которую надо переименовать
//		- НовоеИмяКолонки - новое имя колонки. Если параметр не задан, новое имя присваивается автоматически
//
Процедура ПереименоватьКолонкуТаблицыЗначений(ТабЗначений, ТабИмен, Знач ТекИмяКолонки, Знач НовоеИмяКолонки = "") Экспорт

	Если ТабИмен = Неопределено Тогда
		ТабИмен = Новый ТаблицаЗначений;
		ТабИмен.Колонки.Добавить("НовИмя", Новый ОписаниеТипов("Строка"));
		ТабИмен.Колонки.Добавить("ТекИмя",   Новый ОписаниеТипов("Строка"));
	КонецЕсли;
	
	ТекКолонка = ТабЗначений.Колонки.Найти(ТекИмяКолонки);
	Если ПустаяСтрока(НовоеИмяКолонки) Тогда
		// Генерируем новое имя для старой колонки, гарантируя что оно будет уникальным
		Индекс = 1;
		Пока Истина Цикл
			НовоеИмяКолонки = "_" + Строка(Индекс) + "_" + ТекИмяКолонки;
			Если ТабЗначений.Колонки.Найти(НовоеИмяКолонки) = Неопределено Тогда
				Прервать;
			КонецЕсли;
			Индекс = Индекс + 1;
		КонецЦикла;
		// После выхода из цикла в переменной НовоеИмяКолонки должны получить новое имя колонки,
	КонецЕсли;
	
	// Переименуем колонку
	ТабЗначений.Колонки[ТекИмяКолонки].Имя = НовоеИмяКолонки;
	
	// Сохраним имя колонки в таб. имен
	НоваяСтрока = ТабИмен.Добавить();
	НоваяСтрока.НовИмя = НовоеИмяКолонки;
	НоваяСтрока.ТекИмя = ТекИмяКолонки;

КонецПроцедуры // ПереименоватьКолонкуТаблицыЗначений()

// Процедура восстанавливает имена колонок таблицы значений, сохраненные в процедуре ПереименоватьКолонкуТаблицыЗначений()
//
//	Параметры:
//		- ТабЗначений - таблица значений в которой производится переименование колонок
//		- ТабИмен - таблица с историей переименований, таблица создается и заполняется в процедуре ПереименоватьКолонкуТаблицыЗначений()
//
Процедура ВосстановитьИменаКолонокТаблицыЗначений(ТабЗначений, ТабИмен) Экспорт
	
	К = ТабИмен.Количество() - 1;
	Пока К >= 0 Цикл
		ТекСтрока = ТабИмен[К];
		ТабЗначений.Колонки[ТекСтрока.НовИмя].Имя = ТекСтрока.ТекИмя;
		К = К - 1;
	КонецЦикла;
	
	ТабИмен.Очистить();

КонецПроцедуры // ВосстановитьИменаКолонокТаблицыЗначений()

// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ФОРМИРОВАНИЯ ДВИЖЕНИЙ ДОКУМЕНТОВ
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ

// Устанавливает управляемую блокировку таблицы
//
// Параметры:
//  СтруктураПараметров 		- <Структура>. Структура параметров блокировки. Обязательный параметр.
//								Обязательно должна содержать свойства:
//								"ИмяТаблицы" - <Строка> - имя таблицы, на которую накладывается блокировка.
//									Например: "АвансовыйОтчет"
//								Необязательные свойства:
//								"ТипТаблицы" - <Строка> - тип таблицы, на которую накладывается блокировка.
//									Пространство блокировки состоит из типа таблицы и имени таблицы.
//									Например: "Документ"
//									Значение по умолчанию: "РегистрНакопления"
//								"РежимБлокировки" - <РежимБлокировкиДанных> - режим накладываемой блокировки.
//									Значение по умолчанию: РежимБлокировкиДанных.Исключительный
//								"ИсточникДанных" - источник данных для блокировки.
//									Может передаваться значение любого типа, поддерживаемого свойством ИсточникДанных элемента блокировки,
//									а также типа "Менеджер временных таблиц".
//									Если в структуре нет этого свойства - блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
//								"ИмяВременнойТаблицы" - <Строка> - имя временной таблицы менеджера временных таблиц, которая служит источником данных для блокировки.
//									Обязательно должно указываться, если в качестве источника данных процедуре передан менеджер временных таблиц.
//  СтруктураЗначенийБлокировки	- <Структура> - описывает значения блокировки, накладываемые с помощью УстановитьЗначение().
//									Ключ - поле блокировки, значение - блокируемое значение.
//									Если передано Неопределено или если структура не содержит ни одного элемента -
//									блокировки через УстановитьЗначение() не накладываются.
//  СтруктураИсточникаДанных	- <Структура> - описывает значения блокировки, накладываемые с помощью ИспользоватьИзИсточникаДанных().
//									Ключ - поле блокировки, значение - поле источника данных.
//									Если передано Неопределено или если структура не содержит ни одного элемента -
//									блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
//  Отказ 						- <Булево> - при ошибке в процессе установки блокировки в этот параметр процедура возвращает значение Истина
//  Заголовок 					- <Строка> - заголовок сообщения об ошибке при установке блокировки
//
Процедура УстановитьУправляемуюБлокировку(СтруктураПараметров, СтруктураЗначенийБлокировки = Неопределено, СтруктураИсточникаДанных = Неопределено, Отказ, Заголовок) Экспорт
	
	Если НЕ ТипЗнч(СтруктураПараметров) = Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	ИспользоватьЗначенияБлокировки = СтруктураЗначенийБлокировки <> Неопределено 
		И ТипЗнч(СтруктураЗначенийБлокировки) = Тип("Структура") 
		И СтруктураЗначенийБлокировки.Количество() > 0;
		
	ИспользоватьИсточникДанных     = СтруктураИсточникаДанных <> Неопределено 
		И ТипЗнч(СтруктураИсточникаДанных) = Тип("Структура") 
		И СтруктураИсточникаДанных.Количество() > 0
		И СтруктураПараметров.Свойство("ИсточникДанных");
	
	Если НЕ ИспользоватьЗначенияБлокировки И НЕ ИспользоватьИсточникДанных Тогда
		Возврат;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	
	ТипТаблицы = ?(СтруктураПараметров.Свойство("ТипТаблицы"), СтруктураПараметров.ТипТаблицы, "РегистрНакопления") + ".";
	ИмяТаблицы = СтруктураПараметров.ИмяТаблицы;
	ПространствоБлокировки = ТипТаблицы + ИмяТаблицы;
	ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
	
	РежимБлокировки = ?(СтруктураПараметров.Свойство("РежимБлокировки"), СтруктураПараметров.РежимБлокировки, РежимБлокировкиДанных.Исключительный);
	ЭлементБлокировки.Режим = РежимБлокировки;
	
	Если ИспользоватьЗначенияБлокировки Тогда
	
		Для каждого ЭлементСтруктуры Из СтруктураЗначенийБлокировки Цикл
			ЭлементБлокировки.УстановитьЗначение(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
		КонецЦикла;
	
	КонецЕсли;
	
	Если ИспользоватьИсточникДанных Тогда
		
		ИсточникДанных = СтруктураПараметров.ИсточникДанных; 
		
		Если ТипЗнч(ИсточникДанных) = Тип("МенеджерВременныхТаблиц") Тогда
		
			Запрос = Новый Запрос;
			Запрос.МенеджерВременныхТаблиц = ИсточникДанных;
			ТекстЗапроса = "";
			Для каждого ЭлементСтруктуры Из СтруктураИсточникаДанных Цикл
				ТекстЗапроса = ТекстЗапроса + ",
				|	Таб." + ЭлементСтруктуры.Значение;
			КонецЦикла;
			ТекстЗапроса = Сред(ТекстЗапроса, 2);
			ТекстЗапроса = 			
			"ВЫБРАТЬ РАЗЛИЧНЫЕ"
			+ ТекстЗапроса + "
			|ИЗ
			|	" + СтруктураПараметров.ИмяВременнойТаблицы + " КАК Таб";
			Запрос.Текст = ТекстЗапроса;
			Результат    = Запрос.Выполнить();
			
			ЭлементБлокировки.ИсточникДанных = Результат;
			
		Иначе
			
			ЭлементБлокировки.ИсточникДанных = ИсточникДанных;
			
		КонецЕсли;
	
		Для каждого ЭлементСтруктуры Из СтруктураИсточникаДанных Цикл
			ЭлементБлокировки.ИспользоватьИзИсточникаДанных(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
		КонецЦикла;
	
	КонецЕсли;
	
	Попытка
	
		Блокировка.Заблокировать();
	
	Исключение
		
		ОбщегоНазначения.СообщитьОбОшибке(ОписаниеОшибки(), Отказ, Заголовок);
	    ВызватьИсключение "Операция не выполнена";
	КонецПопытки;

КонецПроцедуры

// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА

// Функция разбирает строку вида
// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
// ТипОбъектаМетаданных должен быть Справочник или Документ.
//
// Параметры:
//  ПутьКДанным - строка.
//  МетаданныеОбъекта - Объект метаданных
//
// Возвращаемое значение:
//  Структура - путь к объекту метаданных
//
Функция РазобратьПутьКОбъектуМетаданных(ПутьКДанным, МетаданныеОбъекта = Неопределено) Экспорт
	
	Структура = Новый Структура;
	
	СоответствиеИмен = Новый Массив();
	СоответствиеИмен.Добавить("ТипОбъекта");
	СоответствиеИмен.Добавить("ВидОбъекта");
	СоответствиеИмен.Добавить("ПутьКДанным");
	СоответствиеИмен.Добавить("ИмяТаблЧасти");
	СоответствиеИмен.Добавить("ИмяРеквизита");
	
	Для индекс = 1 по 3 Цикл
		
		Точка = Найти(ПутьКДанным, ".");
		ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
		Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
		ПутьКДанным = Сред(ПутьКДанным, Точка+1);
		
	КонецЦикла;
	
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
	
	Если Структура.ПутьКДанным = "ТабличнаяЧасть" Тогда
		
		Для индекс = 4 по 5  Цикл 
			
			Точка = Найти(ПутьКДанным, ".");
			Если Точка = 0 Тогда
				ТекущееЗначение = ПутьКДанным;
			Иначе
				ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
			КонецЕсли;
			
			Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
			ПутьКДанным = Сред(ПутьКДанным,  Точка+1);
			
		КонецЦикла;
		
	Иначе
		
		Структура.Вставить(СоответствиеИмен[3], "");
		Структура.Вставить(СоответствиеИмен[4], ПутьКДанным);
		
	КонецЕсли;
	
	Если МетаданныеОбъекта <> Неопределено Тогда
		Структура.Вставить("Метаданные", МетаданныеОбъекта);
	Иначе
		Если Структура.ТипОбъекта = "Документ" Тогда
			Структура.Вставить("Метаданные", Метаданные.Документы[Структура.ВидОбъекта]);
		Иначе
			Структура.Вставить("Метаданные", Метаданные.Справочники[Структура.ВидОбъекта]);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Структура;
	
КонецФункции // РазобратьПутьКОбъектуМетаданных()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА, ПЕРЕМЕННЫХ МОДУЛЯ ПРИЛОЖЕНИЯ

// Функция определяет наличие клиентских подключений к базе других пользователей
Функция ЕстьДругиеПользователиВБазе() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда			
			Возврат Истина;						
		КонецЕсли;		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Функция собирает паспортные данные физ. лица на указанную дату
//
// Параметры: 
//  ФизЛицо.    - физ. лицо, для которго необходимо получить паспортные данные
//  ДатаПериода - дата получения сведений
//
// Возвращаемое значение:
//  Структура с паспортными данными.
//
Функция ПаспортныеДанные(ФизЛицо, ДатаПериода) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ПарФизЛицо",     ФизЛицо);
	Запрос.УстановитьПараметр("ПарДатаПериода", ДатаПериода);

	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ДокументВид        КАК Вид,
	|	ДокументСерия      КАК Серия,
	|	ДокументНомер      КАК Номер,
	|	ДокументДатаВыдачи КАК ДатаВыдачи,
	|	ДокументКемВыдан   КАК Выдан
	|ИЗ
	|	РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ПарДатаПериода, ФизЛицо = &ПарФизЛицо)
	|";

	Шапка = Запрос.Выполнить().Выбрать();
	Шапка.Следующий();

	Результат = Новый Структура("Вид, Серия, Номер, ДатаВыдачи, Выдан");

	Результат.Вид        = Шапка.Вид;
	Результат.Серия      = Шапка.Серия;
	Результат.Номер      = Шапка.Номер;
	Результат.ДатаВыдачи = Шапка.ДатаВыдачи;
	Результат.Выдан      = Шапка.Выдан;

	Возврат Результат;

КонецФункции // ПаспортныеДанные()

// Получает параметр учетной политики (налоговый учет) для заданной организации на заданную дату
//
// Параметры:
//	ИмяПараметра        - строка, имя запрашиваемого параметра учетной политики,
//	Организация         - ссылка на элемент справочника "Организации", для которого надо получить параметры,
//	Дата                - дата, на которую надо получить параметры, если не заполнено, то берется рабочая дата,
//	СтруктураПараметров - структура, содержащая все параметры учетной политики.
//
// Возвращаемое значение:
//	Значение учетной политики
//
Функция ВыгрузитьСтруктуруВСтроку(Структура,ПоЗначениям=Ложь,СтруктураПроверки = Неопределено) Экспорт
	
	НеПроверять = (СтруктураПроверки=Неопределено);
	
	НоваяСтрока = "";
	Для каждого Колонка из Структура Цикл
		Если НеПроверять тогда
			НоваяСтрока = НоваяСтрока + ?(НЕ ЗначениеЗаполнено(Колонка.Значение)или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)+",";
		ИначеЕсли СтруктураПроверки.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение) или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)) тогда
			НоваяСтрока = НоваяСтрока + ?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+",";
		Иначе
			//Нет в проверке!
			возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Если ЗначениеЗаполнено(НоваяСтрока) Тогда
		НоваяСтрока = Лев(НоваяСтрока,СтрДлина(НоваяСтрока)-1);
	КонецЕсли;
	Возврат НоваяСтрока;
КонецФункции

//Процедура для распределения записей из одной таблицы значений по базису (таблица значений или  набору записей)
//Источник 		: ТаблицаЗначений
//Базис 		: ТаблицаЗначений или НаборЗаписей
//Распределение : ключ - поля базиса, значение - поля источника
//Фильтр 		: ключ - поля базиса, значение - поля источника (если не укзан - по совпадающим колонкам)
//Игнорировать  : ключ - поля базиса, значение - поля источника
//Дополнить		: ключ - имя нового поля базиса, значение - значение для заполнения
Функция СформироватьКорректирующиеЗаписи(Источник,Базис,Распределение,Фильтр=неопределено,Игнорировать=Неопределено,Дополнить=Неопределено, НераспределенныеЗаписи_AsIs = ложь) Экспорт
	
	Если ТипЗнч(Базис) = Тип("ТаблицаЗначений") тогда
		Временный_Базис	   = Базис.Скопировать();
	иначе
		Временный_Базис	   = Базис.Выгрузить();
	Конецесли;
	
	КолонкиИсточника = Новый Структура();
	Для Каждого Колонка Из источник.Колонки Цикл
		КолонкиИсточника.Вставить(Колонка.Имя);
	КонецЦикла;
	КолонкиБазиса = Новый Структура();
	Для Каждого Колонка Из Временный_Базис.Колонки Цикл
		Если Не(НЕ ЗначениеЗаполнено(Колонка.Имя)) тогда
			КолонкиБазиса.Вставить(Колонка.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ ЗначениеЗаполнено(Игнорировать) тогда
		 Игнорировать = новый Структура();
	Иначе
		//Зачистим колонки источника и базиса на игнорируемые колонки
		Для Каждого Колонка Из Игнорировать Цикл
			Если КолонкиИсточника.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
				 КолонкиИсточника.Удалить(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
			Конецесли;
			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
				 КолонкиБазиса.Удалить(Колонка.Ключ);
			Конецесли;
		КонецЦикла;
 	КонецЕсли;
	
	//Зачистим колонки источника на распределяемые колонки. Они учитываются отдельно.
	Для Каждого Колонка Из Распределение Цикл
		Если КолонкиИсточника.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
			 КолонкиИсточника.Удалить(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
		Иначе
			 Если Источник.Колонки.Найти(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено тогда
				 //Не хватает колонок к распределению
				 //Но одну и ту же колонку можно распределить дважды
				 Возврат ложь;
			 КонецЕсли;
		Конецесли;
		Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
			 КолонкиБазиса.Удалить(Колонка.Ключ);
		Иначе
			  //Не хватает колонок базиса распределения
			 Возврат ложь;
		Конецесли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(Дополнить) тогда
		//Проверим на отсутствие дополняемых колонок!
		Для Каждого Колонка Из Дополнить Цикл
			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
				//Такая колонка уже есть, нельзя добавить новую
				Возврат Ложь;
			Конецесли;
		КонецЦикла;
 	КонецЕсли;
	
	//Если фильтр не задан - по всем совпадающим колонкам
	Если Фильтр=Неопределено тогда
		Фильтр = Новый Структура();
		Для каждого Колонка из КолонкиБазиса цикл
			Если КолонкиИсточника.Свойство(Колонка.Ключ)  и не(Игнорировать.Свойство(Колонка.Ключ)) тогда
				Фильтр.Вставить(Колонка.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Фильтр) тогда
		//Должно быть хоть одно объединяющее поле!
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого Колонка Из Фильтр Цикл
		Если не КолонкиБазиса.Свойство(Колонка.Ключ) тогда
			  //Не хватает колонок базиса распределения
			 Возврат ложь;
		Конецесли;
	КонецЦикла;
	
	
	//Подготовить сворачивание для источника
	СтрокаСверткиИсточник = ВыгрузитьСтруктуруВСтроку(Фильтр,Истина,КолонкиИсточника);
	Если СтрокаСверткиИсточник = ложь Тогда
		//попытка фильтровать по полю, отсутствующему в источнике!
		Возврат ложь;
	КонецЕсли;
	КолонкиКРаспределениюИсточник = ВыгрузитьСтруктуруВСтроку(Распределение,Истина);
	Если КолонкиКРаспределениюИсточник = ложь Тогда
		//попытка распределить поле, отсутствующее в источнике!
		Возврат ложь;
	КонецЕсли;
	
	//Подготовить сворачивание для базиса
	СтрокаСверткиБазис = ВыгрузитьСтруктуруВСтроку(КолонкиБазиса,Ложь);
	Если СтрокаСверткиБазис = ложь Тогда
		//попытка фильтровать по полю, отсутствующему в базисе!
		Возврат ложь;
	КонецЕсли;
	КолонкиКРаспределениюБазис = ВыгрузитьСтруктуруВСтроку(Распределение,Ложь);
	Если КолонкиКРаспределениюБазис = ложь Тогда
		//попытка распределить поле, отсутствующее в базисе!
		Возврат ложь;
	КонецЕсли;
	
	Временный_Источник = Источник.Скопировать();
	
	Временный_Базис.Свернуть(СтрокаСверткиБазис,КолонкиКРаспределениюБазис);
	Временный_Источник.Свернуть(СтрокаСверткиИсточник,КолонкиКРаспределениюИсточник);
	
	НоваяТаблица = новый ТаблицаЗначений();
	Для каждого Колонка из Временный_Базис.Колонки Цикл
		Если Колонка.ТипЗначения.СодержитТип(Тип("Число")) Тогда
			Разрядность = Колонка.ТипЗначения.КвалификаторыЧисла.Разрядность;
			РазрядностьДробнойЧасти = Колонка.ТипЗначения.КвалификаторыЧисла.РазрядностьДробнойЧасти;
			КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
			
			ТипЗначения = Новый ОписаниеТипов(Колонка.ТипЗначения,,,КвалификаторЧисла);
		Иначе
			ТипЗначения = Колонка.ТипЗначения;
		КонецЕсли;
		
		НоваяТаблица.Колонки.Добавить(Колонка.Имя, ТипЗначения,,10);
	КонецЦикла;
	
	ТаблицаБазисовРаспределения = Новый ТаблицаЗначений();
	Для каждого Колонка из Распределение Цикл
		ТаблицаБазисовРаспределения.Колонки.Добавить(Колонка.Ключ);
	КонецЦикла;
	
	Для каждого СтрокаИсточника из Временный_Источник цикл
		Отбор = новый структура();
		Для каждого Колонка из Фильтр цикл
			Отбор.Вставить(Колонка.Ключ,СтрокаИсточника[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)]);
		КонецЦикла;
		СтрокиБазиса = Временный_Базис.НайтиСтроки(Отбор);
		Временный_Базис_СтрокаНераспределеннойЗаписи = Неопределено;
		Если СтрокиБазиса.Количество() = 0 и НераспределенныеЗаписи_AsIs Тогда
			Временный_Базис_СтрокаНераспределеннойЗаписи = Временный_Базис.Добавить();
			ЗаполнитьЗначенияСвойств(Временный_Базис_СтрокаНераспределеннойЗаписи, СтрокаИсточника);
			СтрокиБазиса.Добавить(Временный_Базис_СтрокаНераспределеннойЗаписи);
		КонецЕсли;		
			
		ТаблицаБазисовРаспределения.Очистить();
		Для каждого Строка из СтрокиБазиса Цикл
			СтрокаТБР = ТаблицаБазисовРаспределения.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаТБР, Строка);
		КонецЦикла;
		Для каждого Колонка из Распределение цикл
			РаспределяемаяСумма =  СтрокаИсточника[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)];
			МассивДляРаспределения = ТаблицаБазисовРаспределения.ВыгрузитьКолонку(Колонка.Ключ);
			РазрядностьДробнойЧасти = Временный_Источник.Колонки[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)].ТипЗначения.КвалификаторыЧисла.РазрядностьДробнойЧасти;
			МассивРезультата = РаспределитьПропорционально(РаспределяемаяСумма, МассивДляРаспределения,?(РазрядностьДробнойЧасти = 0, 3, РазрядностьДробнойЧасти));
			Если МассивРезультата = неопределено тогда
				ТаблицаБазисовРаспределения.ЗаполнитьЗначения(0,Колонка.Ключ);
			иначе
				ТаблицаБазисовРаспределения.ЗагрузитьКолонку(МассивРезультата,Колонка.Ключ);
			КонецЕсли;
		КонецЦикла;
		
		СтрокаРезультата = 0;
		Для каждого Строка из СтрокиБазиса Цикл
			СтрокаНовая = НоваяТаблица.Добавить();
			СрокаРекультатаРаспределения = ТаблицаБазисовРаспределения[СтрокаРезультата];
			СтрокаРезультата = СтрокаРезультата +1;
			Для каждого Колонка из Временный_Базис.Колонки цикл
				Если Распределение.Свойство(Колонка.Имя) тогда
					СтрокаНовая[Колонка.Имя] = СрокаРекультатаРаспределения[Колонка.Имя];
				Иначе
					СтрокаНовая[Колонка.Имя] = Строка[Колонка.Имя];
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
		Если не Временный_Базис_СтрокаНераспределеннойЗаписи = Неопределено Тогда
		    Временный_Базис.удалить(Временный_Базис_СтрокаНераспределеннойЗаписи);
		КонецЕсли; 
	КонецЦикла;
	Если ЗначениеЗаполнено(Дополнить) тогда
		Для каждого Колонка из Дополнить Цикл
			НоваяТаблица.Колонки.Добавить(Колонка.Ключ,,,10);
			НоваяТаблица.ЗаполнитьЗначения(Колонка.Значение,Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;
	СтрокиС0Распределением = Новый Массив();
	Для каждого Строка из НоваяТаблица цикл
		СуммаРаспределений0=Истина;
		Для каждого Колонка из распределение цикл
			Если ЗначениеЗаполнено(Строка[Колонка.Ключ]) тогда
				СуммаРаспределений0=Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если СуммаРаспределений0 тогда
			СтрокиС0Распределением.Добавить(Строка);
		Конецесли;
	КонецЦикла;
	Для каждого ПустаяСтрока из СтрокиС0Распределением Цикл 
		НоваяТаблица.Удалить(ПустаяСтрока);
	КонецЦикла;
	//Если ЗначениеЗаполнено(ИсключитьПослеРаспределения) тогда
	//	КолонкиРезультата = Новый Структура();
	//	Для каждого Колонка из НоваяТаблица.Колонки Цикл
	//		Если ИсключитьПослеРаспределения.Свойство(Колонка.Имя) = Истина  или Распределение.Свойство(Колонка.Имя) = Истина Тогда
	//			Продолжить;
	//		Иначе
	//			КолонкиРезультата.Вставить(Колонка.Имя);
	//		КонецЕсли;
	//	КонецЦикла;
	//	КолонкиКСворачиванию = ВыгрузитьСтруктуруВСтроку(КолонкиРезультата,Ложь);
	//	НоваяТаблица.Свернуть(КолонкиКСворачиванию,КолонкиКРаспределениюБазис);
	//КонецЕсли;
	
	Возврат НоваяТаблица;
КонецФункции

Функция ВыгрузитьСтрокиДереваВТаблицуЗначений(Источник,КоллекцияКолонокДереваЗначений) Экспорт

	Реквизиты = Новый Структура();
	Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
		Реквизиты.Вставить(Колонка.Имя);
	КонецЦикла;
	
	НоваяТЗ= Новый ТаблицаЗначений();
	
	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл
		Строка = НоваяТЗ.Добавить();
	КонецЦикла;
	
	Для каждого ТекРеквизит из Реквизиты Цикл
		ИскомыйРеквизит = ТекРеквизит.Ключ;
		НовыйРеквизит 	= ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);
		ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);
		НоваяТЗ.Колонки.Добавить(НовыйРеквизит, ИсточникКолонка.ТипЗначения);
		НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);
	КонецЦикла;
	
    Возврат НоваяТЗ;
КонецФункции // СформироватьТаблицуОплаты()

// Возвращает строку, описывающую период, определяемый переданными
// датой и периодичностью.
//
// Параметры
//  ДатаВПериоде:Дата - дата из периода
//  Периодичность: Строка - строка, определяющая периодичность
//
// Возвращаемое значение:
//   СтрокаПериод: строка   – представление периода для вывода в отчетах
//
Функция ПолучитьПериодСтрокой(ДатаВПериоде, Периодичность) Экспорт
	
	Если Периодичность = "Год" Тогда
		ФорматДаты = "ДФ='гггг ""г.""'";
		
	ИначеЕсли Периодичность = "Квартал" Тогда
		ФорматДаты = "ДФ='к"" квартал"" гггг ""г.""'";
		
	ИначеЕсли Периодичность = "Месяц" Тогда
		ФорматДаты = "ДФ='ММММ гггг ""г.""'";
		
	ИначеЕсли Периодичность = "Неделя" Тогда
		ФорматДаты = "ДФ='""Неделя (""дд.ММ.гггг'";
		
	ИначеЕсли Периодичность = "День" Тогда
		ФорматДаты = "ДФ='дд.ММ.гггг ""г.""'";
		
	Иначе
		ФорматДаты = "";
		
	КонецЕсли;
	
	СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты);
	Если Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата") Тогда
		СтрокаПериод = "" + НеделяГода(ДатаВПериоде) + "-ая " + СтрокаПериод + Формат(КонецНедели(ДатаВПериоде), "ДФ='"" - ""дд.ММ.гггг)'");
	КонецЕсли;
	
	Возврат СтрокаПериод;
	
КонецФункции // ПолучитьПериодСтрокой()

// Процедура предназначена для получения момента определения остатков для заполнения документа.
//
// Параметры:
//  ДокОбъект - (ДокументОбъект), документ, для которого надо определить лату получения остатков.
//
// Возвращаемое значение.
//  Дата (момент времени) - дата остатков
//
Функция ПолучитьДатуОстатков(ДокОбъект) Экспорт
	
	ДатаОстатков = '00010101';
	Если НачалоДня(ДокОбъект.Дата) <> НачалоДня(ТекущаяДата()) 
	   И ДокОбъект.Дата <> '00010101' Тогда
	   
		Если НЕ ЗначениеЗаполнено(ДокОбъект.Ссылка) Тогда
			ДатаОстатков = КонецДня(ДокОбъект.Дата);
		Иначе
			ДатаОстатков = ДокОбъект.МоментВремени();
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ДатаОстатков;
	
КонецФункции

// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт

	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(ПустаяСтрока(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(ПустаяСтрока(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если Валюта <> Неопределено Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;

	Возврат РезультирующаяСтрока;

КонецФункции // ФорматСумм()

// Удаляет повторяющиеся значения из массива
//
// Параметры:
//	Массив
//
Процедура УдалитьПовторяющиесяЭлементы(Массив) Экспорт
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда
		
		// Удалим повторы
		Инд=0;
		КолВо = Массив.Количество();
		
		Пока Инд<КолВо Цикл
			
			Инд2 = Инд+1;
			Пока Инд2<КолВо Цикл
				
				Если Массив[Инд2] = Массив[Инд] Тогда
					Массив.Удалить(Инд2);
					КолВо = КолВо-1;
				Иначе
					Инд2 = Инд2+1;
				КонецЕсли;
				
			КонецЦикла; 
			
			//Установим для не заполненных значений тип "Неопределено"
			Если НЕ ЗначениеЗаполнено(Массив[Инд]) Тогда
				Массив[Инд] = Неопределено;
			КонецЕсли;

			Инд = Инд+1;
			
		КонецЦикла; 
		
	КонецЕсли;
	
КонецПроцедуры

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//		ИсхСумма - распределяемая сумма
//		МассивКоэф - массив коэффициентов распределения
//		Точность - точность округления при распределении. Необязателен.
//
//	Возврат:
//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина) Экспорт

	Если МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;

	// Массив коэффициентов необходимо упорядочить, поэтому создадим таблицу для распределения
    УпорядоченнаяТаблица = Новый ТаблицаЗначений;
	УпорядоченнаяТаблица.Колонки.Добавить("Коэф", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(17,4)));
	УпорядоченнаяТаблица.Колонки.Добавить("ИсходныйИндекс", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,0)));
	
	СуммаКоэф  = 0;

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		СуммаКоэф = СуммаКоэф + МассивКоэф[К];
		
		СтрокаТаблицы = УпорядоченнаяТаблица.Добавить();
		СтрокаТаблицы.Коэф = МассивКоэф[К];
		СтрокаТаблицы.ИсходныйИндекс = К;
	КонецЦикла;
	
	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	УпорядоченнаяТаблица.Сортировать("Коэф Убыв");
	
	МассивСумм = Новый Массив(УпорядоченнаяТаблица.Количество());
	
	Для каждого СтрокаТаблицы Из УпорядоченнаяТаблица Цикл
		// Возвращаемый результат должен быть в том же порядке
		МассивСумм[СтрокаТаблицы.ИсходныйИндекс] = ?(СуммаКоэф <> 0, Окр(ИсхСумма * МассивКоэф[СтрокаТаблицы.ИсходныйИндекс] / СуммаКоэф, Точность, 1), 0);
		
		ИсхСумма = ИсхСумма - МассивСумм[СтрокаТаблицы.ИсходныйИндекс]; 
		СуммаКоэф = СуммаКоэф - МассивКоэф[СтрокаТаблицы.ИсходныйИндекс]; 
	КонецЦикла;

	Возврат МассивСумм;

КонецФункции // РаспределитьПропорционально()

// Процедура копирует значения одной строки таблицы значеницй в другую
// структура колонок должна совпадать
//
// Параметры:
//		СтрокаПриемник - строка в которую копируем
//		СтрокаИсточник - строка из которой копируем
//      ИменаКол - имена колонок, разделенные запятыми, которые надо скопировать
//                 необязателен. По умолчанию - все колонки
//
Процедура КопироватьСтрокуТаблицыЗначений(СтрокаПриемник, СтрокаИсточник, ИменаКол) Экспорт

	Если ТипЗнч( ИменаКол) = Тип("ТаблицаЗначений") Тогда
		СписокСвойств = "";
		Для Каждого Кол Из ИменаКол.Колонки Цикл
			Если Не Кол.Имя = "НомерСтроки" Тогда
				Если Не ПустаяСтрока(СписокСвойств) Тогда
					СписокСвойств = СписокСвойств + ",";	
				КонецЕсли;
				СписокСвойств = СписокСвойств + Кол.Имя;
			КонецЕсли;
		КонецЦикла;
		ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, СписокСвойств,);
	Иначе // Строка с именами колонок
        ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, ИменаКол,);
	КонецЕсли;

КонецПроцедуры // КопироватьСтрокуТаблицыЗначений()

#Если Клиент Тогда

// Процедура возвращает паспортные данные физлица в виде строки
//
// Параметры: 
//  ФизЛицо - ссылка на элемент справочника "Физические лица",по которму необходимо
//            получить паспортные данные.
//
// Возвращаемое значение:
//  Строка с данными об удостоверении личности физичского лица
//
Функция ПолучитьПаспортныеДанныеСтрокой(ФизЛицо) Экспорт

	СтруктураПаспортныхДанных	= РегистрыСведений.ПаспортныеДанныеФизЛиц.ПолучитьПоследнее(РабочаяДата, Новый Структура("ФизЛицо",ФизЛицо));
	ВидДокумента				= СтруктураПаспортныхДанных.ДокументВид;
	Серия						= СтруктураПаспортныхДанных.ДокументСерия;
	Номер						= СтруктураПаспортныхДанных.ДокументНомер;
	ДатаВыдачи					= СтруктураПаспортныхДанных.ДокументДатаВыдачи;
	КемВыдан					= СтруктураПаспортныхДанных.ДокументКемВыдан;
	НомерПодразделения			= СтруктураПаспортныхДанных.ДокументКодПодразделения;

	Если НЕ (НЕ ЗначениеЗаполнено(ДатаВыдачи)
		   И НЕ ЗначениеЗаполнено(ВидДокумента)
		   И НЕ ЗначениеЗаполнено(Серия + Номер + КемВыдан + НомерПодразделения)) Тогда

		Возврат ?(ВидДокумента.Пустая(),"","" + ВидДокумента + ", ") 
				+ "Серия: " + Серия + ", № " + Номер 
				+ ", Выдан: " + Формат(ДатаВыдачи,"ДФ='дд ММММ гггг'") + " года, " 
				+ КемВыдан + "; № подр. " + НомерПодразделения;

	Иначе
		Возврат "Отсутствуют данные об удостоверении личности."
	КонецЕсли;

КонецФункции // ПолучитьПаспортныеДанныеСтрокой()

#КонецЕсли

// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечать(Документ, МассивПрефиксов = Неопределено) Экспорт

	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;

	Номер   = СокрЛП(Документ.Номер);
	Префикс = "";
	Если МассивПрефиксов = Неопределено Тогда
		
		Организация = Неопределено;
		
		Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса")
			ИЛИ ТипЗнч(Документ) = Тип("Структура") Тогда

			Организация = Документ.Организация;
			
		Иначе

			МетаданныеДокумента = Документ.Метаданные();

			Если МетаданныеДокумента.Реквизиты.Найти("Организация") <> Неопределено Тогда

				Организация = Документ.Организация;

			КонецЕсли;

		КонецЕсли;
		
		МассивПрефиксовДляОбхода = СформироватьМассивПрефиксовДляРИБИОрганизации(Организация)
		
	Иначе
		
		МассивПрефиксовДляОбхода = МассивПрефиксов;
		
	КонецЕсли;
	
	Для Каждого ТекущийПрефикс ИЗ МассивПрефиксовДляОбхода Цикл
		
		// удаление префикса из номера документа
		Если Найти(Номер, ТекущийПрефикс)=1 Тогда 
			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
		КонецЕсли;
		
		// так же, может остаться "минус" впереди
		Если Лев(Номер, 1) = "-" Тогда
			Номер = Сред(Номер, 2);
		КонецЕсли;
		
		// удаление ведущих нулей
		Пока Лев(Номер, 1)="0" Цикл
			Номер = Сред(Номер, 2);
		КонецЦикла;
	КонецЦикла;

	Возврат Номер;

КонецФункции // ПолучитьНомерНаПечать()

// Заменяет одни термины, которые используются в коде, другими - уместными в интерфейсе.
// Позволяет иметь один тот же код при разных названиях объектов.
//
// Параметры
//  СтрокаИзИнтерфейса - строка - заголовок колонки, надпись и т.п.
//
// Возвращаемое значение:
//  Строка - новый заголовок колонки, надпись и т.п. 
//
Функция ПреобразоватьСтрокуИнтерфейса(СтрокаИзИнтерфейса) Экспорт 

	Возврат СтрокаИзИнтерфейса

КонецФункции // ПреобразоватьСтрокуИнтерфейса()

// Возвращает головную организацию для заданной организации
// Если для организации реквизит ГоловнаяОрганизация не заполнен 
// это значит, что сама организация является голвной
//
// Параметры
//  Организация – СправочникСсылка.Организации
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   СправочникСсылка.Организации
//
Функция ГоловнаяОрганизация(Организация) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Организация",Организация);
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.ГоловнаяОрганизация
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";
	Выборка = Запрос.Выполнить().Выбрать();
	Если Не Выборка.Следующий() Тогда
		Возврат Справочники.Организации.ПустаяСсылка()
	КонецЕсли;
	Если Организация.Пустая() или Выборка.ГоловнаяОрганизация.Пустая() Тогда
		Возврат Организация;
	Иначе
		Возврат Выборка.ГоловнаяОрганизация;
	КонецЕсли;
КонецФункции // ГоловнаяОрганизация()

Функция ЭтоЮрЛицо(Организация) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Организация",Организация);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Организации.ЮрФизЛицо
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";
	Выборка = Запрос.Выполнить().Выбрать();
	Возврат Не Выборка.Следующий() Или Выборка.ЮрФизЛицо <> Перечисления.ЮрФизЛицо.ФизЛицо;
	
КонецФункции // ЭтоЮрЛицо()

Функция ЭтоДоступнаяОрганизация(Организация) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Организация",Организация);
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.ПометкаУдаления
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";
	
	Возврат Не Запрос.Выполнить().Пустой() // если удалось прочитать закрытое поле - организация доступна
	
КонецФункции // ЭтоДоступнаяОрганизация()


///////////////////////////////////////////////////////////////////////////////
// РАБОТА С ПЕРЕЧИСЛЕНИЕМ "ПЕРИОДИЧНОСТЬ"
// Функции не обрабатывают значения "Декада" и "Полугодие"

// Функция возвращает ближайшую дату начала периода планирования
//
// Параметры
//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//
// Возвращаемое значение:
//	ДатаНачалаПериода		– ближайшая дата начала периода планирования
//
Функция ДатаНачалаПериода(ДатаВПериоде,Периодичность) Экспорт
	
	Если НЕ ТипЗнч(ДатаВПериоде)=Тип("Дата") Тогда
		Возврат '00010101';
	КонецЕсли;
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат НачалоДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат НачалоНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат НачалоМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат НачалоКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат НачалоГода (ДатаВПериоде);
	Иначе
		Возврат НачалоДня(ДатаВПериоде);
	КонецЕсли;
		
КонецФункции // ДатаНачалаПериода()

// Функция возвращает ближайшую дату окончания периода планирования
//
// Параметры
//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//
// Возвращаемое значение:
//	ДатаКонцаПериода	– ближайшая дата окончания периода планирования
//
Функция ДатаКонцаПериода(ДатаВПериоде,Периодичность) Экспорт
							
	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат КонецДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат КонецНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат КонецМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат КонецКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат КонецГода (ДатаВПериоде);
	Иначе
		Возврат КонецДня(ДатаВПериоде);
	КонецЕсли;
		
КонецФункции // ДатаКонцаПериода()

// Функция добавляет интервал к дате
//
// Параметры:
//	Периодичность (Перечисления.Периодичность)	- пнриодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//	Смещение (число)							- определяет направление и количество периодов, в котором сдвигается дата
//
// Возвращаемое значение:
//	Дата, отстоящая от исходной на заданное количество периодов 
//
Функция ДобавитьИнтервал(ДатаПериода,Периодичность,Смещение) Экспорт

	Если Смещение = 0 Тогда
		НоваяДатаПериода = ДатаПериода;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		НоваяДатаПериода = НачалоДня(ДатаПериода + Смещение*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		НоваяДатаПериода = ДатаПериода + Смещение*7*24*3600;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*3);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Год Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*12);
		
	Иначе
		НоваяДатаПериода=НачалоДня(ДатаПериода) + Смещение*24*3600;
		
	КонецЕсли;

	Возврат НоваяДатаПериода;

КонецФункции // ДобавитьИнтервал()

// Возвращает число дней в переданном периоде
//
// Параметры
//  Периодичность – Перечисление.Периодичность элемент перечисления, 
//		для которого вычисляется количество дней
//
// Возвращаемое значение:
//   ЧислоДнейВПериоде (число)  – число дней в переданном периоде
//
Функция ЧислоДнейВПериоде(Периодичность) Экспорт
		
	Если Периодичность=Перечисления.Периодичность.День Тогда
		ЧислоДнейВПериоде=1;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		ЧислоДнейВПериоде=7;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		ЧислоДнейВПериоде=30;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		ЧислоДнейВПериоде=90;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		ЧислоДнейВПериоде=365;
	Иначе
		ЧислоДнейВПериоде=0;
	КонецЕсли;
	
	Возврат ЧислоДнейВПериоде;	

КонецФункции // ЧислоДнейВПериоде()

///////////////////////////////////////////////////////////////////////////////

Функция ВопросПерезаполнитьКУДиР() Экспорт
	
	Ответ = Ложь;
	
	#Если Клиент Тогда
		ТекстВопроса = 
		"Отражение платежа в Книге учета доходов и расходов настроено вручную.
		|Перезаполнить показатели Книги учета доходов и расходов?";
		
		Ответ = (Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Да) = КодВозвратаДиалога.Да);
	#КонецЕсли
	
	Возврат Ответ;
	
КонецФункции

// Формирует список обособленных структурных подразделений организации
Функция ПолучитьСписокОбособленныхПодразделенийОрганизации(Организация) Экспорт

	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.Ссылка,
	|	Организации.Наименование
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.ГоловнаяОрганизация = &Организация");

	Запрос.УстановитьПараметр("Организация", Организация);

	СписокОрганизаций = Новый СписокЗначений;
	
	Выборка = Запрос.Выполнить().Выбрать(); 

	Пока Выборка.Следующий() Цикл
		СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;

	Возврат СписокОрганизаций;
КонецФункции // ПолучитьСписокОбособленныхПодразделенийОрганизации()

//Удалает повторяющиеся элементы массива.
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь, УдалитьПустыеЭлементыСсылочногоТипа = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМасссиве = Новый Соответствие; 
		БылоНеопределено = Ложь;
		
		КолвоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента = ТипЗнч(ЭлементМассива); 
			Если ЭлементМассива = Неопределено Тогда
				Если БылоНеопределено или НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				Продолжить;
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
				
				Если УдалитьПустыеЭлементыСсылочногоТипа
					И НЕ ЗначениеЗаполнено(ЭлементМассива)
					Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
					Продолжить;
				КонецЕсли;
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМасссиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМасссиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Получает первичную информацию об ошибке
// Параметры:
//	ИнформацияОбОшибке - информация об ошибке
// Возвращает:
//	Информацию об ошибке, которая является первопричиной возникновения переданной ИнформацияОбОшибке
//  Если ошибка первичная, то возвращается сама ошибка, переданная в качестве параметра
Функция ПолучитьПричинуОшибки(ИнформацияОбОшибке) Экспорт
	ПричинаОшибки = ИнформацияОбОшибке.Причина;
	Если ПричинаОшибки = НеОпределено Тогда
		Возврат ИнформацияОбОшибке;
	КонецЕсли;
	Пока ПричинаОшибки.Причина <> НеОпределено Цикл
		ПричинаОшибки = ПричинаОшибки.Причина;
	КонецЦикла;
	Возврат ПричинаОшибки;
	
КонецФункции

// Считываем последнее состояние регистра сведений о физлице и заполняем переданный набор записей
//
// Параметры
//  Физлицо - 
//  НаборЗаписей  - 
//
Процедура ПолучитьСвязанныеДанныеФизлица(Физлицо, НаборЗаписей) Экспорт

	НаборЗаписей.Очистить();
	
	Если Физлицо.Пустая() Тогда
		Возврат;
	КонецЕсли;	
	
	ИмяТаблицы = НаборЗаписей.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ПарамФизЛицо",Физлицо);
	Запрос.УстановитьПараметр("парамДатаСреза", ОбщегоНазначения.ПолучитьРабочуюДату());
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	СвязанныеДанные.*
	|ИЗ
	|	РегистрСведений." + ИмяТаблицы + ".СрезПоследних(&парамДатаСреза, ФизЛицо = &ПарамФизЛицо) КАК СвязанныеДанные";
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(НаборЗаписей.Добавить(), Выборка);
	КонецЕсли;
	
КонецПроцедуры // ПолучитьСвязанныеДанныеФизлица()

// Возвращает выборку со значениями реквизитов переданной ссылки
//
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	" + ИменаРеквизитов + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура(ИменаРеквизитов);
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Получить значение одного реквизита по ссылке.
// Например, для элемента справочника нужно получить наименование,
// в этом случае в качестве ИмяРеквизита нужно передать "Наименование".
//
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ПолучитьЗначенияРеквизитов(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура.
//              Если в качестве объекта передана пустая ссылка, то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		Реквизиты = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Реквизиты, ",", Истина);
	КонецЕсли;
	
	СтруктураРеквизитов = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура") Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		СтруктураРеквизитов = Реквизиты;
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Для Каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(СтрЗаменить(Реквизит, ".", ""), Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"),
			Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции 

// Возвращает значения реквизитов, прочитанные из информационной базы
// для нескольких объектов.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИменаРеквизитов - Строка, имена реквизитов перечисленные через запятую,
//				в формате требований к свойствам структуры.
//				Например, "Код, Наименование, Родитель".
// 
// Возвращаемое значение:
//  Соответствие - где ключ - ссылка на объект, а Значение - структура, которая 
//		   		содержит список свойств, как список имен в строке
//				ИменаРеквизитов, со значениям реквизитов, прочитанными из информационной базы.
// 
Функция ЗначенияРеквизитовОбъектов(МассивСсылок, ИменаРеквизитов) Экспорт
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если МассивСсылок.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Ссылка КАК Ссылка, " + ИменаРеквизитов + "
		|ИЗ
		|	" + МассивСсылок[0].Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&МассивСсылок)";
	Запрос.УстановитьПараметр("МассивСсылок", МассивСсылок);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(ИменаРеквизитов);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

//+++АК SHEP 2018.04.06 общая функция
// рекомендуется использовать для получения реквизита объекта на клиенте для объектов, не имеющих метаданных, но значения которых недоступны на клиенте
// например, РегистрСведенийКлючЗаписи
Функция ЗначениеРеквизита(Объект, ИмяРекъ) Экспорт
	Возврат Объект[ИмяРекъ];
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Соответствие - Ключ - ссылка на объект, Значение - значение прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита) Экспорт
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита);
	Для Каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;
		
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Выполнить экспортную процедуру по имени.
//
// Параметры
//  ИмяЭкспортнойПроцедуры – Строка – имя экспортной процедуры в формате 
//                                    <имя объекта>.<имя процедуры>, где <имя объекта> - это
//                                    общий модуль или модуль менеджера объекта.
// Параметры               - Массив - параметры передаются в процедуру <ИмяЭкспортнойПроцедуры>
//                                    в порядке расположения элементов массива.
// ОбластьДанных           - Число  - задает область данных, в которой необходимо выполнить процедуру.
// 
// Пример:
//  ВыполнитьБезопасно("МойОбщийМодуль.МояПроцедура");
//
Процедура ВыполнитьБезопасно(ИмяЭкспортнойПроцедуры, Параметры = Неопределено, ОбластьДанных = Неопределено) Экспорт
	
	// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.       
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецЕсли;

	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецЕсли;
		
	Если ЧастиИмени.Количество() = 3 Тогда
		ДопустимыеИменаТипов = Новый Массив;
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаКонстанты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыСведений()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыНакопления()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыБухгалтерии()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыРасчета()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаСправочники()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаДокументы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаОтчеты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаОбработки()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаБизнесПроцессы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЖурналыДокументов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЗадачи()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыСчетов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыОбмена()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовХарактеристик()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовРасчета()));
		ИмяТипа = ВРег(ЧастиИмени[0]);
		Если ДопустимыеИменаТипов.Найти(ИмяТипа) = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
		КонецЕсли;
	КонецЕсли;
	
	ИмяМетода = ЧастиИмени[ЧастиИмени.ВГраница()];
	ВременнаяСтруктура = Новый Структура;
	Попытка
		// Проверка на то, что ИмяМетода является допустимым идентификатором.
		// Например: МояПроцедура
		ВременнаяСтруктура.Вставить(ИмяМетода);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Безопасное выполнение метода'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
	КонецПопытки;
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + Индекс + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	Выполнить ИмяЭкспортнойПроцедуры + "(" + ПараметрыСтрока + ")";
	
КонецПроцедуры

// Выполнить экспортную процедуру по имени с уровнем привилегий конфигурации.
// При включении профилей безопасности для вызова оператора Выполнить() используется
// переход в безопасный режим с профилем безопасности, используемом для информационной базы
// (если выше по стеку не был установлен другой безопасный режим).
//
// Параметры:
//  ИмяМетода  - Строка - имя экспортной процедуры в формате
//                       <имя объекта>.<имя процедуры>, где <имя объекта> - это
//                       общий модуль или модуль менеджера объекта.
//  Параметры  - Массив - параметры передаются в процедуру <ИмяЭкспортнойПроцедуры>
//                        в порядке расположения элементов массива.
// 
// Пример:
//  Параметры = Новый Массив();
//  Параметры.Добавить("1");
//  ОбщегоНазначения.ВыполнитьМетодКонфигурации("МойОбщийМодуль.МояПроцедура", Параметры);
//
Процедура ВыполнитьМетодКонфигурации(Знач ИмяМетода, Знач Параметры = Неопределено) Экспорт
	
	ПроверитьИмяПроцедурыКонфигурации(ИмяМетода);
	
	//Если ПодсистемаСуществует("СтандартныеПодсистемы.ПрофилиБезопасности") Тогда
	//	МодульРаботаВБезопасномРежиме = ОбщийМодуль("РаботаВБезопасномРежиме");
	//	Если МодульРаботаВБезопасномРежиме.ИспользуютсяПрофилиБезопасности()
	//		И Не МодульРаботаВБезопасномРежиме.УстановленБезопасныйРежим() Тогда
	//		
	//		ПрофильИнформационнойБазы = МодульРаботаВБезопасномРежиме.ПрофильБезопасностиИнформационнойБазы();
	//		Если ЗначениеЗаполнено(ПрофильИнформационнойБазы) Тогда
	//			
	//			УстановитьБезопасныйРежим(ПрофильИнформационнойБазы);
	//			Если БезопасныйРежим() = Истина Тогда
	//				УстановитьБезопасныйРежим(Ложь);
	//			КонецЕсли;
	//			
	//		КонецЕсли;
	//		
	//	КонецЕсли;
	//КонецЕсли;
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + Индекс + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	Выполнить ИмяМетода + "(" + ПараметрыСтрока + ")";
	
КонецПроцедуры

// Выполнить экспортную процедуру объекта встроенного языка по имени.
// При включении профилей безопасности для вызова оператора Выполнить() используется
// переход в безопасный режим с профилем безопасности, используемом для информационной базы
// (если выше по стеку не был установлен другой безопасный режим).
//
// Параметры:
//  Объект    - Произвольный - объект встроенного языка 1С:Предприятия, содержащий методы (например, ОбработкаОбъект).
//  ИмяМетода - Строка       - имя экспортной процедуры модуля объекта обработки.
//  Параметры - Массив       - параметры передаются в процедуру <ИмяПроцедуры>
//                             в порядке расположения элементов массива.
//
Процедура ВыполнитьМетодОбъекта(Знач Объект, Знач ИмяМетода, Знач Параметры = Неопределено) Экспорт
	
	// Проверка имени метода на корректность.
	Попытка
		Тест = Новый Структура(ИмяМетода, ИмяМетода);
	Исключение
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Некорректное значение параметра ИмяМетода (%1) в ОбщегоНазначения.ВыполнитьМетодОбъекта'"), ИмяМетода);
	КонецПопытки;
	
	//Если ПодсистемаСуществует("СтандартныеПодсистемы.ПрофилиБезопасности") Тогда
	//	МодульРаботаВБезопасномРежиме = ОбщийМодуль("РаботаВБезопасномРежиме");
	//	Если МодульРаботаВБезопасномРежиме.ИспользуютсяПрофилиБезопасности()
	//		И Не МодульРаботаВБезопасномРежиме.УстановленБезопасныйРежим() Тогда
	//		
	//		МодульРаботаВБезопасномРежиме = ОбщийМодуль("РаботаВБезопасномРежиме");
	//		ПрофильИнформационнойБазы = МодульРаботаВБезопасномРежиме.ПрофильБезопасностиИнформационнойБазы();
	//		
	//		Если ЗначениеЗаполнено(ПрофильИнформационнойБазы) Тогда
	//			
	//			УстановитьБезопасныйРежим(ПрофильИнформационнойБазы);
	//			Если БезопасныйРежим() = Истина Тогда
	//				УстановитьБезопасныйРежим(Ложь);
	//			КонецЕсли;
	//			
	//		КонецЕсли;
	//		
	//	КонецЕсли;
	//КонецЕсли;
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + Индекс + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	Выполнить "Объект." + ИмяМетода + "(" + ПараметрыСтрока + ")";
	
КонецПроцедуры

// Выполняет произвольный алгоритм на встроенном языке 1С:Предприятия, предварительно устанавливая
// безопасный режим выполнения кода и безопасный режим разделения данных для всех разделителей,
// присутствующих в составе конфигурации.
//
// Параметры:
//  Алгоритм  - Строка - алгоритм на встроенном языке 1С:Предприятия.
//  Параметры - Произвольный -  контекст, который требуется для выполнения алгоритмы.
//    В тексте алгоритма обращение к контексту должно происходить по имени "Параметры".
//    Например, выражение "Параметры.Значение1 = Параметры.Значение2" обращается к значениям
//    "Значение1" и "Значение2" переданные в Параметры, как свойства.
//
// Пример:
//
//  Параметры = Новый Структура;
//  Параметры.Вставить("Значение1", 1);
//  Параметры.Вставить("Значение2", 10);
//  ОбщегоНазначения.ВыполнитьВБезопасномРежиме("Параметры.Значение1 = Параметры.Значение2", Параметры);
//
Процедура ВыполнитьВБезопасномРежиме(Знач Алгоритм, Знач Параметры = Неопределено) Экспорт
	
	УстановитьБезопасныйРежим(Истина);
	
	//Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
	//	МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
	//	МассивРазделителей = МодульРаботаВМоделиСервиса.РазделителиКонфигурации();
	//Иначе
	//	МассивРазделителей = Новый Массив;
	//КонецЕсли;
	//
	//Для Каждого ИмяРазделителя Из МассивРазделителей Цикл
	//	
	//	УстановитьБезопасныйРежимРазделенияДанных(ИмяРазделителя, Истина);
	//	
	//КонецЦикла;
	
	Выполнить Алгоритм;
	
КонецПроцедуры

// Вычисляет переданное выражение, предварительно устанавливая безопасный режим выполнения кода
// и безопасный режим разделения данных для всех разделителей, присутствующих в составе конфигурации.
//
// Параметры:
//  Выражение - Строка - выражение на встроенном языке 1С:Предприятия.
//  Параметры - Произвольный - контекст, который требуется для вычисления выражения.
//    В тексте выражения обращение к контексту должно происходить по имени "Параметры".
//    Например, выражение "Параметры.Значение1 = Параметры.Значение2" обращается к значениям
//    "Значение1" и "Значение2" переданные в Параметры, как свойства.
//
// Возвращаемое значение:
//   Произвольный - результат вычисления выражения.
//
// Пример:
//
//  // Пример 1
//  Параметры = Новый Структура;
//  Параметры.Вставить("Значение1", 1);
//  Параметры.Вставить("Значение2", 10);
//  Результат = ОбщегоНазначения.ВычислитьВБезопасномРежиме("Параметры.Значение1 = Параметры.Значение2", Параметры);
//
//  // Пример 2
//  Результат = ОбщегоНазначения.ВычислитьВБезопасномРежиме("СтандартныеПодсистемыСервер.ВерсияБиблиотеки()");
//
Функция ВычислитьВБезопасномРежиме(Знач Выражение, Знач Параметры = Неопределено) Экспорт
	
	УстановитьБезопасныйРежим(Истина);
	
	//Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
	//	МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
	//	МассивРазделителей = МодульРаботаВМоделиСервиса.РазделителиКонфигурации();
	//Иначе
	//	МассивРазделителей = Новый Массив;
	//КонецЕсли;
	//
	//Для Каждого ИмяРазделителя Из МассивРазделителей Цикл
	//	
	//	УстановитьБезопасныйРежимРазделенияДанных(ИмяРазделителя, Истина);
	//	
	//КонецЦикла;
	
	Возврат Вычислить(Выражение);
	
КонецФункции

// Проверяет, что переданное имя ИмяПроцедуры является именем экспортной процедуры конфигурации.
// Может использоваться для проверки, что переданная строка не содержит произвольного алгоритма
// на встроенном языке 1С:Предприятия перед использованием его в операторах Выполнить и Вычислить
// при их использовании для динамического вызова методов код конфигурации.
//
// В случае если переданная строка не является именем процедуры конфигурации, генерируется исключение.
//
// Предназначена для вызова из см. процедуру ВыполнитьМетодКонфигурации.
//
// Параметры:
//   ИмяПроцедуры - Строка - проверяемое имя экспортной процедуры.
//
Процедура ПроверитьИмяПроцедурыКонфигурации(Знач ИмяПроцедуры)
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра ИмяПроцедуры (передано значение: ""%1"") в ОбщегоНазначения.ВыполнитьМетодКонфигурации'"), ИмяПроцедуры);
	КонецЕсли;
	
	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра ИмяПроцедуры (передано значение: ""%1"") в ОбщегоНазначения.ВыполнитьМетодКонфигурации:
				|Не найден общий модуль ""%2"".'"),
			ИмяПроцедуры,
			ИмяОбъекта);
	КонецЕсли;
	
	Если ЧастиИмени.Количество() = 3 Тогда
		ПолноеИмяОбъекта = ЧастиИмени[0] + "." + ЧастиИмени[1];
		Попытка
			Менеджер = МенеджерОбъектаПоИмени(ПолноеИмяОбъекта);
		Исключение
			Менеджер = Неопределено;
		КонецПопытки;
		Если Менеджер = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неправильный формат параметра ИмяПроцедуры (передано значение: ""%1"") в ОбщегоНазначения.ВыполнитьМетодКонфигурации:
				           |Не найден менеджер объекта ""%2"".'"),
				ИмяПроцедуры,
				ПолноеИмяОбъекта);
		КонецЕсли;
	КонецЕсли;
	
	ИмяМетодаОбъекта = ЧастиИмени[ЧастиИмени.ВГраница()];
	ВременнаяСтруктура = Новый Структура;
	Попытка
		// Проверка того, что ИмяПроцедуры является допустимым идентификатором.
		// Например: МояПроцедура.
		ВременнаяСтруктура.Вставить(ИмяМетодаОбъекта);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Безопасное выполнение метода'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра ИмяПроцедуры (передано значение: ""%1"") в ОбщегоНазначения.ВыполнитьМетодКонфигурации:
			           |Имя метода ""%2"" не соответствует требованиям образования имен процедур и функций.'"),
			ИмяПроцедуры, ИмяМетодаОбъекта);
	КонецПопытки;
	
КонецПроцедуры

// Возвращает менеджер объекта по имени.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Имя - Строка - имя например, "Справочник", "Справочники", "Справочник.Организации".
//
// Возвращаемое значение:
//  СправочникиМенеджер, СправочникМенеджер, ДокументыМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоИмени(Имя)
	Перем КлассОМ, ИмяОМ, Менеджер;
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Имя, ".");
	
	Если ЧастиИмени.Количество() > 0 Тогда
		КлассОМ = ВРег(ЧастиИмени[0]);
	КонецЕсли;
	
	Если ЧастиИмени.Количество() > 1 Тогда
		ИмяОМ = ЧастиИмени[1];
	КонецЕсли;
	
	Если      КлассОМ = "ПЛАНОБМЕНА"
	 Или      КлассОМ = "ПЛАНЫОБМЕНА" Тогда
		Менеджер = ПланыОбмена;
		
	ИначеЕсли КлассОМ = "СПРАВОЧНИК"
	      Или КлассОМ = "СПРАВОЧНИКИ" Тогда
		Менеджер = Справочники;
		
	ИначеЕсли КлассОМ = "ДОКУМЕНТ"
	      Или КлассОМ = "ДОКУМЕНТЫ" Тогда
		Менеджер = Документы;
		
	ИначеЕсли КлассОМ = "ЖУРНАЛДОКУМЕНТОВ"
	      Или КлассОМ = "ЖУРНАЛЫДОКУМЕНТОВ" Тогда
		Менеджер = ЖурналыДокументов;
		
	ИначеЕсли КлассОМ = "ПЕРЕЧИСЛЕНИЕ"
	      Или КлассОМ = "ПЕРЕЧИСЛЕНИЯ" Тогда
		Менеджер = Перечисления;
		
	ИначеЕсли КлассОМ = "ОБЩИЙМОДУЛЬ"
	      Или КлассОМ = "ОБЩИЕМОДУЛИ" Тогда
		
		Возврат ОбщийМодуль(ИмяОМ);
		
	ИначеЕсли КлассОМ = "ОТЧЕТ"
	      Или КлассОМ = "ОТЧЕТЫ" Тогда
		Менеджер = Отчеты;
		
	ИначеЕсли КлассОМ = "ОБРАБОТКА"
	      Или КлассОМ = "ОБРАБОТКИ" Тогда
		Менеджер = Обработки;
		
	ИначеЕсли КлассОМ = "ПЛАНВИДОВХАРАКТЕРИСТИК"
	      Или КлассОМ = "ПЛАНЫВИДОВХАРАКТЕРИСТИК" Тогда
		Менеджер = ПланыВидовХарактеристик;
		
	ИначеЕсли КлассОМ = "ПЛАНСЧЕТОВ"
	      Или КлассОМ = "ПЛАНЫСЧЕТОВ" Тогда
		Менеджер = ПланыСчетов;
		
	ИначеЕсли КлассОМ = "ПЛАНВИДОВРАСЧЕТА"
	      Или КлассОМ = "ПЛАНЫВИДОВРАСЧЕТА" Тогда
		Менеджер = ПланыВидовРасчета;
		
	ИначеЕсли КлассОМ = "РЕГИСТРСВЕДЕНИЙ"
	      Или КлассОМ = "РЕГИСТРЫСВЕДЕНИЙ" Тогда
		Менеджер = РегистрыСведений;
		
	ИначеЕсли КлассОМ = "РЕГИСТРНАКОПЛЕНИЯ"
	      Или КлассОМ = "РЕГИСТРЫНАКОПЛЕНИЯ" Тогда
		Менеджер = РегистрыНакопления;
		
	ИначеЕсли КлассОМ = "РЕГИСТРБУХГАЛТЕРИИ"
	      Или КлассОМ = "РЕГИСТРЫБУХГАЛТЕРИИ" Тогда
		Менеджер = РегистрыБухгалтерии;
		
	ИначеЕсли КлассОМ = "РЕГИСТРРАСЧЕТА"
	      Или КлассОМ = "РЕГИСТРЫРАСЧЕТА" Тогда
		
		Если ЧастиИмени.Количество() < 3 Тогда
			// Регистр расчета
			Менеджер = РегистрыРасчета;
		Иначе
			КлассПодчиненногоОМ = ВРег(ЧастиИмени[2]);
			Если ЧастиИмени.Количество() > 3 Тогда
				ИмяПодчиненногоОМ = ЧастиИмени[3];
			КонецЕсли;
			Если КлассПодчиненногоОМ = "ПЕРЕРАСЧЕТ"
			 Или КлассПодчиненногоОМ = "ПЕРЕРАСЧЕТЫ" Тогда
				// Перерасчет
				Попытка
					Менеджер = РегистрыРасчета[ИмяОМ].Перерасчеты;
					ИмяОМ = ИмяПодчиненногоОМ;
				Исключение
					Менеджер = Неопределено;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли КлассОМ = "БИЗНЕСПРОЦЕСС"
	      Или КлассОМ = "БИЗНЕСПРОЦЕССЫ" Тогда
		Менеджер = БизнесПроцессы;
		
	ИначеЕсли КлассОМ = "ЗАДАЧА"
	      Или КлассОМ = "ЗАДАЧИ" Тогда
		Менеджер = Задачи;
		
	ИначеЕсли КлассОМ = "КОНСТАНТА"
	      Или КлассОМ = "КОНСТАНТЫ" Тогда
		Менеджер = Константы;
		
	ИначеЕсли КлассОМ = "ПОСЛЕДОВАТЕЛЬНОСТЬ"
	      Или КлассОМ = "ПОСЛЕДОВАТЕЛЬНОСТИ" Тогда
		Менеджер = Последовательности;
	КонецЕсли;
	
	Если Менеджер <> Неопределено Тогда
		Если ЗначениеЗаполнено(ИмяОМ) Тогда
			Попытка
				Возврат Менеджер[ИмяОМ];
			Исключение
				Менеджер = Неопределено;
			КонецПопытки;
		Иначе
			Возврат Менеджер;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не удалось получить менеджер для объекта ""%1""'"), Имя);
	
КонецФункции

// Возвращает ссылку на общий модуль по имени.
//
// Параметры:
//  Имя          - Строка - имя общего модуля, например:
//                 "ОбщегоНазначения",
//                 "ОбщегоНазначенияКлиент".
//
// Возвращаемое значение:
//  ОбщийМодуль - общий модуль.
//
Функция ОбщийМодуль(Имя) Экспорт
	
	Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда
		Модуль = Вычислить(Имя); // ВычислитьВБезопасномРежиме не требуется, т.к. проверка надежная.
	ИначеЕсли СтрЧислоВхождений(Имя, ".") = 1 Тогда
		Возврат СерверныйМодульМенеджера(Имя);
	Иначе
		Модуль = Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Модуль) <> Тип("ОбщийМодуль") Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Общий модуль ""%1"" не найден.'"), Имя);
	КонецЕсли;
	
	Возврат Модуль;
	
КонецФункции

// Возвращает серверный модуль менеджера по имени объекта.
Функция СерверныйМодульМенеджера(Имя)
	ОбъектНайден = Ложь;
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Имя, ".");
	Если ЧастиИмени.Количество() = 2 Тогда
		
		ИмяВида = ВРег(ЧастиИмени[0]);
		ИмяОбъекта = ЧастиИмени[1];
		
		Если ИмяВида = ВРег("Константы") Тогда
			Если Метаданные.Константы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыСведений") Тогда
			Если Метаданные.РегистрыСведений.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыНакопления") Тогда
			Если Метаданные.РегистрыНакопления.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыБухгалтерии") Тогда
			Если Метаданные.РегистрыБухгалтерии.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыРасчета") Тогда
			Если Метаданные.РегистрыРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Справочники") Тогда
			Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Документы") Тогда
			Если Метаданные.Документы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Отчеты") Тогда
			Если Метаданные.Отчеты.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Обработки") Тогда
			Если Метаданные.Обработки.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("БизнесПроцессы") Тогда
			Если Метаданные.БизнесПроцессы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ЖурналыДокументов") Тогда
			Если Метаданные.ЖурналыДокументов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Задачи") Тогда
			Если Метаданные.Задачи.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыСчетов") Тогда
			Если Метаданные.ПланыСчетов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыОбмена") Тогда
			Если Метаданные.ПланыОбмена.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовХарактеристик") Тогда
			Если Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовРасчета") Тогда
			Если Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ОбъектНайден Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Объект метаданных ""%1"" не найден,
			|либо для него не поддерживается получение модуля менеджера.'"), Имя);
	КонецЕсли;
	
	Модуль = Вычислить(Имя); // ВычислитьВБезопасномРежиме не требуется, т.к. проверка надежная.
	
	Возврат Модуль;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Имена типов.

// Функция-свойство: возвращает значение для идентификации общего типа "Регистры сведений"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыСведений() Экспорт
	
	Возврат "РегистрыСведений";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Регистры накопления"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыНакопления() Экспорт
	
	Возврат "РегистрыНакопления";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Регистры бухгалтерии"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыБухгалтерии() Экспорт
	
	Возврат "РегистрыБухгалтерии";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Регистры расчета"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыРасчета() Экспорт
	
	Возврат "РегистрыРасчета";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Документы"
//
// Тип: Строка
//
Функция ИмяТипаДокументы() Экспорт
	
	Возврат "Документы";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Справочники"
//
// Тип: Строка
//
Функция ИмяТипаСправочники() Экспорт
	
	Возврат "Справочники";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Отчеты"
//
// Тип: Строка
//
Функция ИмяТипаОтчеты() Экспорт
	
	Возврат "Отчеты";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Обработки"
//
// Тип: Строка
//
Функция ИмяТипаОбработки() Экспорт
	
	Возврат "Обработки";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "ПланыОбмена"
//
// Тип: Строка
//
Функция ИмяТипаПланыОбмена() Экспорт
	
	Возврат "ПланыОбмена";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Планы видов характеристик"
//
// Тип: Строка
//
Функция ИмяТипаПланыВидовХарактеристик() Экспорт
	
	Возврат "ПланыВидовХарактеристик";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Бизнес процессы"
//
// Тип: Строка
//
Функция ИмяТипаБизнесПроцессы() Экспорт
	
	Возврат "БизнесПроцессы";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Задачи"
//
// Тип: Строка
//
Функция ИмяТипаЗадачи() Экспорт
	
	Возврат "Задачи";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Планы счетов"
//
// Тип: Строка
//
Функция ИмяТипаПланыСчетов() Экспорт
	
	Возврат "ПланыСчетов";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Планы видов расчета"
//
// Тип: Строка
//
Функция ИмяТипаПланыВидовРасчета() Экспорт
	
	Возврат "ПланыВидовРасчета";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Константы"
//
// Тип: Строка
//
Функция ИмяТипаКонстанты() Экспорт
	
	Возврат "Константы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Журналы документов"
//
// Тип: Строка
//
Функция ИмяТипаЖурналыДокументов() Экспорт
	
	Возврат "ЖурналыДокументов";
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Сохранение, чтение и удаление настроек из хранилищ

// Возвращает строку ключа настроек, не превышающую допустимую длину.
// Проверяет длину строки на входе и, в случае превышения 128, преобразует ее конец по алгоритму MD5 в короткий
// вариант, в результате чего строка становится длиной 128 символов.
// Если исходная строка менее 128 символов, она возвращается в неизменном виде.
//
// Параметры:
//  Строка - Строка - строка произвольной длины.
//
Функция КлючНастроек(Знач Строка)
	Результат = Строка;
	Если СтрДлина(Строка) > 128 Тогда // ключ более 128 символов вызовет исключение при обращении к хранилищу настроек
		Результат = Лев(Строка, 128);
		//Результат = Лев(Строка, 96);
		//ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.MD5);
		//ХешированиеДанных.Добавить(Сред(Строка, 97));
		//Результат = Результат + СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Сохраняет настройку в хранилище общих настроек.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
// 
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		Значение,
		ОписаниеНастроек,
		ИмяПользователя,
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища общих настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек,
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища общих настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроек.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеОбщихНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур. 
// Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//    НужноОбновитьПовторноИспользуемыеЗначения - Булево - требуется обновить повторно используемые значения
//
Процедура ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур,
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Элемент Из МассивСтруктур Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, КлючНастроек(Элемент.Настройка), Элемент.Значение);
	КонецЦикла;
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур и обновляет повторно
//   используемые значения. Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//
Процедура ХранилищеОбщихНастроекСохранитьМассивИОбновитьПовторноИспользуемыеЗначения(МассивСтруктур) Экспорт
	
	ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур, Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище общих настроек и обновляет повторно используемые 
//   значения.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
//
Процедура ХранилищеОбщихНастроекСохранитьИОбновитьПовторноИспользуемыеЗначения(КлючОбъекта, КлючНастроек, Значение) Экспорт
	
	ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,,,Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище системных настроек.
// 
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
// 
Процедура ХранилищеСистемныхНастроекСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища системных настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеСистемныхНастроекЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища системных настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеСистемныхНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеСистемныхНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек данных форм.
// 
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
//
Процедура ХранилищеНастроекДанныхФормСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища настроек данных форм.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеНастроекДанныхФормЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища настроек данных форм.
//
// Параметры:
//   Соответствуют методу ХранилищеНастроекДанныхФорм.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеНастроекДанныхФормУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеНастроекДанныхФорм,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища - СтандартноеХранилищеНастроекМенеджер - Хранилище, в котором сохраняется настройка.
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - *      - Содержит настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Содержит информацию об описании настройки.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "Настройки, автоматически сохраняемые в системном хранилище" в синтакс-помощнике.
//
Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек, ИмяПользователя, НужноОбновитьПовторноИспользуемыеЗначения)
	
	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек(КлючНастроек), Значение, ОписаниеНастроек, ИмяПользователя);
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Загружает настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища   - СтандартноеХранилищеНастроекМенеджер - Хранилище, из которого загружается настройка.
//   КлючОбъекта         - Строка - Ключ объекта настройки. 
//   КлючНастроек        - Строка - Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - *      - Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек    - ОписаниеНастроек - Через данный параметр при загрузке можно получить описание настроек.
//   ИмяПользователя     - Строка - Имя пользователя, настройки которого загружается.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены.
//
// См. также:
//   "Настройки, автоматически сохраняемые в системном хранилище" в синтакс-помощнике.
//
Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию,
	ОписаниеНастроек, ИмяПользователя)
	
	Результат = Неопределено;
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек(КлючНастроек), ОписаниеНастроек, ИмяПользователя);
	КонецЕсли;
	
	Если (Результат = Неопределено) И (ЗначениеПоУмолчанию <> Неопределено) Тогда
		Результат = ЗначениеПоУмолчанию;
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

// Удаляет настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища - СтандартноеХранилищеНастроекМенеджер - Хранилище, из которого удаляется настройка.
//   КлючОбъекта       - Строка       - Ключ объекта настройки. 
//                     - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек      - Строка       - Ключ сохраняемых настроек.
//                     - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя   - Строка       - Имя пользователя, настройки которого загружается.
//                     - Неопределено - Удаляются настройки всех пользователей.
//
// Возвращаемое значение: 
//   (*) Настройки, загруженные из хранилища. Неопределено, если настройки не найдены. 
//
// См. также:
//   "Настройки, автоматически сохраняемые в системном хранилище" в синтакс-помощнике.
//
Процедура ХранилищеУдалить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ИмяПользователя)
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		МенеджерХранилища.Удалить(КлючОбъекта, КлючНастроек(КлючНастроек), ИмяПользователя);
	КонецЕсли;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ОБСЛУЖИВАНИЯ ОБЪЕКТОВ, НЕ ПОДДЕРЖИВАЕМЫХ В КОНФИГУРАЦИИ
//

// Выводит сообщение о том, что объект не используется в конфигурации
//
Процедура СообщитьОбъектНеИспользуется(МетаданныеОбъекта = Неопределено, Отказ = Истина, СтандартнаяОбработка = Ложь) Экспорт
	
	Перем ТипОбъекта;
	
	ТипОбъекта = "Объект";
	Если МетаданныеОбъекта <> Неопределено Тогда
		ПолноеИмяОбъекта = МетаданныеОбъекта.ПолноеИмя();
		ПозицияТочки = Найти(ПолноеИмяОбъекта, ".");
		Если ПозицияТочки <> 0 Тогда
			ТипОбъекта = Лев(ПолноеИмяОбъекта, ПозицияТочки-1);
		КонецЕсли;
	КонецЕсли;
	
	ОбщегоНазначения.СообщитьОбОшибке(ТипОбъекта+" не используется в конфигурации """ + Метаданные.Синоним + """", Отказ);
	СтандартнаяОбработка = Ложь;
	
КонецПроцедуры

// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

// Функция СтрокаТаблицыЗначенийВСтруктуру создает
// структуру со свойствами, как колонки таблицы
// значений передаваемой строки
// и устанавливает этим свойствам значения
// из строки таблицы значений
// 
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений
//
// ВозвращаемоеЗначение:
//  Структура
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
	
	Структура = Новый Структура;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

// Формирует сообщение при ошибках проведения документов.
//
// Параметры: 
//  ТекстСообщения - Исходный текст, выводимого сообщения,
//  Отказ          - Флаг отказа в проведении документа,
//  Заголовок      - Заголовок начала серии сообщений об ошибках проведения (не обязательный)
//
Процедура ОшибкаПриПроведении(ТекстСообщения, Отказ, Заголовок = "") Экспорт

	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок);

КонецПроцедуры

// Открывает ОсновнуюФорму ручной корректировки
//
Процедура РучнаяКорректировкаОсновнаяФорма(ЭтоНовый,Ссылка,ЭтотОбъект)  Экспорт
	
	Если НЕ ЭтоНовый Тогда
		ФормаНастройки = Обработки.КорректировкаДвижений.ПолучитьФорму("ОсновнаяФорма", ЭтотОбъект, Строка(Ссылка));
		ФормаНастройки.ДокументОбъект = ЭтотОбъект;
		Если ФормаНастройки.Открыта() Тогда
			Для Каждого СтрокаТаблицыРегистров из ФормаНастройки.Регистры Цикл
				СтрокаТаблицыРегистров.Прочитан = Ложь;
				//СтрокаТаблицыРегистров.Отрисован = Ложь;
			КонецЦикла;
			
			КолСтраниц = ФормаНастройки.ЭлементыФормы.ОсновнаяПанель.Страницы.Количество() - 1;
			Для НомерСтраницы = 0 По КолСтраниц Цикл
				Страница = ФормаНастройки.ЭлементыФормы.ОсновнаяПанель.Страницы[КолСтраниц - НомерСтраницы];
				Если Страница.Видимость
						И Страница.Значение="" Тогда
					ФормаНастройки.ЭлементыФормы.ОсновнаяПанель.Страницы.Удалить(ФормаНастройки.ЭлементыФормы.ОсновнаяПанель.Страницы.Индекс(Страница));
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;

		ФормаНастройки.Открыть();
	КонецЕсли;
 	
КонецПроцедуры // РучнаяКорректировкаОсновнаяФорма()

// Открывает ОсновнуюФорму ручной корректировки после записи
//
Процедура РучнаяКорректировкаОсновнаяФормаПослеЗаписи(Проведен,ОткрыватьНастройкуДвижений,Ссылка,ЭтотОбъект)  Экспорт
	
	Если (Проведен
				ИЛИ ТипЗнч(ЭтотОбъект) = Тип("ДокументОбъект.РегламентнаяОперация"))
			И ОткрыватьНастройкуДвижений Тогда
		ФормаНастройки = Обработки.КорректировкаДвижений.ПолучитьФорму("ОсновнаяФорма", ЭтотОбъект, Строка(Ссылка));
		Если ФормаНастройки.Открыта() Тогда
			СтруктураОтбора = Новый Структура;
			СтруктураОтбора.Вставить("Отображение",  Истина);
			НайденныеСтроки = ФормаНастройки.Регистры.НайтиСтроки(СтруктураОтбора);
			Для Каждого Строка Из НайденныеСтроки Цикл
				ЭтотОбъект.Движения[Строка.Имя].Прочитать();
			КонецЦикла;			
		КонецЕсли;
		Если ОткрыватьНастройкуДвижений Тогда
			ФормаНастройки.ДокументОбъект = ЭтотОбъект;
			ФормаНастройки.Открыть();
		КОнецЕсли;
	КОнецЕсли;
 	
КонецПроцедуры

// Проверка ручной корректировки
//
Функция РучнаяКорректировкаОбработкаПроведения(РучнаяКорректировка, Отказ, Заголовок, ЭтотОбъект, ВыборочноОчищатьРегистры = Истина, РазрешитьЗаписьБезПроверки = Ложь)  Экспорт
	
	Если РучнаяКорректировка Тогда
		ИзменитьАктивностьПоРегистратору(ЭтотОбъект, Отказ);
		ТекстСообщения = "Движения документа отредактированы вручную и не могут быть автоматически актуализированы.";
		СообщитьОбОшибке(ТекстСообщения, , Заголовок);
		Возврат Истина;
	Иначе
		УдалитьДвиженияРегистратора(ЭтотОбъект, Отказ, ВыборочноОчищатьРегистры,, РазрешитьЗаписьБезПроверки);
		Возврат Ложь;
	КонецЕсли;
 	
КонецФункции

// Процедура включения активности движений при проведении документа, движения которого
// заданы вручную
Процедура ИзменитьАктивностьПоРегистратору(ДокументОбъект, Отказ,ВключитьАктивность = Истина) Экспорт
	
	Для Каждого Набор ИЗ ДокументОбъект.Движения Цикл
		
		Набор.Прочитать();
		Набор.УстановитьАктивность(ВключитьАктивность);
		
		Попытка
			Набор.Записать();
		Исключение
			// возможно «сработал» RLS или механизм даты запрета изменения
			СообщитьОбОшибке(ОписаниеОшибки(), Отказ, Набор.Имя);
			ВызватьИсключение "Операция не выполнена";
		КонецПопытки;	
		
	КонецЦикла;	
	
КонецПроцедуры

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт

	Возврат НЕ (МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции

// Позволяет определить есть ли табличная часть документа с переданным именем.
//
// Параметры: 
//  ИмяТабЧасти - строковое имя искомой табличной части,
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьТабЧастьДокумента(ИмяТабЧасти, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции

Функция ПадежФИО(Знач ФИО, Падеж = 1, ТолькоИнициалы = Ложь, Знач пРазделитель = ".") Экспорт 
	
	Если ТипЗнч(ФИО) <> Тип("Строка") Тогда
		Сообщить("Неверная строка передана ""падежу ФИО!""");
		Возврат ФИО;
	КонецЕсли;
	
	// уберем множественные пробелы
	Пока 1 = 1 Цикл
		ФИО = СокрЛП(СтрЗаменить(ФИО, "  ", " "));
		Если Найти(ФИО, "  ") = 0 Тогда
			Прервать
		КонецЕсли;
	КонецЦикла;
	
	Если ТипЗнч(Падеж)=Тип("Строка") Тогда
		пад=СокрЛП(НРег(Лев(Падеж,1))); 
		Если Найти("ирдвтп",пад)=0 Тогда
			Сообщить("Неверный падеж передан ""падежу ФИО""!"); Возврат ФИО;
		КонецЕсли;
	ИначеЕсли ТипЗнч(Падеж)=Тип("Число") Тогда
		Если (Падеж<1) или (Падеж>6) Тогда
			Сообщить("Неверный падеж передан ""падежу ФИО""!"); Возврат ФИО;
		КонецЕсли; 
		пад=Падеж-1;
	КонецЕсли;
	
	ФИО=СокрЛП(НРег(ФИО)); // так удобнее
	
	// свой анализатор состава
	Фамилия="";
	Для й=1 По СтрДлина(ФИО) Цикл
		символс=Сред(ФИО,й,1);
		Если символс=" " Тогда Прервать КонецЕсли;
		Фамилия=Фамилия+символс;
	КонецЦикла;
	ы=й+1; // перешли пробел
	Имя="";
	Для й=ы По СтрДлина(ФИО) Цикл
		символс=Сред(ФИО,й,1);
		Если символс=" " Тогда Прервать КонецЕсли;
		Имя=Имя+символс;
	КонецЦикла;
	ы=й+1; // перешли второй пробел
	Отчество="";
	Для й=ы По СтрДлина(ФИО) Цикл
		символс=Сред(ФИО,й,1);
		Если символс=" " Тогда Прервать КонецЕсли;
		Отчество=Отчество+символс;
	КонецЦикла;
	
	// теперь имеем раздельно Фамилию, Имя и Отчество. 
	// начинается собственно блок анализа содержания и падежей
	
	// вернем, если сам именительный. Если установлен возврат ТолькоИнициалы, то преобразуем в инициалы
	Если (Лев(Падеж,1)="И") или (Падеж=1) Тогда 
		Если НЕ ТолькоИнициалы или Найти(ФИО, ".") Тогда 
			Возврат ФИО; // либо уже преобразованная строка, либо не нужно преобразовывать
		КонецЕсли;
		НовоеФИО = ТРег(Фамилия) + " " + Врег(Лев(Имя,1)) + пРазделитель + Врег(Лев(Отчество,1)) + пРазделитель;
		Возврат СокрЛП(НовоеФИО); // на тот случай, если разделитель пробел. Последний срежем
	КонецЕсли;
	
	
	// проанализируем пол М/Ж
	Если Прав(Отчество,1)="а" Тогда Пол="Ж" Иначе Пол="М" КонецЕсли;
	
	// создадим структуру таблицы, хранящей окончания слов
	ток=Новый ТаблицаЗначений;
	ТипСтроки=Новый ОписаниеТипов("Строка",Новый КвалификаторыСтроки(3));
	ТипЧисла=Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(1,0));
	ток.Колонки.Добавить("СтарОк",ТипСтроки); // старое окончание 2 символа
	// колонки, хранящие новые окончания слов
	ток.Колонки.Добавить("р"); // родительный
	ток.Колонки.Добавить("д"); // дательный
	ток.Колонки.Добавить("в"); // винительный
	ток.Колонки.Добавить("т"); // творительный
	ток.Колонки.Добавить("п"); // предложный
	// для указания, сколько букв с конца слова отсечь,
	ток.Колонки.Добавить("КолвоСрез",ТипЧисла); // кол-во срезаемых букв
	
	Гласные="аеэоуиыяюьъ"; // список гласных букв в виде строки
	
	// ======== обработаем фамилию ==========
	// заполним таблицу данными для фамилии
	
	Если пол="М" Тогда
		строток=ток.Добавить(); // иванов
		строток.СтарОк="*s";
		строток.р="а"; строток.д="у"; строток.в="а"; строток.т="ым"; строток.п="е";
		строток.КолвоСрез=0;
		
		строток=ток.Добавить(); // красинский
		строток.СтарОк="*й"; 
		строток.р="ого"; строток.д="ому"; строток.в="ого"; строток.т="им"; строток.п="ом";
		строток.КолвоСрез=2; 
		
		строток=ток.Добавить(); // всемогущий
		строток.СтарОк="щий"; 
		строток.р="его"; строток.д="ему"; строток.в="его"; строток.т="им"; строток.п="ем";
		строток.КолвоСрез=2; 
		
		строток=ток.Добавить(); // белый
		строток.СтарОк="ый";
		строток.р="ого"; строток.д="ому"; строток.в="ого"; строток.т="ым"; строток.п="ом";
		строток.КолвоСрез=2;
		
		строток=ток.Добавить(); // палей
		строток.СтарОк="*й";
		строток.р="я"; строток.д="ю"; строток.в="я"; строток.т="ем"; строток.п="е";
		строток.КолвоСрез=1;
		
		строток=ток.Добавить(); // рабинович
		строток.СтарОк="*ч";
		строток.р="а"; строток.д="у"; строток.в="а"; строток.т="ем"; строток.п="е";
		строток.КолвоСрез=0;
		
		строток=ток.Добавить(); // починок, зализняк
		строток.СтарОк="*к";
		строток.р="ка"; строток.д="ку"; строток.в="ка"; строток.т="ком"; строток.п="ке";
		строток.КолвоСрез=2;
		
		строток=ток.Добавить(); // шинкарь
		строток.СтарОк="*ь";
		строток.р="я"; строток.д="ю"; строток.в="я"; строток.т="ем"; строток.п="е";
		строток.КолвоСрез=1;
		
		строток=ток.Добавить(); // перельман, оганесян
		строток.СтарОк="*н";
		строток.р="а"; строток.д="у"; строток.в="а"; строток.т="ом"; строток.п="е";
		строток.КолвоСрез=0;
		
		строток=ток.Добавить(); // баранкин
		строток.СтарОк="ин";
		строток.р="а"; строток.д="у"; строток.в="а"; строток.т="ым"; строток.п="е";
		строток.КолвоСрез=0;
		
	ИначеЕсли Пол="Ж" Тогда 
		строток=ток.Добавить(); // склодовская
		строток.СтарОк="ая";
		строток.р="ой"; строток.д="ой"; строток.в="ую"; строток.т="ой"; строток.п="ой";
		строток.КолвоСрез=2;
		
		строток=ток.Добавить(); // иванова
		строток.СтарОк="*а"; 
		строток.р="ой"; строток.д="ой"; строток.в="у"; строток.т="ой"; строток.п="ой";
		строток.КолвоСрез=1;
	КонецЕсли;
	
	// таблица заполнена. считаем 2 последних буквы и поищем их
	Если не ПустаяСтрока(Фамилия) Тогда
		пб=Прав(Фамилия,3); кол="СтарОк"; // ищем по ней
		новФамилия=Фамилия; // если ничего не изменится, так и будет
		стро=ток.Найти(пб,кол);
		Если стро<>Неопределено Тогда // нашли строгое сразу
			Основа=Лев(Фамилия,СтрДлина(Фамилия)-стро.КолвоСрез);
			новФамилия=Основа+СокрЛП(стро[пад]);
		Иначе
			// строго не нашли по трем последним символам, ищем по двум символам только по последней
			пб=Прав(Фамилия,2);
			стро=ток.Найти(пб,кол);
			Если стро<>Неопределено Тогда
				Основа=Лев(Фамилия,СтрДлина(Фамилия)-стро.КолвоСрез);
				новФамилия=Основа+СокрЛП(стро[пад]);
			Иначе // если по двум не нашли, ищем по одному
				пб="*"+Прав(пб,1); 
				стро=ток.Найти(пб,кол);
				Если стро<>Неопределено Тогда // нашли по последней
					Основа=Лев(Фамилия,СтрДлина(Фамилия)-стро.КолвоСрез);
					новФамилия=Основа+СокрЛП(стро[пад]);
				Иначе // по последней не нашли, ищем по виду буквы
					пб="*"+?(Найти(Гласные,Прав(пб,1))=0,"s","g");
					стро=ток.Найти(пб,кол);
					Если стро<>Неопределено Тогда // нашли по виду
						Основа=Лев(Фамилия,СтрДлина(Фамилия)-стро.КолвоСрез);
						новФамилия=Основа+СокрЛП(стро[пад]);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	Иначе
		новФамилия="";
	КонецЕсли;
	
	// ======== обработаем имя ==========
	// заполним таблицу данными для имени
	ток.Очистить();
	
	Если Пол="М" Тогда
		// обработаем исключения
		Если Имя="лев" Тогда Имя="льв" КонецЕсли;
		Если Имя="павел" Тогда Имя="павл" КонецЕсли;
		
		строток=ток.Добавить(); // сергей
		строток.старок="*й";
		строток.р="я"; строток.д="ю"; строток.в="я"; строток.т="ем"; строток.п="е";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // иван + лев + павел
		строток.старок="*s";
		строток.р="а"; строток.д="у"; строток.в="а"; строток.т="ом"; строток.п="е";
		строток.колвосрез=0;
		
		строток=ток.Добавить(); // никита
		строток.старок="*а";
		строток.р="ы"; строток.д="е"; строток.в="у"; строток.т="ой"; строток.п="е";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // лука
		строток.старок="ка";
		строток.р="и"; строток.д="е"; строток.в="у"; строток.т="ой"; строток.п="е";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // иеремия
		строток.старок="ия";
		строток.р="и"; строток.д="и"; строток.в="ю"; строток.т="ей"; строток.п="и";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // илья
		строток.старок="*я";
		строток.р="и"; строток.д="е"; строток.в="ю"; строток.т="ей"; строток.п="е";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // игорь
		строток.старок="*ь";
		строток.р="я"; строток.д="ю"; строток.в="я"; строток.т="ем"; строток.п="е";
		строток.колвосрез=1;
		
	ИначеЕсли Пол="Ж" Тогда
		// обработаем исключения
		//Если Имя="ольга" Тогда Имя="ольгь" КонецЕсли;
		
		строток=ток.Добавить(); // ирина
		строток.старок="*а";
		строток.р="ы"; строток.д="е"; строток.в="у"; строток.т="ой"; строток.п="е";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // инга, ольга
		строток.старок="га";
		строток.р="и"; строток.д="е"; строток.в="у"; строток.т="ой"; строток.п="е";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // эсфирь
		строток.старок="*ь";
		строток.р="и"; строток.д="и"; строток.в="ь"; строток.т="ью"; строток.п="и";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // мария
		строток.старок="ия";
		строток.р="и"; строток.д="и"; строток.в="ю"; строток.т="ей"; строток.п="и";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // софья
		строток.старок="*я";
		строток.р="и"; строток.д="е"; строток.в="ю"; строток.т="ей"; строток.п="е";
		строток.колвосрез=1;
	КонецЕсли;
	
	// таблица заполнена. считаем 2 последних буквы и поищем их
	Если не ПустаяСтрока(Имя) Тогда
		пб=Прав(Имя,2); кол="СтарОк"; // ищем по ней
		новИмя=Имя; // если ничего не изменится, так и будет
		стро=ток.Найти(пб,кол);
		Если стро<>Неопределено Тогда // нашли строгое сразу
			Основа=Лев(Имя,СтрДлина(Имя)-стро.КолвоСрез);
			новИмя=Основа+СокрЛП(стро[пад]);
		Иначе // строго не нашли, ищем только по последней
			пб="*"+Прав(пб,1); 
			стро=ток.Найти(пб,кол);
			Если стро<>Неопределено Тогда // нашли по последней
				Основа=Лев(Имя,СтрДлина(Имя)-стро.КолвоСрез);
				новИмя=Основа+СокрЛП(стро[пад]);
			Иначе // по последней не нашли, ищем по виду буквы
				пб="*"+?(Найти(Гласные,Прав(пб,1))=0,"s","g");
				стро=ток.Найти(пб,кол);
				Если стро<>Неопределено=1 Тогда // нашли по виду
					Основа=Лев(Имя,СтрДлина(Имя)-стро.КолвоСрез);
					новИмя=Основа+СокрЛП(стро[пад]);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	Иначе
		новИмя="";
	КонецЕсли;
	
	// ======== обработаем отчество, тут проще ==========
	ток.Очистить();
	
	Если Пол="М" Тогда
		строток=ток.Добавить();
		строток.р="а"; строток.д="у"; строток.в="а"; строток.т="ем"; строток.п="е";
		строток.колвосрез=0;
	ИначеЕсли Пол="Ж" Тогда
		строток=ток.Добавить();
		строток.р="ы"; строток.д="е"; строток.в="у"; строток.т="ой"; строток.п="е";
		строток.колвосрез=1;
	КонецЕсли;
	Если не ПустаяСтрока(Отчество) Тогда
		Основа=Лев(Отчество,СтрДлина(Отчество)-ток[0].КолвоСрез); 
		новОтчество=Основа+СокрЛП(ток[0][пад]);
	Иначе
		новОтчество="";
	КонецЕсли; 
	
	Если ТолькоИнициалы Тогда
		новИмя=Лев(новИмя,1); новОтчество=Лев(новОтчество,1);
	КонецЕсли;
	
	// установим первые буквы верхним регистром
	новФамилия=ВРег(Лев(новФамилия,1))+Сред(новФамилия,2);
	новИмя=ВРег(Лев(новИмя,1))+Сред(новИмя,2);
	новОтчество=ВРег(Лев(новОтчество,1))+Сред(новОтчество,2);
	
	// и теперь всё вместе 
	Если ТолькоИнициалы Тогда // если задан формат инициалов
		новФИО=новФамилия+" "+новИмя+пРазделитель+новОтчество+пРазделитель;
	Иначе
		новФИО=новФамилия+" "+новИмя+" "+новОтчество;
	КонецЕсли;
	
	Если Найти(ФИО, ".") Тогда // На тот случай, если входной параметр Фамилию с инициалами. Инициалы не трогаем
		новФИО = новФамилия + " " + ТРег(Имя) + Трег(Отчество);
	КонецЕсли;
	
	Возврат СокрЛП(новФИО);
КонецФункции

// Формирует структуру дерева значений, содержащего имена полей, которые
// нужно заполнить в запросе по шапке документа.
//
// Параметры: 
//  Нет.
//
// Возвращаемое значение:
//  Дерево значений.
//
Функция СформироватьДеревоПолейЗапросаПоШапке()  Экспорт

	ДеревоПолейЗапросаПоШапке = Новый ДеревоЗначений;
	ОписаниеТиповСтрока       = ПолучитьОписаниеТиповСтроки(100);

	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Объект"   , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Поле"     , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Псевдоним", ОписаниеТиповСтрока);

	Возврат ДеревоПолейЗапросаПоШапке;

КонецФункции

// Вставляет строку в дерево полей запроса по шапке, если ее там еще нет,
// если есть, то ничего не делает.
//
// Параметры:
//  ДеревоПолейЗапросаПоШапке - дерево значений, содержащего имена полей, 
//                              которые нужно заполнить в запросе по шапке документа, 
//  ИмяОбъекта                - строка, имя объекта (справочник, регистр и т.д.), 
//  ИмяПоля                   - строка, имя поля объекта,
//  ИмяПсевдонима             - строка, имя псевдонима в запросе поля объекта (необязательный).
//
Процедура ДобавитьСтрокуВДеревоПолейЗапросаПоШапке(ДеревоПолейЗапросаПоШапке, ИмяОбъекта, ИмяПоля, ИмяПсевдонима = Неопределено) Экспорт

	// Поищем нужную строку.
	// Вначале ищем объект.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти(ИмяОбъекта, "Объект");

	Если СтрокаОбъекта = Неопределено Тогда // нужно добавить.

		СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Добавить();

		СтрокаОбъекта.Объект    = ИмяОбъекта;
		СтрокаОбъекта.Поле      = ИмяПоля;
		СтрокаОбъекта.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

	// Ищем поле.
	СтрокаПоля = СтрокаОбъекта.Строки. Найти(ИмяПоля,"Поле");

	Если СтрокаПоля = Неопределено Тогда // нужно добавить

		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();

		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

	// Ищем псевдоним.
	СтрокаПоля = СтрокаОбъекта.Строки.Найти( ИмяПсевдонима, "Псевдоним");

	Если СтрокаПоля = Неопределено Тогда // нужно добавить

		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();

		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

КонецПроцедуры // ДобавитьСтрокуВДеревоПолейЗапросаПоШапке()

// По переданной структуре полей формирует запрос по табличной части документа.
//
// Параметры: 
//  ДокументОбъект    - объект проводимого документа, 
//  ИмяТабличнойЧасти - строка, имя табличной части,
//  СтруктураПолей    - структура, ключ структуры содержит псевдоним поля запроса, значение - строку запроса,
//
// Возвращаемое значение:
//  Результат запроса.
//
Функция СформироватьЗапросПоТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураПолей) Экспорт

	ТекстЗапроса = "";

	Для Каждого Реквизит Из СтруктураПолей Цикл

		ТекстЗапроса  = ТекстЗапроса + ",
		|	Док." + Реквизит.Значение + " КАК " + СокрЛП(Реквизит.Ключ);

	КонецЦикла;

	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ 
	|	Док.НомерСтроки " + ТекстЗапроса + "
	|
	|ИЗ 
	|	Документ." + ДокументОбъект.Метаданные().Имя + "."+ СокрЛП(ИмяТабличнойЧасти) + " КАК Док
	|
	|ГДЕ
	|	Док.Ссылка = &ДокументСсылка
	|
	|УПОРЯДОЧИТЬ ПО
	|      НомерСтроки";
	
	// Установим параметры запроса.
	Запрос.УстановитьПараметр("ДокументСсылка" , ДокументОбъект.Ссылка);

	Возврат Запрос.Выполнить();

КонецФункции // СформироватьЗапросПоТабличнойЧасти()

Функция СписокЗначенийВСтроку(спЗначений, Разделитель) Экспорт
	
	СтрокаСписок = "";
	Для Каждого Строка Из спЗначений Цикл
		СтрокаСписок = СтрокаСписок + ?(СокрЛП(СтрокаСписок) <> "", Разделитель, "") + ?(СокрЛП(Строка.Значение) <> "", СокрЛП(Строка.Значение), "");
	КонецЦикла;
	
	Возврат СтрокаСписок;
	
КонецФункции

// Функция собирает сведения о 
//
// Параметры:
//  Организация - организация, для которой нужно определить руководящих лиц.
//
Функция ОтветственныеЛица(Организация, ДатаСреза, Подразделение = Неопределено) Экспорт
	
	СобиратьПоОрганизации = Истина;
	// {ОбособленныеПодразделения
	Если ЗначениеЗаполнено(Подразделение) Тогда 
		СобиратьПоОрганизации = Ложь;
	Иначе
		СобиратьПоОрганизации = Истина;
	КонецЕсли;
	// }ОбособленныеПодразделения
	
	Результат = Новый Структура("Руководитель, РуководительДолжность, РуководительФИО, РуководительПредставление, 
								|ГлавныйБухгалтер, ГлавныйБухгалтерДолжность, ГлавныйБухгалтерФИО, ГлавныйБухгалтерПредставление, 
								|Кассир, КассирДолжность, КассирФИО, КассирПредставление,  
								|ОтветственныйЗаРегистры, ОтветственныйЗаРегистрыДолжность, ОтветственныйЗаРегистрыФИО, ОтветственныйЗаРегистрыПредставление");

	Если Организация <> Неопределено Тогда

		ЗапросПоЛицам = Новый Запрос;
		ЗапросПоЛицам.УстановитьПараметр("ДатаСреза"	, ДатаСреза);
		ЗапросПоЛицам.УстановитьПараметр("Организация"	, Организация);
		//ЗапросПоЛицам.УстановитьПараметр("ПризнакФизЛица",   Перечисления.ЮрФизЛицо.ФизЛицо);
		//
		//ЗапросПоЛицам.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
		//					  |	ФИОФизЛицСрезПоследних.Фамилия,
		//					  |	ФИОФизЛицСрезПоследних.Имя,
		//					  |	ФИОФизЛицСрезПоследних.Отчество,
		//					  |	ФИОФизЛицСрезПоследних.ФизЛицо КАК ФизическоеЛицо
		//					  |ИЗ
		//					  |	РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ) КАК ФИОФизЛицСрезПоследних
		//					  |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Организации КАК Организации
		//					  |		ПО ФИОФизЛицСрезПоследних.ФизЛицо = Организации.ИндивидуальныйПредприниматель
		//					  |			И (Организации.Ссылка = &Организация)
		//					  |			И (Организации.ЮрФизЛицо = &ПризнакФизЛица)";
		//
		//Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
		//
		//Пока Руководители.Следующий() Цикл
		//	
		//	ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");
		//	Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
		//		ФИО.Фамилия = Руководители.Фамилия;
		//	КонецЕсли;
		//	Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
		//		ФИО.Имя = Руководители.Имя;
		//	КонецЕсли;
		//	Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
		//		ФИО.Отчество = Руководители.Отчество;
		//	КонецЕсли;
		//	Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
		//	
		//	Результат.Руководитель               = Руководители.ФизическоеЛицо;
		//	Результат.РуководительДолжность      = "";
		//	Результат.РуководительФИО            = ФИО;
		//	Результат.РуководительПредставление  = Представление;
		//	
		//КонецЦикла;
		
		Если СобиратьПоОрганизации Тогда
			
			ЗапросПоЛицам.Текст = 
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	ОтветственныеЛицаОрганизацийСрезПоследних.ОтветственноеЛицо,
			|	ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо,
			|	ОтветственныеЛицаОрганизацийСрезПоследних.Должность,
			|	ФИОФизЛицСрезПоследних.Фамилия,
			|	ФИОФизЛицСрезПоследних.Имя,
			|	ФИОФизЛицСрезПоследних.Отчество
			|ИЗ
			|	РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(&ДатаСреза, СтруктурнаяЕдиница = &Организация) КАК ОтветственныеЛицаОрганизацийСрезПоследних
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо ССЫЛКА Справочник.ФизическиеЛица) КАК ФИОФизЛицСрезПоследних
			|		ПО ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо = ФИОФизЛицСрезПоследних.ФизЛицо";
			Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
		// {ОбособленныеПодразделения	
		Иначе
			
			// Создание таблицы иерархии подразделения.
			ТаблицаСтруктурныхЕдиниц = Новый ТаблицаЗначений;
			ТаблицаСтруктурныхЕдиниц.Колонки.Добавить("Порядок"				, ОбщегоНазначения.ПолучитьОписаниеТиповЧисла(15));
			ТаблицаСтруктурныхЕдиниц.Колонки.Добавить("СтруктурнаяЕдиница"	, Новый ОписаниеТипов("СправочникСсылка.Организации, СправочникСсылка.ПодразделенияОрганизаций"));
			
			Порядок = 1;
			
			// Добавление подразделения.
			НоваяСтрока = ТаблицаСтруктурныхЕдиниц.Добавить();
			НоваяСтрока.Порядок            = Порядок;
			НоваяСтрока.СтруктурнаяЕдиница = Подразделение;
			
			// Добавление родителей подразделения.
			Если Подразделение.Уровень() > 0 Тогда 
				
				Родитель = Подразделение.Родитель;
				
				Пока ЗначениеЗаполнено(Родитель) Цикл
					
					Порядок = Порядок + 1;
					
					НоваяСтрока = ТаблицаСтруктурныхЕдиниц.Добавить();
					НоваяСтрока.Порядок            = Порядок;
					НоваяСтрока.СтруктурнаяЕдиница = Родитель;
					
					Родитель = Родитель.Родитель;
					
				КонецЦикла;
				
			КонецЕсли;
			
			// Добавление организации.
			НоваяСтрока = ТаблицаСтруктурныхЕдиниц.Добавить();
			НоваяСтрока.Порядок            = Порядок + 1;
			НоваяСтрока.СтруктурнаяЕдиница = Организация;
			
			// Поиск наименьшей структурной единицы, для которой задано ответственное лицо.
			ЗапросПоЛицам.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
			ЗапросПоЛицам.УстановитьПараметр("ВнешнийИсточник", ТаблицаСтруктурныхЕдиниц);
			ЗапросПоЛицам.Текст = 
			"ВЫБРАТЬ
			|	ВнешнийИсточник.Порядок,
			|	ВнешнийИсточник.СтруктурнаяЕдиница
			|ПОМЕСТИТЬ ТаблицаСтруктурныхЕдиниц
			|ИЗ
			|	&ВнешнийИсточник КАК ВнешнийИсточник
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	МИНИМУМ(ТаблицаСтруктурныхЕдиниц.Порядок) КАК Порядок,
			|	ОтветственныеЛицаОрганизацийСрезПоследних.ОтветственноеЛицо
			|ПОМЕСТИТЬ ОтветственныеЛица
			|ИЗ
			|	ТаблицаСтруктурныхЕдиниц КАК ТаблицаСтруктурныхЕдиниц
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(&ДатаСреза, ) КАК ОтветственныеЛицаОрганизацийСрезПоследних
			|		ПО ТаблицаСтруктурныхЕдиниц.СтруктурнаяЕдиница = ОтветственныеЛицаОрганизацийСрезПоследних.СтруктурнаяЕдиница
			|
			|СГРУППИРОВАТЬ ПО
			|	ОтветственныеЛицаОрганизацийСрезПоследних.ОтветственноеЛицо";
			ЗапросПоЛицам.Выполнить();
			
			// Получение информации о должностях и ФИО ответственных лиц.
			ЗапросПоЛицам.Текст =
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	ОтветственныеЛица.ОтветственноеЛицо,
			|	ТаблицаСтруктурныхЕдиниц.СтруктурнаяЕдиница,
			|	ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо,
			|	ОтветственныеЛицаОрганизацийСрезПоследних.Должность,
			|	ФИОФизЛицСрезПоследних.Фамилия,
			|	ФИОФизЛицСрезПоследних.Имя,
			|	ФИОФизЛицСрезПоследних.Отчество
			|ИЗ
			|	ОтветственныеЛица КАК ОтветственныеЛица
			|		ЛЕВОЕ СОЕДИНЕНИЕ ТаблицаСтруктурныхЕдиниц КАК ТаблицаСтруктурныхЕдиниц
			|		ПО ОтветственныеЛица.Порядок = ТаблицаСтруктурныхЕдиниц.Порядок
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(&ДатаСреза, ) КАК ОтветственныеЛицаОрганизацийСрезПоследних
			|		ПО (ТаблицаСтруктурныхЕдиниц.СтруктурнаяЕдиница = ОтветственныеЛицаОрганизацийСрезПоследних.СтруктурнаяЕдиница)
			|			И ОтветственныеЛица.ОтветственноеЛицо = ОтветственныеЛицаОрганизацийСрезПоследних.ОтветственноеЛицо
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо ССЫЛКА Справочник.ФизическиеЛица) КАК ФИОФизЛицСрезПоследних
			|		ПО (ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо = ФИОФизЛицСрезПоследних.ФизЛицо)";
			Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
		// }ОбособленныеПодразделения	
		КонецЕсли;

		Пока Руководители.Следующий() Цикл

			ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");
			Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
				ФИО.Фамилия = Руководители.Фамилия;
			КонецЕсли;
			Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
				ФИО.Имя = Руководители.Имя;
			КонецЕсли;
			Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
				ФИО.Отчество = Руководители.Отчество;
			КонецЕсли;
			Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
			
			Если Руководители.ОтветственноеЛицо      = Перечисления.ОтветственныеЛицаОрганизаций.Руководитель Тогда
				Результат.Руководитель               = Руководители.ФизическоеЛицо;
				Результат.РуководительДолжность      = Руководители.Должность;
				Результат.РуководительФИО            = ФИО;
				Результат.РуководительПредставление  = Представление;

			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер Тогда
				Результат.ГлавныйБухгалтер           = Руководители.ФизическоеЛицо;
				Результат.ГлавныйБухгалтерДолжность  = Руководители.Должность;
                Результат.ГлавныйБухгалтерФИО        = ФИО;
				Результат.ГлавныйБухгалтерПредставление  = Представление;
				
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.Кассир Тогда
				Результат.Кассир                     = Руководители.ФизическоеЛицо;
				Результат.КассирДолжность      		 = Руководители.Должность;
                Результат.КассирФИО            		 = ФИО;
				Результат.КассирПредставление  = Представление;
				
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ОтветственныйЗаНалоговыеРегистры Тогда
				Результат.ОтветственныйЗаРегистры    = Руководители.ФизическоеЛицо;
				Результат.ОтветственныйЗаРегистрыДолжность      = Руководители.Должность;
				Результат.ОтветственныйЗаРегистрыФИО = ФИО;
				Результат.ОтветственныйЗаРегистрыПредставление  = Представление;

			КонецЕсли;

		КонецЦикла;

	КонецЕсли;

	Возврат Результат;

КонецФункции

Функция ЭтоКопияБазы() Экспорт
	
	СтрСоединения = НРег(СтрокаСоединенияИнформационнойБазы());
	СтрСоединения = СтрЗаменить(СтрСоединения, "10.0.0.40", "srv-sql01");
	//СтрСоединения = СтрЗаменить(СтрСоединения, "10.0.0.15", "srv-sql01");
	СтрСоединения = СтрЗаменить(СтрСоединения, "srv-sql02", "srv-sql01");
	
	Возврат НРег(Константы.СтрокаПодключенияКБазе.Получить()) <> СтрСоединения;
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl.
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса.
//  ИмяСервиса - Строка - имя сервиса.
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap.
//  ИмяПользователя - Строка - имя пользователя для входа на сервер.
//  Пароль - Строка - пароль пользователя.
//  Таймаут - Число - таймаут на операции выполняемые через полученное прокси.
//
// Возвращаемое значение:
//  WSПрокси
//
Функция WSПрокси(Знач АдресWSDL,
	Знач URIПространстваИмен,
	Знач ИмяСервиса,
	Знач ИмяТочкиПодключения = "",
	Знач ИмяПользователя,
	Знач Пароль,
	Знач Таймаут = 0,
	Знач ДелатьКонтрольныйВызов = Ложь) Экспорт

	Возврат ОбщегоНазначенияПовтИсп.WSПрокси(
		АдресWSDL,
		URIПространстваИмен,
		ИмяСервиса,
		ИмяТочкиПодключения,
		ИмяПользователя,
		Пароль,
		Таймаут);
	
КонецФункции

///  Объединяет строки из массива в строку с разделителями.
//
// Параметры:
//  Массив      - Массив - массив строк которые необходимо объединить в одну строку;
//  Разделитель - Строка - любой набор символов, который будет использован в качестве разделителя.
//
// Возвращаемое значение:
//  Строка - строка с разделителями.
// 
Функция СтрокаИзМассиваПодстрок(Массив, Разделитель = ",", СокращатьНепечатаемыеСимволы = Ложь) Экспорт
	
	Результат = "";
	
	Для Индекс = 0 По Массив.ВГраница() Цикл
		Подстрока = Массив[Индекс];
		
		Если СокращатьНепечатаемыеСимволы Тогда
			Подстрока = СокрЛП(Подстрока);
		КонецЕсли;
		
		Если ТипЗнч(Подстрока) <> Тип("Строка") Тогда
			Подстрока = Строка(Подстрока);
		КонецЕсли;
		
		Если Индекс > 0 Тогда
			Результат = Результат + Разделитель;
		КонецЕсли;
		
		Результат = Результат + Подстрока;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Определяет, является ли символ разделителем.
//
// Параметры:
//  КодСимвола      - Число  - код проверяемого символа;
//  РазделителиСлов - Строка - символы разделителей.
//
// Возвращаемое значение:
//  Булево - истина, если символ является разделителем.
//
Функция ЭтоРазделительСлов(КодСимвола, РазделителиСлов = Неопределено) Экспорт
	
	Если РазделителиСлов <> Неопределено Тогда
		Возврат Найти(РазделителиСлов, Символ(КодСимвола)) > 0;
	КонецЕсли;
		
	Диапазоны = Новый Массив;
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 48, 57)); 		// цифры
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 65, 90)); 		// латиница большие
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 97, 122)); 		// латиница маленькие
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 1040, 1103)); 	// кириллица
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 1025, 1025)); 	// символ "Ё"
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 1105, 1105)); 	// символ "ё"
	Диапазоны.Добавить(Новый Структура("Мин,Макс", 95, 95)); 		// символ "_"
	
	Для Каждого Диапазон Из Диапазоны Цикл
		Если КодСимвола >= Диапазон.Мин
				И КодСимвола <= Диапазон.Макс Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Разбивает строку на несколько строк, используя заданный набор разделителей.
// Если параметр РазделителиСлов не задан, то разделителем слов считается любой из символов, 
// не относящихся к символам латиницы, кириллицы, цифры, подчеркивания.
//
// Параметры:
//  Строка          - Строка - строка, которую необходимо разложить на слова.
//  РазделителиСлов - Строка - строка, содержащая символы-разделители.
//
//  Возвращаемое значение:
//      массив значений, элементы которого - отдельные слова.
//
// Пример:
//  РазложитьСтрокуВМассивСлов("один-@#два2_!три") возвратит массив значений: "один", "два2_", "три";
//  РазложитьСтрокуВМассивСлов("один-@#два2_!три", "#@!_") возвратит массив значений: "один-", "два2", "три".
//
Функция РазложитьСтрокуВМассивСлов(Знач Строка, РазделителиСлов = Неопределено) Экспорт
	
	Слова = Новый Массив;
	
	РазмерТекста = СтрДлина(Строка);
	НачалоСлова = 1;
	Для Позиция = 1 По РазмерТекста Цикл
		КодСимвола = КодСимвола(Строка, Позиция);
		Если ЭтоРазделительСлов(КодСимвола, РазделителиСлов) Тогда
			Если Позиция <> НачалоСлова Тогда
				Слова.Добавить(Сред(Строка, НачалоСлова, Позиция - НачалоСлова));
			КонецЕсли;
			НачалоСлова = Позиция + 1;
		КонецЕсли;
	КонецЦикла;
	
	Если Позиция <> НачалоСлова Тогда
		Слова.Добавить(Сред(Строка, НачалоСлова, Позиция - НачалоСлова));
	КонецЕсли;
	
	Возврат Слова;
	
КонецФункции	

// Преобразует (сериализует) любое значение в XML-строку.
// Преобразованы в могут быть только те объекты, для которых в синтакс-помощнике указано, что они сериализуются.
// См. также ЗначениеИзСтрокиXML.
//
// Параметры:
//  Значение - Произвольный - значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
//  Строка - XML-строка.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Выполняет преобразование (десериализацию) XML-строки в значение.
// См. также ЗначениеВСтрокуXML.
//
// Параметры:
//  СтрокаXML - Строка - XML-строка, с сериализованным объектом..
//
// Возвращаемое значение:
//  Произвольный - значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

//+++АК GEYV 03.06.2015
Процедура ЗаменитьНеСуществующиеФайлыВременнымиФайлами(Картинки,ТекстHTML) Экспорт

	Соответствие = Новый Соответствие;
	
	Для каждого ТекКартинка Из Картинки Цикл
		
		ИмяТекКартинкаНаДиске = СтрЗаменить(ТекКартинка.href,"file:///","");
		
		ТекКартинкаНаДиске = Новый Файл(ИмяТекКартинкаНаДиске);
		
		//Попытка
		//
		//	ФайлСуществует = ТекКартинкаНаДиске.Существует();	
		//
		//Исключение
		//	
		//	ФайлСуществует = Ложь;
		//
		//КонецПопытки;
		//
		//Если ФайлСуществует Тогда
		//
		//	Продолжить;	
		//
		//КонецЕсли;

		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	ХранилищеДополнительнойИнформации.Ссылка,
		|	ХранилищеДополнительнойИнформации.ИмяФайла,
		|	КаталогХраненияФайловКартинок.Значение КАК Каталог
		|ИЗ
		|	Справочник.ХранилищеДополнительнойИнформации КАК ХранилищеДополнительнойИнформации,
		|	Константа.КаталогХраненияФайловКартинок КАК КаталогХраненияФайловКартинок
		|ГДЕ
		|	ХранилищеДополнительнойИнформации.ИмяФайла ПОДОБНО &ИмяФайла";
		
		Запрос.УстановитьПараметр("ИмяФайла", ТекКартинкаНаДиске.ИмяБезРасширения);
		
		Результат = Запрос.Выполнить();
		
		Если Результат.Пустой() Тогда
			
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = "Не найдена картинка в базе! "+ ТекКартинка.href;
			Сообщение.Сообщить();
			
			Продолжить;
			
		КонецЕсли;
		
		ВыборкаДетальныеЗаписи = Результат.Выбрать();
		
		ВыборкаДетальныеЗаписи.Следующий();
		
		ИмяВременногоФайла = ВыборкаДетальныеЗаписи.Каталог + ?(Прав(ВыборкаДетальныеЗаписи.Каталог, 1) <> "\", "\", "") + "Справочник хранилище доп информации\"
			+ ВыборкаДетальныеЗаписи.ИмяФайла;
		
		//ЗначениеКартинка = ВыборкаДетальныеЗаписи.Ссылка.Хранилище.Получить();
		//
		//ИмяВременногоФайла = КаталогВременныхФайлов()+ВыборкаДетальныеЗаписи.Ссылка.УникальныйИдентификатор()+Прав(ТекКартинка.href,4);
		//
		//ЗначениеКартинка.Записать(ИмяВременногоФайла);
		
		//ИмяВременногоФайла = ПолучитьИмяВременногоФайла(Прав(ТекКартинка.href,4));
		
		Соответствие.Вставить("<IMG src="+""""+ИмяВременногоФайла+""""+">",ТекКартинка.outerHTML);
        		
	КонецЦикла;
	
	Для каждого ТекСоответствие Из Соответствие Цикл
	
		ТекстHTML = СтрЗаменить(ТекстHTML,ТекСоответствие.Значение,ТекСоответствие.Ключ);
	
	КонецЦикла;

КонецПроцедуры

Функция ПроверитьКонтрагентаНаВхождениеВПапку(Контрагент) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Налоги", Справочники.Контрагенты.НайтиПоКоду("000000523"));
	Запрос.УстановитьПараметр("Ссылка", Контрагент);
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	Контрагенты.Ссылка
	|ИЗ
	|	Справочник.Контрагенты КАК Контрагенты
	|ГДЕ
	|	Контрагенты.Ссылка = &Ссылка
	|	И Контрагенты.Ссылка В ИЕРАРХИИ(&Налоги)";

	Результат = Запрос.Выполнить();

	Возврат НЕ Результат.Пустой();

КонецФункции

Процедура ПроверитьКонтрагентаПередЗаписью(Объект,Отказ) Экспорт
	
	Если Объект.ЭтоГруппа Тогда
		Возврат;
	КонецЕсли;	
	
	//
	Если НЕ (((Объект.ЭтоНовый()
						И ПроверитьКонтрагентаНаВхождениеВПапку(Объект.Родитель))
				ИЛИ Объект.Родитель = Справочники.Контрагенты.НайтиПоКоду("000000523"))
			ИЛИ	ПроверитьКонтрагентаНаВхождениеВПапку(Объект.Ссылка)) Тогда
		
		Если НЕ ЗначениеЗаполнено(Объект.ОсновнойБухгалтерПокупателя) Тогда
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = "Заполните ответственного сотрудника (бухгалтера)";
			Сообщение.Сообщить();
			Отказ = Истина;
		КонецЕсли;
		Если НЕ ЗначениеЗаполнено(Объект.ОсновнойМенеджерПокупателя) Тогда
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = "Заполните ответственного сотрудника (менеджера)";
			Сообщение.Сообщить();
			Отказ = Истина;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры  

Функция ПодключитьсяКБухгалтерии(ТестоваяБаза = Ложь) Экспорт

	//СтрокаПодключения = Константы.СтрокаПодключенияКБухгалтерии.Получить();
	//
	//Если СтрокаПодключения = "" Тогда
	//
	//	СтрокаПодключения = "Srvr=""10.0.0.15""; Ref=""BP_CORP""; Usr=""Обмен""; Pwd=""123321""";
	//
	//КонецЕсли;
	
	СтрокаПодключения = ПолныеПрава.ПолучитьСтрокуПодключения_Бух();
	
	//Если ТестоваяБаза Тогда
	//
	//	СтрокаПодключения = "Srvr=""srv-sql01""; Ref=""BP_CORP_DEB""; Usr=""Обмен""; Pwd=""123321""";
	//
	//Иначе
	//	
	//	СтрокаПодключения = "Srvr=""srv-sql01""; Ref=""BP_CORP""; Usr=""Обмен""; Pwd=""123321""";
	//	
	//КонецЕсли;
	
	v82 = Неопределено;
	
	Если v82 = Неопределено Тогда
		
		v82COMОбъект = Новый COMОбъект(ПолныеПрава.ПолучитьВерсиюКомОбъекта_Бух() + ".COMConnector");
		
		Попытка
			
			v82 = v82COMОбъект.Connect(СтрокаПодключения);
			
			ПодключениеУстановлено = Истина;
			
		Исключение
			
			ПодключениеУстановлено = Ложь;
			
			Сообщение = Новый СообщениеПользователю;
			
			Сообщение.Текст = "Не удалось подключитьс к базе Бух";
			
			Сообщение.Сообщить();
			
			Возврат Неопределено;
			
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат v82;
	
КонецФункции

Функция ПолучитьСчет44ДляДр(СтатьяДР) Экспорт

	//
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", СтатьяДР);
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	СтатьиДоходовРасходовСписокСчетовУчета.СчетУчета,
	|	СтатьиДоходовРасходовСписокСчетовУчета.ОсновнойСчет КАК ОсновнойСчет
	|ИЗ
	|	Справочник.СтатьиДоходовРасходов.СписокСчетовУчета КАК СтатьиДоходовРасходовСписокСчетовУчета
	|ГДЕ
	|	СтатьиДоходовРасходовСписокСчетовУчета.СчетУчета В ИЕРАРХИИ(ЗНАЧЕНИЕ(ПланСчетов.Финансовый.ЗатратыДляРаспределения))
	|	И СтатьиДоходовРасходовСписокСчетовУчета.Ссылка = &Ссылка
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОсновнойСчет УБЫВ";
	Результат = Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
	
		Возврат ПланыСчетов.Финансовый.ЗатратыОбщиеДляРаспределения;
	
	КонецЕсли;

	Выборка = Результат.Выбрать();

	Пока Выборка.Следующий() Цикл
    	Возврат Выборка.СчетУчета;
	КонецЦикла;

КонецФункции

//Минеев Дмитрий - вынес функционал процедуры в модуль регистра бухгалтерии, так как ее вызов происходит в цикле и все это очень плохо для производительности
//Процедура ПроверитьСчет44ДляДр(Период,СчетУчета,СтатьяДР,Отказ) Экспорт
//	
//	//{{КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
//	// Данный фрагмент построен конструктором.
//	// При повторном использовании конструктора, внесенные вручную изменения будут утеряны!!!

//	Запрос = Новый Запрос;
//	Запрос.Текст = 
//		"ВЫБРАТЬ
//		|	СтатьиДоходовРасходовСписокСчетовУчета.СчетУчета,
//		|	СтатьиДоходовРасходовСписокСчетовУчета.ОсновнойСчет,
//		|	ВЫБОР
//		|		КОГДА СтатьиДоходовРасходовСписокСчетовУчета.СчетУчета В ИЕРАРХИИ (ЗНАЧЕНИЕ(ПланСчетов.Финансовый.ЗатратыДляРаспределения))
//		|			ТОГДА ИСТИНА
//		|		ИНАЧЕ ЛОЖЬ
//		|	КОНЕЦ КАК ВГруппе
//		|ИЗ
//		|	Справочник.СтатьиДоходовРасходов.СписокСчетовУчета КАК СтатьиДоходовРасходовСписокСчетовУчета
//		|ГДЕ
//		|	СтатьиДоходовРасходовСписокСчетовУчета.Ссылка = &Ссылка
//		|	И СтатьиДоходовРасходовСписокСчетовУчета.СчетУчета = ЗНАЧЕНИЕ(ПланСчетов.Финансовый.ЗатратыДляРаспределения)";

//	Запрос.УстановитьПараметр("Ссылка",   СтатьяДР);
//	Запрос.УстановитьПараметр("СчетУчета",СчетУчета);
//	Результат = Запрос.Выполнить();
//	
//	Если Результат.Пустой() И Не СтатьяДР.СписокСчетовУчета.Количество() Тогда
//	
//		Возврат ;
//		
//	ИначеЕсли Результат.Пустой() Тогда
//		
//		Датазапрета = Константы.ДатаОграниченийПоСтатьямДР.Получить();
//		
//		Если ЗначениеЗаполнено(ДатаЗапрета) И Период >= Датазапрета Тогда
//			
//			Отказ = Истина;
//			
//			Сообщение = Новый СообщениеПользователю;
//			Сообщение.Текст = "Для статьи ДР "+СтатьяДР+" запрещено использовать счет "+СчетУчета;
//			Сообщение.Сообщить();
//			
//			Возврат
//			
//		КонецЕсли;
//		
//		Сообщение = Новый СообщениеПользователю;
//		Сообщение.Текст = "Для статьи "+СтатьяДР+" указан "+СчетУчета+" счет, который не используется для данной статьи!";
//		Сообщение.Сообщить();	

//	
//	КонецЕсли;

//	ВыборкаДетальныеЗаписи = Результат.Выбрать();

//	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
//		
//		Если Не ВыборкаДетальныеЗаписи.ОсновнойСчет Тогда
//		
//			Сообщение = Новый СообщениеПользователю;
//			Сообщение.Текст = "Для статьи "+СтатьяДР+" указан "+СчетУчета+" счет не основной!";
//			Сообщение.Сообщить();	
//		
//		КонецЕсли;      
//		
//		Возврат
//		
//	КонецЦикла;

//	//}}КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА

//	//Если СтатьяДР.СписокСчетовУчета.Количетсво() Тогда
//	//	
//	//	МассивСтрок = СтатьяДР.СписокСчетовУчета.НайтиСтроки(Новый Структура("СчетУчета,ОсновнойСчет",СчетУчета,Истина);
//	//	
//	//	Если МассивСтрок.Количетсво() Тогда
//	//		
//	//		Сообщение = Новый СообщениеПользователю;
//	//		Сообщение.Текст = "";
//	//		Сообщение.Поле = "";
//	//		Сообщение.УстановитьДанные();
//	//		Сообщение.Сообщить();
//	//		
//	//	КонецЕсли;
//	//
//	//КонецЕсли;
//	
//КонецПроцедуры

Функция ПолучитьКонтрагентаПоСЕ(СтруктурнаяЕдиница) Экспорт
	
	//
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Владелец", СтруктурнаяЕдиница);
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	Склады.Контрагент
	|ИЗ
	|	Справочник.Склады КАК Склады
	|ГДЕ
	|	Склады.Владелец = &Владелец
	|	И Склады.ВидСклада = ЗНАЧЕНИЕ(Перечисление.ВидыСкладов.ОтветственноеХранение)
	|	И НЕ Склады.Контрагент = ЗНАЧЕНИЕ(Справочник.Контрагенты.ПустаяСсылка)
	|	И НЕ Склады.ПометкаУдаления";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Контрагент;
	Иначе
		Возврат Справочники.Контрагенты.ПустаяСсылка();
	КонецЕсли;

КонецФункции

Функция ВернутьДокументПриказНаКомандировку(Ссылка) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ДокументОснование", Ссылка);
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПриказНаКомандировку.Ссылка
	|ИЗ
	|	Документ.ПриказНаКомандировку КАК ПриказНаКомандировку
	|ГДЕ
	//|	ПриказНаКомандировку.Проведен И
	|	ПриказНаКомандировку.ДокументОснование = &ДокументОснование";
	
	Результат = Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
	
		Возврат Неопределено
	
	Иначе
	
		Выборка = Результат.Выбрать();
		
		Выборка.Следующий();
		
		Возврат Выборка.Ссылка;
	
	КонецЕсли;

КонецФункции

Процедура ПроверитьСуществованиеПриказаНаКомандировку(Ссылка,Отказ) Экспорт
	
	//
	Если ВернутьДокументПриказНаКомандировку(Ссылка) = Неопределено Тогда
		
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = "Не создан документ приказ на командировку!";
		Сообщение.Сообщить();	
		
	КонецЕсли;

КонецПроцедуры

Функция ПолучитьПодписьФизлица(ФизЛицо) Экспорт 
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ФизЛицо", Физлицо);
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Факсимиле.Подпись
	|ИЗ
	|	Справочник.Факсимиле КАК Факсимиле
	|ГДЕ
	|	Факсимиле.ФизЛицо = &ФизЛицо
	|	И НЕ Факсимиле.ПометкаУдаления";
	ТЗ = Запрос.Выполнить().Выгрузить();
	
	ГСЧ = Новый ГенераторСлучайныхЧисел();
	Случай = ГСЧ.СлучайноеЧисло(0, ТЗ.Количество());
	
	Возврат ?(Случай = 0, ФизЛицо.Подпись, ТЗ[Случай - 1].Подпись);	
	
КонецФункции

Функция ПолучитьКонтактнуюИнформациюПоВиду(Объект, Вид) Экспорт
	
	//
	Результат = Новый Структура;
	
	//
	ТЗ = "ВЫБРАТЬ
	     |	КонтактнаяИнформация.Объект,
	     |	КонтактнаяИнформация.Тип,
	     |	КонтактнаяИнформация.Вид,
	     |	КонтактнаяИнформация.Представление,
	     |	КонтактнаяИнформация.Поле1,
	     |	КонтактнаяИнформация.Поле2,
	     |	КонтактнаяИнформация.Поле3,
	     |	КонтактнаяИнформация.Поле4,
	     |	КонтактнаяИнформация.Поле5,
	     |	КонтактнаяИнформация.Поле6,
	     |	КонтактнаяИнформация.Поле7,
	     |	КонтактнаяИнформация.Поле8,
	     |	КонтактнаяИнформация.Поле9,
	     |	КонтактнаяИнформация.Поле10,
	     |	КонтактнаяИнформация.Комментарий,
	     |	КонтактнаяИнформация.ЗначениеПоУмолчанию
	     |ИЗ
	     |	РегистрСведений.КонтактнаяИнформация КАК КонтактнаяИнформация
	     |ГДЕ
	     |	КонтактнаяИнформация.Объект = &Объект
	     |	И КонтактнаяИнформация.Вид = &Вид";
		 
		 
	//
	ПЗ = Новый ПостроительЗапроса;
	ПЗ.Текст = ТЗ;
	
	//
	ПЗ.Параметры.Вставить("Объект"	, Объект);
	ПЗ.Параметры.Вставить("Вид"		, Вид);
	
	//
	ПЗ.Выполнить();
	
	//
	ТЗ = ПЗ.Результат.Выгрузить();
	Для каждого СтрокаТЗ Из ТЗ Цикл
		
		//
		Для каждого КолонкаТЗ Из ТЗ.Колонки Цикл
			
			//
			Результат.Вставить(КолонкаТЗ.Имя, СтрокаТЗ[КолонкаТЗ.Имя]);
		
		КонецЦикла; 
	
	КонецЦикла; 
	
	//
	Возврат Результат;

КонецФункции // ()

//---АК

Функция ПолучитьСтрокуПодключенияКБухгалтерии() Экспорт
	
	Возврат ПолныеПрава.ПолучитьСтрокуПодключения_Бух();
	
КонецФункции	

//	Преобразует таблицу значений в массив.
//	Может использоваться для передачи на клиента данных, полученных
//	на сервере в виде таблицы значений в том случае, если таблица
//	значений содержит только такие значения, которые могут
//  быть переданы на клиента
//
//	Полученный массив содержит структуры, каждая из которых повторяет
//	структуру колонок таблицы значений.
//
//	Не рекомендуется использовать для преобразования таблиц значений
//	с большим количеством строк.
//
//	Параметры: 
//    ТаблицаЗначений - ТаблицаЗначений
//
//	Возвращаемое значение: 
//    Массив
//
Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
	
	Массив = Новый Массив();
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат Массив;

КонецФункции

//+++АК SHEP 2018.08.07 б/н
Функция ПолучитьИПодключитьВнешнююОбработку(НаименованиеОбработки) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ВнешниеОбработкиСсылка = Справочники.ВнешниеОбработки.НайтиПоНаименованию(НаименованиеОбработки);
	Если НЕ ЗначениеЗаполнено(ВнешниеОбработкиСсылка) Тогда Возврат Неопределено; КонецЕсли;
	
	ДвоичныеДанные = ВнешниеОбработкиСсылка.ХранилищеВнешнейОбработки.Получить();
	
	#Если Сервер Тогда
		АдресВоВременномХранилище = ПоместитьВоВременноеХранилище(ДвоичныеДанные);
		ИмяОбработки = ВнешниеОбработки.Подключить(АдресВоВременномХранилище, , Ложь);
	#Иначе
		ИмяОбработки = ПолучитьИмяВременногоФайла("epf");
		ДвоичныеДанные.Записать(ИмяОбработки); 
	#КонецЕсли
	
	Обработка = ВнешниеОбработки.Создать(ИмяОбработки);
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат Обработка;
	
КонецФункции

//+++ AK suvv 2018.10.05 ИП-00019795
Функция ЗначенияДополнительныхСвойствСтруктурнойЕдиницы(СтруктурнаяЕдиница, Знач ДополнительныеСвойства) Экспорт
	
	Если ТипЗнч(ДополнительныеСвойства) = Тип("Строка") Тогда
		Если ПустаяСтрока(ДополнительныеСвойства) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		ДополнительныеСвойства = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ДополнительныеСвойства, ",", Истина);
	КонецЕсли;
	
	МассивСвойствДляОтбора = Новый Массив;
	Для Каждого ДопСвойство Из ДополнительныеСвойства Цикл
		ДопСвойствоСсылка = ПланыВидовХарактеристик.СвойстваСтруктурныхЕдиниц[ДопСвойство];
		МассивСвойствДляОтбора.Добавить(ДопСвойствоСсылка);
	КонецЦикла;
		
	Запрос = Новый Запрос;   
	Запрос.УстановитьПараметр("СтруктурнаяЕдиница", СтруктурнаяЕдиница);
	Запрос.УстановитьПараметр("МассивСвойствДляОтбора", МассивСвойствДляОтбора);	
	Запрос.Текст = "ВЫБРАТЬ
	|	СвойстваСтруктурныхЕдиниц.Ссылка
	|ПОМЕСТИТЬ ВТ_СвойстваСЕ
	|ИЗ
	|	ПланВидовХарактеристик.СвойстваСтруктурныхЕдиниц КАК СвойстваСтруктурныхЕдиниц
	|ГДЕ
	|	СвойстваСтруктурныхЕдиниц.Ссылка В(&МассивСвойствДляОтбора)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_СвойстваСЕ.Ссылка КАК Свойство,
	|	ЕСТЬNULL(ЗначенияСвойствСтруктурныхЕдиниц.Значение, ЛОЖЬ) КАК Значение
	|ИЗ
	|	ВТ_СвойстваСЕ КАК ВТ_СвойстваСЕ
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЗначенияСвойствСтруктурныхЕдиниц КАК ЗначенияСвойствСтруктурныхЕдиниц
	|		ПО ВТ_СвойстваСЕ.Ссылка = ЗначенияСвойствСтруктурныхЕдиниц.Свойство
	|ГДЕ
	|	ЗначенияСвойствСтруктурныхЕдиниц.СтруктурнаяЕдиница = &СтруктурнаяЕдиница";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Результат = Новый Структура;
	Пока Выборка.Следующий() Цикл
		Результат.Вставить(ПланыВидовХарактеристик.СвойстваСтруктурныхЕдиниц.ПолучитьИмяПредопределенного(Выборка.Свойство), Выборка.Значение);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции //--- AK suvv
