////////////////////////////////////////////////////////////////////////////////
// Клиентские и серверные процедуры общего назначения

// Функция формирует текст в формате, необходимом для выдачи сообщений по табличной части.
//
// Параметры:
//  ИмяТЧ - Строка. Имя табличной части.
//  НомерСтроки - Число. Номер строки табличной части.
//  ИмяРеквизита - Строка. Имя реквизита.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьТекстДляВыдачиСообщенийПоСтрокеТЧ(ИмяТЧ, НомерСтроки, ИмяРеквизита) Экспорт

	Возврат ИмяТЧ + "[" + Формат(НомерСтроки - 1, "ЧН=0; ЧГ=0") + "]." + ИмяРеквизита;

КонецФункции // ПолучитьТекстДляВыдачиСообщенийПоСтрокеТЧ()
////////////////////////////////////////////////////////////////////////////////
// Клиентские и серверные процедуры общего назначения

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
//  Параметры
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                 - ЛюбаяСсылка - на объект информационной базы.
//                               Ссылка на объект информационной базы, к которому это сообщение относится,
//                               или ключ записи.
//  Поле                       - Строка - наименование реквизита формы
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы)
//  Отказ                      - Булево - Выходной параметр
//                               Всегда устанавливается в значение Истина
//
//	Примеры использования:
//
//	1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ПолеВРеквизитеФормыОбъект",
//		"Объект");
//
//	Альтернативный вариант использования в форме объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"Объект.ПолеВРеквизитеФормыОбъект");
//
//	2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ИмяРеквизитаФормы");
//
//	3. Для вывода сообщения связанного с объектом информационной базы
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
// 4. Для вывода сообщения по ссылке на объект информационной базы
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
// Случаи некорректного использования:
//  1. Передача одновременно параметров КлючДанных и ПутьКДанным
//  2. Передача в параметре КлючДанных значения типа отличного от допустимых
//  3. Установка ссылки без установки поля (и/или пути к данным)
//
Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
#Если НЕ ТонкийКлиент И НЕ ВебКлиент Тогда
	Если КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = Найти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
#Иначе
	ЭтоОбъект = (Найти(Строка(ТипЗнч(КлючДанных)), "ДанныеФормы") = 1);
#КонецЕсли
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		//mind отключил, выдает ошибку
	//	Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

// Проверяет, что почтовый адрес не содержит символов обрамления
// если символы обрамления вставлены правильно убирает их
// Параметры:
//  ПолноеИмяАдресата - строка - имя получателя
//  ПочтовыйАдрес     - строка - email адрес
// Возвращаемое значение:
//  Структура:
//   Ключ статус - булево - успех или неуспех операции
//   СообщениеОбОшибке - в случае неуспеха операции содержит сообщение об ошибке
//   Значение - структура - в случае успеха операции содержит записанную структуру почтового
//                          адреса: ключи - Адрес, Представление (строки)
//
Функция ПроверитьИПодготовитьПочтовыйАдрес(знач ПолноеИмяАдресата, знач ПочтовыйАдрес)
	
	СимволыОбрамления = "<>[]";
	
	ПочтовыйАдрес     = СокрЛП(ПочтовыйАдрес);
	ПолноеИмяАдресата = СокрЛП(ПолноеИмяАдресата);
	
	Если Лев(ПолноеИмяАдресата, 1) = "<" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = ">" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в имени адресата.'");
		КонецЕсли;
	ИначеЕсли Лев(ПолноеИмяАдресата, 1) = "[" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = "]" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в имени адресата.'");
		КонецЕсли;
	КонецЕсли;
	
	Если Лев(ПочтовыйАдрес, 1) = "<" Тогда
		Если Прав(ПочтовыйАдрес, 1) = ">" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
		КонецЕсли;
	ИначеЕсли Лев(ПочтовыйАдрес, 1) = "[" Тогда
		Если Прав(ПочтовыйАдрес, 1) = "]" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
		КонецЕсли;
	КонецЕсли;
	
	Для Индекс = 1 По СтрДлина(СимволыОбрамления) Цикл
		Если Найти(ПолноеИмяАдресата, Сред(СимволыОбрамления, Индекс, 1)) <> 0
		 Или Найти(ПочтовыйАдрес,     Сред(СимволыОбрамления, Индекс, 1)) <> 0 Тогда
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Адрес, Представление", ПочтовыйАдрес,ПолноеИмяАдресата);
	
КонецФункции

// Формирует структуру с ключами Статус (Истина) и Значение
//
Функция ЗаполнитьРезультат(знач Значение, знач Статус = Истина) Экспорт
	
	Если Статус Тогда
		Возврат Новый Структура("Статус, Значение", Истина, Значение);
	Иначе
		Возврат Новый Структура("Статус, СообщениеОбОшибке", Ложь, Значение);
	КонецЕсли;
	
КонецФункции

// Сдвигает маркер позиции пока встречается символ Символ
// возвращает номер позиции в строке, на которое установился маркер
//
Функция ПропуститьПробелы(знач Строка,
                          знач ТекущийИндекс,
                          знач ПропускаемыйСимвол)
	
	Результат = ТекущийИндекс;
	
	// убираем лишние пробелы если они есть
	Пока ТекущийИндекс < СтрДлина(Строка) Цикл
		Если Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол Тогда
			Возврат ТекущийИндекс;
		КонецЕсли;
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	Возврат ТекущийИндекс;
	
КонецФункции

//Процедуры подготовки исходных данных при проведении документов

//Обрабатывает таблицу значений: заполняет незаполненные колонки с НоменклатурнойГруппой и СтатьейЗатрат по данным других реквизитов
//Параметры:
//	ТаблицаДокумента - обрабатываемая таблица значений
//	СтруктураОбрабатываемыхКолонок - структура, содержит обрабатываемые колонки
//		Ключ - имя колонки которую необходимо заполнить
//		Значение - имя колонки, из которой необходимо взять значение для заполнения
Процедура ЗаполнитьНоменклатурнуюГруппуИСтатьюЗатратВТаблицеДокумента(ТаблицаДокумента, СтруктураОбрабатываемыхКолонок) Экспорт
	Для Каждого СтрокаТаблицыЗначений ИЗ ТаблицаДокумента Цикл
		Для Каждого КолонкаТаблицы ИЗ СтруктураОбрабатываемыхКолонок Цикл
			//Колонка в текущей строке заполнена - не требуется ее заполнять
			Если ЗначениеЗаполнено(СтрокаТаблицыЗначений[КолонкаТаблицы.Ключ]) Тогда
				Продолжить;
			КонецЕсли;
			СтрокаТаблицыЗначений[КолонкаТаблицы.Ключ] = СтрокаТаблицыЗначений[КолонкаТаблицы.Значение];
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

//Процедура добавляет в СтруктуруШапкиДокумента сведения о счетах расчетов по умолчанию, если эти данные не заполнились из шапки документа
Процедура ДобавитьВСтруктуруШапкиСведенияОСчетахРасчетов(ДокументОбъект, СтруктураШапкиДокумента) Экспорт
	Если НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете Тогда
		Возврат;
	КонецЕсли;
	//Получим структуру счетов учета расчетов: 
	//	ключ - имя реквизита шапки, значение - счет учета расчетов по умолчанию
	СтруктураСчетовУчетаРасчетов = ДокументОбъект.ЗаполнитьСтруктуруСчетовУчетаШапки();
	//Заполним недостающие свойства в структуре шапки документа 
	Для Каждого СчетУчетаРасчетов Из СтруктураСчетовУчетаРасчетов Цикл
		Если НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента[СчетУчетаРасчетов.Ключ]) Тогда
			СтруктураШапкиДокумента[СчетУчетаРасчетов.Ключ] = СчетУчетаРасчетов.Значение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

//Процедура добавляет в СтруктуруШапкиДокумента сведения о подразделении организации, 
//Если в шапке документа «Подразделение организации» оказалось незаполненным, то соответствующее свойство структуры заполняется вычисленным по подразделению
//Если Подразделение организации не удалось определить по подразделению, то выдается ошибка
Процедура ДополнитьСтруктуруШапкиПодразделениемОрганизации(Заголовок, СтруктураШапкиДокумента, Отказ) Экспорт
	Если НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента.ПодразделениеОрганизации) Тогда
		СтруктураШапкиДокумента.ПодразделениеОрганизации = РаботаСДиалогамиСервер.ПодразделениеОрганизации(СтруктураШапкиДокумента.Подразделение, СтруктураШапкиДокумента.Организация);
	КонецЕсли;	
	
	Если НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента.ПодразделениеОрганизации) Тогда
		ОбщегоНазначения.СообщитьОбОшибке(Нстр("ru = 'Не заполнено подразделение организации'"), Отказ, Заголовок);
	КонецЕсли;	
КонецПроцедуры//ДополнитьСтруктуруШапкиПодразделениемОрганизации()

//Процедура добавляет в ТаблицуДокумента сведения о подразделении организации, 
//Если в табличной части документа «Подразделение организации» оказалось незаполненным, то соответствующая колонка таблицы заполняется вычисленным значением по подразделению
//Окончательная проверка заполненности подразделения организации выполняется в модуле документа
Процедура ДополнитьТаблицуДокументаПодразделениемОрганизации(СтруктураШапкиДокумента, ТаблицаДокумента) Экспорт
	Если НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете Тогда
		Возврат;
	КонецЕсли;	
	
	Если ТаблицаДокумента.Колонки.Найти("Подразделение") <> Неопределено Тогда
		ИмяКолонкиПодразделение = "Подразделение";
		ИмяКолонкиПодразделениеОрганизации = "ПодразделениеОрганизации";
	ИначеЕсли ТаблицаДокумента.Колонки.Найти("ПодразделениеПолучатель") <> Неопределено Тогда
		ИмяКолонкиПодразделение = "ПодразделениеПолучатель";
		ИмяКолонкиПодразделениеОрганизации = "ПодразделениеОрганизацииПолучатель";
	Иначе
		Возврат;//Нет колонки с подразделением
	КонецЕсли;	
	
	Для Каждого ТекущаяСтрока Из ТаблицаДокумента Цикл
		Если НЕ ЗначениеЗаполнено(ТекущаяСтрока[ИмяКолонкиПодразделениеОрганизации]) Тогда
			ТекущаяСтрока[ИмяКолонкиПодразделениеОрганизации] = РаботаСДиалогамиСервер.ПодразделениеОрганизации(ТекущаяСтрока[ИмяКолонкиПодразделение], СтруктураШапкиДокумента.Организация);
		КонецЕсли;	
	КонецЦикла;	
КонецПроцедуры

// Проверяет правильность заполнения шапки документа по структуре шапки документа.
// Если какой-то из реквизитов шапки, влияющий на проведение, не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  ДокументОбъект             - объект проводимого документа, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  СтруктураШапкиДокумента    - структура шапки проводимого документа
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеВычисляемыхРеквизитовШапки(ДокументОбъект, СтруктураОбязательныхПолей, СтруктураШапкиДокумента, Отказ, Заголовок) Экспорт
	
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;
	
	Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

		Значение = СтруктураШапкиДокумента[КлючЗначение.Ключ];
		Если НЕ ЗначениеЗаполнено(Значение) Тогда

			Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
				ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
				СтрокаСообщения = "Не заполнен """ + СокрЛП(ПредставлениеРеквизита) + """";
			Иначе
				СтрокаСообщения = КлючЗначение.Значение;
			КонецЕсли;
			ОбщегоНазначения.СообщитьОбОшибке(СтрокаСообщения, Отказ, Заголовок);

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ПроверитьЗаполнениеШапкиДокумента()

// Снимает один элемент условного оформления, если это список значений.
// Параметры
// УсловноеОформление - условное оформление элемента формы
// ИдентификаторПользовательскойНастройки - строка - идентефикатор настройки
// Значение - значение, которое требуется удалить из списка оформления
//
Процедура СнятьУсловноеОформлениеСпискаЗначений(
						УсловноеОформление,
						знач ИдентификаторПользовательскойНастройки,
						знач Значение) Экспорт
	
	Для Каждого ЭлементУО Из УсловноеОформление.Элементы Цикл
		Если ЭлементУО.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки Тогда
			Если ЭлементУО.Отбор.Элементы.Количество() = 0 Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписокОтбора = ЭлементУО.Отбор.Элементы[0];
			Если ЭлементСписокОтбора.ПравоеЗначение = Неопределено Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписка = ЭлементСписокОтбора.ПравоеЗначение.НайтиПоЗначению(Значение);
			Если ЭлементСписка <> Неопределено Тогда
				ЭлементСписокОтбора.ПравоеЗначение.Удалить(ЭлементСписка);
			КонецЕсли;
			ЭлементСписокОтбора.ПравоеЗначение = ЭлементСписокОтбора.ПравоеЗначение;
			Возврат;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры


// Удаляет отбор у отбора системы компоновки данных
//
// Пример использования:
//   УдалитьОтборУСписка(Список.Отбор, Новый ПолеКомпоновкиДанных("Куратор"));
//
Процедура УдалитьОтборУСписка(ОтборСКД, ЛевоеЗначение) Экспорт
	
	ЭлементыОтбора = ОтборСКД.Элементы;
	
	МассивОтборов = Новый Массив;
	
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда Продолжить; КонецЕсли;
		Если ЭлементОтбора.ЛевоеЗначение = ЛевоеЗначение Тогда
			МассивОтборов.Добавить(ЭлементОтбора);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ЭлементОтбора Из МассивОтборов Цикл
		ЭлементыОтбора.Удалить(ЭлементОтбора);
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает отбор у отбора системы компоновки данных.
//
//  Пример использования:
//   ОбщегоНазначенияКлиентСервер.УстановитьОтборУСпискаНаРавенство(
//                   Список.Отбор,
//                   Новый ПолеКомпоновкиДанных("ИмяСвойства"),
//                   ЗначениеОтбора);
//
Процедура УстановитьОтборУСпискаНаРавенство(ОтборСКД,
                                            знач ЛевоеЗначение,
                                            знач ПравоеЗначение) Экспорт
	
	ЭлементыОтбора = ОтборСКД.Элементы;
	ЭлементОтбораДанных = Неопределено;
	
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		Если ЭлементОтбора.ЛевоеЗначение = ЛевоеЗначение Тогда
			Если ЭлементОтбораДанных = Неопределено Тогда
				ЭлементОтбораДанных = ЭлементОтбора;
			Иначе
				ЭлементОтбора.Использование = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ЭлементОтбораДанных = Неопределено Тогда
		ЭлементОтбораДанных = ЭлементыОтбора.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбораДанных.ЛевоеЗначение = ЛевоеЗначение;
	КонецЕсли;
	
	ЭлементОтбораДанных.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбораДанных.ПравоеЗначение = ПравоеЗначение;
	ЭлементОтбораДанных.Использование = Истина;
	
КонецПроцедуры

// Дополняет таблицу значений-приемник данными из таблицы значений-источник
//
// Параметры:
//  ТаблицаИсточник - Таблица значений - таблица из которой будут браться строки для заполнения
//  ТаблицаПриемник - Таблица значений - таблица в которую будут добавлены строки из таблицы-источника
//  
Процедура ДополнитьТаблицу(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	Для Каждого СтрокаТаблицыИсточник ИЗ ТаблицаИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(ТаблицаПриемник.Добавить(), СтрокаТаблицыИсточник);
		
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Блок функций для работы с почтовыми адресами
//

// Функция проверяет что введенная строка с e-mail адресами введена правильно
//
// Формат строки:
// Z = ИмяПользователя|[Имя Пользователя] [<]пользователь@почтовыйсервер[>], Строка = Z[<разделитель*>Z]..
// 
//   прим.: разделитель* - имеется в виду любой разделитель адресов
//
// Параметры:
// СтрокаАдресов - строка - правильная строка с почтовыми адресами
//
// Возвращаемое значение:
// Структура
// ключ Статус - булево - успех или неуспех преобразования
// в случае успеха содержит ключ Значение:
//           Массив структур, где
//                  Адрес- e-mail получателя
//                  Представление   - имя получателя
// в случае неуспеха содержит ключ СообщениеОбОшибке - строка
//
//  ВАЖНО: Функция возвращает массив структур, в которых одно поле (любое)
//         может быть незаполнено. Может использоваться различными
//         подсистемами для собственного сопоставления имени пользователя
//         некому e-mail адресу. Поэтому, необходимо перед непосредственной
//         отправкой проверить, что поле почтового адреса заполнено.
//
Функция РазобратьСтрокуСПочтовымиАдресами(знач СтрокаАдресов) Экспорт
	
	Результат = Новый Массив;
	
	НедопустимыеСимволы = "!#$%^&*()+-`~|\/=";
	ДопустимыеСимволыEMAIL = "abcdefghijklmnopqrstuvwxyz.-_0123456789";
	СимволыРазделители = ";,";
	
	Индекс = 1;               // номер обрабатываемого символа
	Накопитель = "";          // накопитель символов, после анализа перемещается либо в полное имя
	                          // либо в почтовый адрес
	ПолноеИмяАдресата = "";   // переменная, накапливающая имя адресата
	ПочтовыйАдрес = "";       // переменная, накапливающая e-mail адрес
	СтадияРазбора = 1; // 1 - формирование полного имени: ожидаются любые допустимые символы имени адресата
	                   // 2 - формирование почтового адреса: ожидаются любые допустимые символы email адреса
	                   // 3 - завершение формирования очередного почтового адреса - ожидаются символы разделители либо пробелы
	
	Пока Индекс <= СтрДлина(СтрокаАдресов) Цикл
		
		Символ = Сред(СтрокаАдресов, Индекс, 1);
		
		Если      Символ = " " Тогда
			Индекс = ? ((ПропуститьПробелы(СтрокаАдресов, Индекс, " ") - 1) > Индекс,
			             ПропуститьПробелы(СтрокаАдресов, Индекс, " ") - 1,
			             Индекс);
			Если      СтадияРазбора = 1 Тогда
				ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель + " ";
			ИначеЕсли СтадияРазбора = 2 Тогда
				ПочтовыйАдрес = Накопитель;
				СтадияРазбора = 3;
			КонецЕсли;
			Накопитель = "";
		ИначеЕсли Символ = "@" Тогда
			Если      СтадияРазбора = 1 Тогда
				СтадияРазбора = 2;
				Накопитель = Накопитель + Символ;
			ИначеЕсли СтадияРазбора = 2 Тогда
				ВызватьИсключение НСтр("ru = 'Неверный формат почтового адреса.'");
			ИначеЕсли СтадияРазбора = 3 Тогда
				ВызватьИсключение НСтр("ru = 'Неверный формат почтового адреса.'");
			КонецЕсли;
		ИначеЕсли Найти(СимволыРазделители, Символ) > 0 Тогда
			
			Если      СтадияРазбора = 1 Тогда
				ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
			ИначеЕсли СтадияРазбора = 2 Тогда
				ПочтовыйАдрес = Накопитель;
			КонецЕсли;
			
			СтадияРазбора = 1;
			
			Если Не (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
				Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
			КонецЕсли;
			
			ПочтовыйАдрес = "";
			ПолноеИмяАдресата = "";
			Накопитель = "";
		Иначе
			Если Найти(НедопустимыеСимволы, Символ) > 0 Тогда
				ВызватьИсключение НСтр("ru = 'Недопустимые символы в почтовом адресе.'");
			КонецЕсли;
			
			Накопитель = Накопитель + Символ;
		КонецЕсли;
		
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Если      СтадияРазбора = 1 Тогда
		ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
	ИначеЕсли СтадияРазбора = 2 Тогда
		ПочтовыйАдрес = Накопитель;
	КонецЕсли;

	Если Не (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
		Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#Если Не ВебКлиент Тогда
// Генерирует имя временного каталога возвращает путь к нему
//
Функция ПолучитьИмяКаталога(знач Идентификатор) Экспорт
	
	Индекс = 0;
	
	Пока Истина Цикл
		
		ПутьККаталогу = КаталогВременныхФайлов () + Идентификатор + строка(Индекс) + "\";
		КаталогНаДиске = Новый Файл(ПутьККаталогу);
		Если НЕ КаталогНаДиске.Существует() Тогда
			СоздатьКаталог(ПутьККаталогу);
			Возврат ПутьККаталогу;
		КонецЕсли;
		Индекс = Индекс + 1;
		
	КонецЦикла;
	
КонецФункции
#КонецЕсли

// Возвращает дату из строки в формате ЧЧ.ММ.ГГГГ
//
Функция ПолучитьДатуИзСтроки(Строка) Экспорт
	
	Возврат Дата(Сред(Строка, 7, 4)+Сред(Строка, 4, 2)+Лев(Строка, 2));
	
КонецФункции

// Получает представление сообщения ошибке на основании Информации об ошибке
// Может вызываться в операторных скобках Попытка ... Исключение ... КонецПопытки;
// для получения сообщения об ошибке.
//
Функция ПолучитьПредставлениеОписанияОшибки(ИнформацияОбОшибке) Экспорт
	
	Возврат ? (ИнформацияОбОшибке.Причина = Неопределено, ИнформацияОбОшибке.Описание, ИнформацияОбОшибке.Причина.Описание);
	
КонецФункции

// Составляет полное имя файла из имени каталога и имени файла.
//
// Параметры
//  ИмяКаталога  – Строка, содержащая путь к каталогу файла на диске.
//  ИмяФайла     – Строка, содержащая имя файла, без имени каталога.
//
// Возвращаемое значение:
//   Строка – полное имя файла с учетом каталога.
//
Функция ПолучитьИмяФайла(Знач ИмяКаталога, Знач ИмяФайла) Экспорт

	Если Не ПустаяСтрока(ИмяФайла) Тогда
		
		Слэш = "";
		Если (Прав(ИмяКаталога, 1) <> "\") И (Прав(ИмяКаталога, 1) <> "/") Тогда
			Слэш = ?(Найти(ИмяКаталога, "\") = 0, "/", "\");
		КонецЕсли;
		
		Возврат ИмяКаталога + Слэш + ИмяФайла;
		
	Иначе
		
		Возврат ИмяКаталога;
		
	КонецЕсли;

КонецФункции

Процедура УдалитьКаталогСФайлами(Путь) Экспорт
	
	Каталог = Новый Файл(Путь);
	
	Если Каталог.Существует() Тогда
		УдалитьФайлы(Путь);
	КонецЕсли;
	
КонецПроцедуры

// Добавляет к переданному пути каталога конечный символ-разделитель,
// если необходимо.
//
// Параметры
//  ПутьКаталога  - Строка - путь к каталогу
//
// Возвращаемое значение:
//   Строка   - путь к каталогу с конечным символом-разделителем.
//
// Примеры использования:
//    Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог"); // возвращает "C:\Мой каталог\"
//    Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог\"); // возвращает "C:\Мой каталог\"
//    Результат = ДобавитьКонечныйРазделительПути("ftp://Мой каталог"); // возвращает "ftp://Мой каталог/"
//
Функция ДобавитьКонечныйРазделительПути(Знач ПутьКаталога) Экспорт
	Если ПустаяСтрока(ПутьКаталога) Тогда
		Возврат ПутьКаталога;
	КонецЕсли;
	
	ДобавляемыйСимвол = "\";
	Если Найти(ПутьКаталога, "/") > 0 Тогда
		ДобавляемыйСимвол = "/";
	КонецЕсли;
	
	Длина = СтрДлина(ПутьКаталога);
	Если Длина = 0 Тогда
		Возврат ДобавляемыйСимвол;
	ИначеЕсли Сред(ПутьКаталога, Длина, 1) <> ДобавляемыйСимвол Тогда
		Возврат ПутьКаталога + ДобавляемыйСимвол;
	Иначе 
		Возврат ПутьКаталога;
	КонецЕсли;
КонецФункции

Функция РасписаниеВСтруктуру(Знач Расписание) Экспорт
	
	ЗначениеРасписания = Расписание;
	Если ЗначениеРасписания = Неопределено Тогда
		ЗначениеРасписания = Новый РасписаниеРегламентногоЗадания();
	КонецЕсли;
	СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";
	Результат = Новый Структура(СписокПолей);
	ЗаполнитьЗначенияСвойств(Результат, ЗначениеРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для каждого РасписаниеДля Из Расписание.ДетальныеРасписанияДня Цикл
		ДетальныеРасписанияДня.Добавить(РасписаниеВСтруктуру(РасписаниеДля));
	КонецЦикла;
	Результат.Вставить("ДетальныеРасписанияДня", ДетальныеРасписанияДня);
	Возврат Результат;
	
КонецФункции		
	
// Преобразует структуру в РасписаниеРегламентногоЗадания.
//
// Параметры:
//  СтруктураРасписания - Структура
// 
// Возвращаемое значение:
//  РасписаниеРегламентногоЗадания
//
Функция СтруктураВРасписание(Знач СтруктураРасписания) Экспорт
	
	Если СтруктураРасписания = Неопределено Тогда
		Возврат Новый РасписаниеРегламентногоЗадания();
	КонецЕсли;
	СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";
	Результат = Новый РасписаниеРегламентногоЗадания;
	ЗаполнитьЗначенияСвойств(Результат, СтруктураРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для каждого Расписание Из СтруктураРасписания.ДетальныеРасписанияДня Цикл
		  ДетальныеРасписанияДня.Добавить(СтруктураВРасписание(Расписание));
	КонецЦикла;
	Результат.ДетальныеРасписанияДня = ДетальныеРасписанияДня;  
	Возврат Результат;
	
КонецФункции		


Процедура НайтиРекурсивно(КоллекцияЭлементов, МассивЭлементов, СпособПоиска, ЗначениеПоиска)
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			
			Если СпособПоиска = 1 Тогда
				Если ЭлементОтбора.ЛевоеЗначение = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			ИначеЕсли СпособПоиска = 2 Тогда
				Если ЭлементОтбора.Представление = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			КонецЕсли;
		Иначе
			
			НайтиРекурсивно(ЭлементОтбора.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
			
			Если СпособПоиска = 2 И ЭлементОтбора.Представление = ЗначениеПоиска Тогда
				МассивЭлементов.Добавить(ЭлементОтбора);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Поиск элементов и групп отбора динамического списка
// Параметры:
//  ОбластьПоиска - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - имя поля компоновки (не используется для групп)
//  Представление - представление поля компоновки
//  Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
//
Функция НайтиЭлементыИГруппыОтбора(знач ОбластьПоиска,
									знач ИмяПоля = Неопределено,
									знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Возврат МассивЭлементов;
	
КонецФункции

// Добавление группы отбора
// Параметры:
//  КоллекцияЭлементов - контейнер с элементами и группами отбора, например
//                      Список.Отбор.Элементы или группа в отборе
//  ТипГруппы - ТипГруппыЭлементовОтбораКомпоновкиДанных - тип группы
//  Представление строка - представление группы
//
Функция СоздатьГруппуЭлементовОтбора(Знач КоллекцияЭлементов, Представление, ТипГруппы) Экспорт
	
	Если ТипЗнч(КоллекцияЭлементов) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		КоллекцияЭлементов = КоллекцияЭлементов.Элементы;
	КонецЕсли;
	
	ГруппаЭлементовОтбора = НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление);
	Если ГруппаЭлементовОтбора = Неопределено Тогда
		ГруппаЭлементовОтбора = КоллекцияЭлементов.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	Иначе
		ГруппаЭлементовОтбора.Элементы.Очистить();
	КонецЕсли;
	
	ГруппаЭлементовОтбора.Представление    = Представление;
	ГруппаЭлементовОтбора.Применение       = ТипПримененияОтбораКомпоновкиДанных.Элементы;
	ГруппаЭлементовОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	ГруппаЭлементовОтбора.ТипГруппы        = ТипГруппы;
	ГруппаЭлементовОтбора.Использование    = Истина;
	
	Возврат ГруппаЭлементовОтбора;
	
КонецФункции

// Добавление элемента компоновки в контейнер элементов компоновки
// Параметры:
//  ОбластьДобавления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - строка - имя для поля компоновки данных
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
//  ПравоеЗначение - произвольный
//  Представление - представление элемента компоновки данных
//  Использование - булево - использование элемента
//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Функция ДобавитьЭлементКомпоновки(ОбластьДобавления,
									знач ИмяПоля,
									знач ВидСравнения,
									знач ПравоеЗначение = Неопределено,
									знач Представление  = Неопределено,
									знач Использование  = Неопределено,
									знач РежимОтображения = Неопределено) Экспорт
	
	Элемент = ОбластьДобавления.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	Элемент.ВидСравнения = ВидСравнения;
	
	Если РежимОтображения = Неопределено Тогда
		Элемент.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	Иначе
		Элемент.РежимОтображения = РежимОтображения;
	КонецЕсли;
	
	Если ПравоеЗначение <> Неопределено Тогда
		Элемент.ПравоеЗначение = ПравоеЗначение;
	КонецЕсли;
	
	Если Представление <> Неопределено Тогда
		Элемент.Представление = Представление;
	КонецЕсли;
	
	Если Использование <> Неопределено Тогда
		Элемент.Использование = Использование;
	КонецЕсли;
	
	Возврат Элемент;
	
КонецФункции

// Изменение элементов отбора
// Параметры
//  ИмяПоля - строка - имя поля компоновки
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
//  ПравоеЗначение - произвольный
//  Представление - строка - представление элемента компоновки данных
//  Использование - булево - использование элемента
//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Функция ИзменитьЭлементыОтбора(ОбластьПоиска,
								знач ИмяПоля = Неопределено,
								знач Представление = Неопределено,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Использование = Неопределено,
								знач РежимОтображения = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если ИмяПоля <> Неопределено Тогда
			Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
		КонецЕсли;
		Если Представление <> Неопределено Тогда
			Элемент.Представление = Представление;
		КонецЕсли;
		Если Использование <> Неопределено Тогда
			Элемент.Использование = Использование;
		КонецЕсли;
		Если ВидСравнения <> Неопределено Тогда
			Элемент.ВидСравнения = ВидСравнения;
		КонецЕсли;
		Если ПравоеЗначение <> Неопределено Тогда
			Элемент.ПравоеЗначение = ПравоеЗначение;
		КонецЕсли;
		Если РежимОтображения <> Неопределено Тогда
			Элемент.РежимОтображения = РежимОтображения;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивЭлементов.Количество();
	
КонецФункции

// Поиск элементов и групп отбора динамического списка
// Параметры:
//  ОбластьУдаления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - имя поля компоновки (не используется для групп)
//  Представление - представление поля компоновки
//  Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
//
Процедура УдалитьЭлементыГруппыОтбора(знач ОбластьУдаления,
										знач ИмяПоля = Неопределено,
										знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьУдаления.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если Элемент.Родитель = Неопределено Тогда
			ОбластьУдаления.Элементы.Удалить(Элемент);
		Иначе
			Элемент.Родитель.Элементы.Удалить(Элемент);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Используется для создания элемента отбора или, если таковой не найден,
// установления существующим элементам свойств
// Параметры
//  ОбластьПоискаДобавления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - строка - имя для поля компоновки данных (заполняется всегда)
// Устанавливаемые поля:
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
//  ПравоеЗначение - произвольный
//  Представление - представление элемента компоновки данных
//  Использование - булево - использование элемента
//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Процедура УстановитьЭлементОтбора(ОбластьПоискаДобавления,
								знач ИмяПоля,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Представление = Неопределено,
								знач Использование = Неопределено,
								знач РежимОтображения = Неопределено) Экспорт
	
	ЧислоИзмененных = ИзменитьЭлементыОтбора(ОбластьПоискаДобавления, ИмяПоля, Представление,
							ПравоеЗначение, ВидСравнения, Использование, РежимОтображения);
	
	Если ЧислоИзмененных = 0 Тогда
		Если ВидСравнения = Неопределено Тогда
			ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		КонецЕсли;
		ДобавитьЭлементКомпоновки(ОбластьПоискаДобавления, ИмяПоля, ВидСравнения,
								ПравоеЗначение, Представление, Использование, РежимОтображения);
	КонецЕсли;
	
КонецПроцедуры

// Добавить или заменить существующий элемент отбора динамического списка.
//
// Параметры:
//  Отбор                   - ОтборКомпоновкиДанных - отбор элементов в динамическом списке
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда)
//  ПравоеЗначение          - произвольный - сравниваемое значение
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения
//  Представление           - Строка - представление элемента компоновки данных
//  Использование           - Булево - использование элемента
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Процедура УстановитьНедоступныйЭлементОтбора(ОтборКД,
											ИмяПоля,
											ПравоеЗначение,
											ВидСравнения = Неопределено,
											Использование = Истина,
											Представление = Неопределено) Экспорт
	
	Если ВидСравнения = Неопределено Тогда
		ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	КонецЕсли;
	
	РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	
	УстановитьЭлементОтбора(ОтборКД, ИмяПоля, ПравоеЗначение, ВидСравнения, Представление, Использование, РежимОтображения);
	
КонецПроцедуры

// Добавить или заменить существующий элемент отбора динамического списка.
//
// Параметры:
//  ДинамическийСписок      - ДинамическийСписок - реквизит формы, для которого требуется установить отбор.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда)
//  ПравоеЗначение          - произвольный - сравниваемое значение
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения
//  Представление           - Строка - представление элемента компоновки данных
//  Использование           - Булево - использование элемента
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Процедура УстановитьЭлементОтбораДинамическогоСписка(ДинамическийСписок,
													ИмяПоля,
													ПравоеЗначение = Неопределено,
													ВидСравнения = Неопределено,
													Представление = Неопределено,
													Использование = Неопределено,
													РежимОтображения = Неопределено) Экспорт
	
	Если РежимОтображения = Неопределено Тогда
		РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	КонецЕсли;
	
	Если РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
		ОтборДинамическогоСписка = ДинамическийСписок.КомпоновщикНастроек.ФиксированныеНастройки.Отбор;
	Иначе
		ОтборДинамическогоСписка = ДинамическийСписок.КомпоновщикНастроек.Настройки.Отбор;
	КонецЕсли;
	
	УстановитьЭлементОтбора(
		ОтборДинамическогоСписка,
		ИмяПоля,
		ПравоеЗначение,
		ВидСравнения,
		Представление,
		Использование,
		РежимОтображения);
	
КонецПроцедуры

// Устанавливает значение Значение параметра ИмяПараметра динамического списка Список 
// или отключает его использование в зависимости от признака Использование.
//
Процедура УстановитьПараметрДинамическогоСписка(Список, ИмяПараметра, Значение, Использование = Истина) Экспорт
	
	Если Использование Тогда
		Список.Параметры.УстановитьЗначениеПараметра(ИмяПараметра, Значение);
	Иначе
		ЗначениеПараметра = Список.Параметры.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
		Если ЗначениеПараметра <> Неопределено Тогда
			ЗначениеПараметра.Значение = Значение;
			ЗначениеПараметра.Использование = Ложь;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры 

// Получает значение реквизита формы
// Параметры:
//		Форма
//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления"
Функция ПолучитьРеквизитФормыПоПути(Форма, ПутьРеквизита) Экспорт
	
	МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 по МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	
	Возврат Объект[ПоследнееПоле];
	
КонецФункции

// Устанавливает значение реквизиту формы
// Параметры:
//		Форма
//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления"
//		Значение
Процедура УстановитьРеквизитФормыПоПути(Форма, ПутьРеквизита, Значение, ТолькоЕслиНеЗаполнен = Ложь) Экспорт
	
	МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 по МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	Если НЕ ТолькоЕслиНеЗаполнен ИЛИ НЕ ЗначениеЗаполнено(Объект[ПоследнееПоле]) Тогда
		Объект[ПоследнееПоле] = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Выполняет поиск элемента отбора в коллекции по заданному представлению
//
// Параметры:
//  КоллекцияЭлементов - контейнер с элементами и группами отбора, например
//                      Список.Отбор.Элементы или группа в отборе
//  Представление строка - представление группы
// 
Функция НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление) Экспорт
	
	ВозвращаемоеЗначение = Неопределено;
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		Если ЭлементОтбора.Представление = Представление Тогда
			ВозвращаемоеЗначение = ЭлементОтбора;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ВозвращаемоеЗначение
	
КонецФункции

Функция ТаблицаЗначенийВТабличныйДокумент(ТЗ) Экспорт
    
	Т=Новый ТабличныйДокумент();
	
	//выводим шапку
	Для Каждого Кол ИЗ ТЗ.Колонки Цикл
		Заг=СокрЛП(Кол.Заголовок);
		Заг=?(Заг="",Кол.Имя, Заг);
		Т.Область("R1C"+Формат(1+ТЗ.Колонки.Индекс(Кол), "ЧГ=")).Текст=Заг;
	КонецЦикла;
	
	Для Каждого Стр ИЗ ТЗ Цикл
		//выводим строки
		Для Каждого Кол ИЗ ТЗ.Колонки Цикл
			Т.Область("R"+Формат(2+ТЗ.Индекс(Стр), "ЧГ=")+"C"+Формат(1+ТЗ.Колонки.Индекс(Кол), "ЧГ=")).Текст=Стр[Кол.Имя];
		КонецЦикла;
	КонецЦикла;
	//Если П.Показывать Тогда
	//	Т.Показать();
	//КонецЕсли;
	
	Возврат Т;
	
КонецФункции

// Функция выполняет формирование изображения штрихкода.
// 
// Параметры: 
//  ВнешняяКомпонента, ПараметрыШтрихкода
// 
// Возвращаемое значение: 
//  Картинка - Картинка со сформированным штрихкодом или НЕОПРЕДЕЛЕНО
Функция ПолучитьКартинкуШтрихкода(ВнешняяКомпонента, ПараметрыШтрихкода) Экспорт
	
	// Зададим размер картинки
	ВнешняяКомпонента.Ширина = ПараметрыШтрихкода.Ширина;
	ВнешняяКомпонента.Высота = ПараметрыШтрихкода.Высота;
	
	// Разрешим компоненте самой определять тип кода
	ВнешняяКомпонента.АвтоТип = Ложь;
	ВнешняяКомпонента.ТипКода         = ПараметрыШтрихкода.ТипКода;
	ВнешняяКомпонента.ОтображатьТекст = ПараметрыШтрихкода.ОтображатьТекст;
	Попытка
		ВнешняяКомпонента.РазмерШрифта = ПараметрыШтрихкода.РазмерШрифта;
	Исключение
		
	КонецПопытки;
	
	// Или установим код EAN-13
	// ВнешняяКомпонента.ТипКода = 1;
	//
	// Тип смотрим в документации на внешнуюю компоненту
	
	// Если код содержит контрольный символ, обязательно указываем
	ВнешняяКомпонента.СодержитКС = СтрДлина(ПараметрыШтрихкода.Штрихкод) = 13;
	
	// Если отображать контрольный символ не нужно
	// ВнешняяКомпонента.ВидимостьКС = Ложь;
	
	// Формируем картинку штрихкода
	ВнешняяКомпонента.ЗначениеКода = ПараметрыШтрихкода.Штрихкод;
	
	// Если установленная нами ширина меньше минимально допустимой для этого штрихкода
	Если ВнешняяКомпонента.Ширина < ВнешняяКомпонента.МинимальнаяШиринаКода Тогда
		// Скорректируем ширину
		ВнешняяКомпонента.Ширина = ВнешняяКомпонента.МинимальнаяШиринаКода + 10;
	КонецЕсли;
	
	// Сформируем картинку
	ДвоичныеДанныеКартинки = ВнешняяКомпонента.ПолучитьШтрихкод();
	
	// Если картинка сформировалась
	Если ДвоичныеДанныеКартинки <> Неопределено Тогда
		// Формируем из двоичных данных
		Возврат Новый Картинка(ДвоичныеДанныеКартинки);
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

//+++АК LATV 2018.09.26 ИП-00019950
Процедура ДобавитьQRКодВОбластьДокумента(Область, Ссылка, ЕстьШтрихкод = Ложь) Экспорт

	Штрихкод = ПолучитьШтрихкодПоУИНу(Ссылка);
	
	ДанныеQRКода = УправлениеПечатью.ДанныеQRКода(Штрихкод, 0, 190);
	Если ТипЗнч(ДанныеQRКода) = Тип("ДвоичныеДанные") Тогда
		
		КартинкаQRКода = Новый Картинка(ДанныеQRКода);
		
		Рисунок = Область.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Картинка);
		Рисунок.Имя			= "QrКод";
		Рисунок.Ширина		= 20;
		Рисунок.Высота		= 20;
		Рисунок.Картинка	= КартинкаQRКода;
		
		Если ЕстьШтрихкод Тогда
			Рисунок.Лево = 140;
		КонецЕсли;
		
	ИначеЕсли Не ЕстьШтрихкод Тогда
		ДобавитьШтрихкодВОбластьДокумента(Область, Ссылка, Ложь);
		
	КонецЕсли;

КонецПроцедуры

//+++АК LATV 2018.09.26 ИП-00019950
Процедура ДобавитьШтрихкодВОбластьДокумента(Область, Ссылка, ДобавитьQRКод = Истина) Экспорт

	Штрихкод = ПолучитьШтрихкодПоУИНу(Ссылка);
	
	ВнешняяКомпонента = ПодключитьВнешнююКомпонентуПечатиШтрихкода();
	
	Параметры = Новый Структура();
	Параметры.Вставить("Ширина",			130);
	Параметры.Вставить("Высота",			20);
	Параметры.Вставить("ТипКода",			4);
	Параметры.Вставить("ОтображатьТекст",	Ложь);
	Параметры.Вставить("РазмерШрифта",		14);
	Параметры.Вставить("Штрихкод",			Штрихкод);
	КартинкаШтрихкода = ПолучитьКартинкуШтрихкода(ВнешняяКомпонента, Параметры);
	
	Рисунок = Область.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Картинка);
	Рисунок.Имя			= "ШтрихКод";
	Рисунок.Ширина		= 130;
	Рисунок.Высота		= 20;
	Рисунок.Картинка	= КартинкаШтрихкода;
	
	Если ДобавитьQRКод Тогда
		ДобавитьQRКодВОбластьДокумента(Область, Ссылка, Истина);
	КонецЕсли;

КонецПроцедуры

Функция ПолучитьШтрихкодПоУИНу(Ссылка) Экспорт
	Возврат ПрефиксШтрихкодаДляДокумента(Ссылка)+ЧисловойКодПоСсылке(Ссылка);
КонецФункции

Функция ПрефиксШтрихкодаДляДокумента(Ссылка)
	Если ТипЗнч(Ссылка)=Тип("ДокументСсылка.ЗаказПоставщику") Тогда
		Возврат "91";
	ИначеЕсли ТипЗнч(Ссылка)=Тип("ДокументСсылка.ПриходныйОрдерСклад") Тогда
		Возврат "92";
	ИначеЕсли ТипЗнч(Ссылка)=Тип("ДокументСсылка.РасходныйОрдерСклад") Тогда
		Возврат "93";
	ИначеЕсли ТипЗнч(Ссылка)=Тип("ДокументСсылка.ПеремещениеСклад") Тогда
		Возврат "94";
	ИначеЕсли ТипЗнч(Ссылка)=Тип("ДокументСсылка.ЗаданиеНаИнвентаризацию") Тогда
		Возврат "90";
	ИначеЕсли ТипЗнч(Ссылка)=Тип("ДокументСсылка.МаршрутныйЛист") Тогда
		Возврат "89";
	ИначеЕсли ТипЗнч(Ссылка)=Тип("ДокументСсылка.ЗаданиеНаПеремещение") Тогда
		Возврат "87";
	ИначеЕсли ТипЗнч(Ссылка)=Тип("ДокументСсылка.ЗаданиеНаРазборку") Тогда
		Возврат "95";
	КонецЕсли;
	Возврат "00";
КонецФункции	

Функция ЧисловойКодПоСсылке(Ссылка) Экспорт
	ШестнадчатиричноеЧисло = СтрЗаменить(Строка(Ссылка.УникальныйИдентификатор()),"-","");
	Возврат ПреобразоватьИзШестнадцатиричнойСистемыСчисленияВДесятичноеЧисло(ШестнадчатиричноеЧисло);
КонецФункции

Функция ПреобразоватьДесятичноеЧислоВШестнадцатиричнуюСистемуСчисления(Знач ДесятичноеЧисло) Экспорт
	
	Результат = "";
	
	Пока ДесятичноеЧисло > 0 цикл
		ОстатокОтДеления = ДесятичноеЧисло % 16;
		ДесятичноеЧисло  = (ДесятичноеЧисло - ОстатокОтДеления) / 16;
		Результат        = Сред("0123456789abcdef", ОстатокОтДеления + 1, 1) + Результат;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ПреобразоватьИзШестнадцатиричнойСистемыСчисленияВДесятичноеЧисло(Знач Значение)
	
	Значение = НРег(Значение);
	ДлинаСтроки = СтрДлина(Значение);
	
	Результат = 0;
	Для НомерСимвола = 1 По ДлинаСтроки Цикл
		Результат = Результат * 16 + Найти("0123456789abcdef", Сред(Значение, НомерСимвола, 1)) - 1;
	КонецЦикла;
	
	Возврат Формат(Результат, "ЧГ=0");
	
КонецФункции

Функция ПодключитьВнешнююКомпонентуПечатиШтрихкода() Экспорт
	
	// В зависимости от типа платформы подключим соответствующую внешнюю компоненту
	ПодключениеВыполнено = Неопределено;
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Если СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86 Тогда
		ПодключениеВыполнено = ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаПечатиШтрихкодовWindows32", "КартинкаШтрихкода", ТипВнешнейКомпоненты.Native);
	ИначеЕсли СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
		ПодключениеВыполнено = ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаПечатиШтрихкодовWindows64", "КартинкаШтрихкода", ТипВнешнейКомпоненты.Native);
	КонецЕсли;
	
	// Создадим объект внешней компоненты
	Если ПодключениеВыполнено Тогда
		ВнешняяКомпонента = Новый("AddIn.КартинкаШтрихкода.Barcode");
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	// Если нет возможности рисовать
	Если НЕ ВнешняяКомпонента.ГрафикаУстановлена Тогда
		// То картинку сформировать не сможем
		Возврат Неопределено;
	Иначе
		
		// Установим основные параметры компоненты
		
		// Если в системе установлен шрифт Tahoma
		Если ВнешняяКомпонента.НайтиШрифт("Tahoma") = Истина Тогда
			// Выбираем его как шрифт для формирования картинки
			ВнешняяКомпонента.Шрифт = "Tahoma";
		Иначе
			
			// Шрифт Tahoma в системе отсутствует
			// Обойдем все доступные компоненте шрифты
			Для Сч = 0 По ВнешняяКомпонента.КоличествоШрифтов -1 Цикл
				// Получим очередной шрифт, доступный компоненте
				ТекущийШрифт = ВнешняяКомпонента.ШрифтПоИндексу(Сч);
				// Если шрифт доступен
				Если ТекущийШрифт <> Неопределено Тогда
					// Они и будет шрифтом для формирования штри-кода
					ВнешняяКомпонента.Шрифт = ТекущийШрифт;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		// Утановим размер шрифта
		ВнешняяКомпонента.РазмерШрифта = 12;
		
		Возврат ВнешняяКомпонента;
		
	КонецЕсли;
	
КонецФункции

Процедура ПроверкаРеквизитовПомеченныхНаУдаление(ДокументОбъект) Экспорт
	
	МассивПоиска = Новый Массив;
	
	МассивПоиска.Добавить(Тип("СправочникСсылка.СтатьиДвиженияДенежныхСредств"));
	МассивПоиска.Добавить(Тип("СправочникСсылка.СтатьиДоходовРасходов"));
	
	Реквизиты = ДокументОбъект.Метаданные().Реквизиты;	
	Для каждого Реквизит из Реквизиты Цикл
		
		ТипРеквизита = ТипЗнч(ДокументОбъект[Реквизит.Имя]);
		ТипПроверка = МассивПоиска.Найти(ТипРеквизита) <> Неопределено;	
		Если ТипПроверка тогда
			Если ДокументОбъект[Реквизит.Имя].ПометкаУдаления Тогда
				ДокументОбъект[Реквизит.Имя]=Неопределено;
				Сообщить("Очищены реквизиты, помеченные на удаление");
			КонецЕсли;	
		КонецЕсли;	
		
	КонецЦикла;
	
	ТабличныеЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти;	
	Для каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
		
		Реквизиты = ТабличнаяЧасть.Реквизиты;
		Для каждого СтрокаТЧ из ДокументОбъект[ТабличнаяЧасть.Имя] Цикл	
			Для каждого Реквизит из Реквизиты Цикл	
				ТипРеквизита = ТипЗнч(СтрокаТЧ[Реквизит.Имя]);
				ТипПроверка = МассивПоиска.Найти(ТипРеквизита) <> Неопределено;	
				Если ТипПроверка тогда
					Если СтрокаТЧ[Реквизит.Имя].ПометкаУдаления Тогда
						СтрокаТЧ[Реквизит.Имя]=Неопределено;
						Сообщить("Очищены реквизиты в табличной части, помеченные на удаление");
					КонецЕсли;	
				КонецЕсли;	
				
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;	
	
КонецПроцедуры	


#Если ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ Сервер Тогда
Процедура ОтправитьПисьмоПоПочте(СтруктураНовогоПисьма)  Экспорт
	КолАдр=СтруктураНовогоПисьма.Кому.Количество();
	КолИтер=Цел(КолАдр/21)+1;
	УчетнаяЗапись = Справочники.УчетныеЗаписиЭлектроннойПочты.НайтиПоНаименованию("no-reply@vkusvill.ru");
	Профиль = УправлениеЭлектроннойПочтой.ПолучитьИнтернетПочтовыйПрофиль(УчетнаяЗапись);
	Почта = Новый ИнтернетПочта;
	Почта.Подключиться(Профиль);
	Для Ит=1 По КолИтер Цикл
		//УчетнаяЗапись = ОбщиеПроцедуры.ПолучитьУчетнуюЗаписьДляРассылки();
		
		СпАдресов=Новый СписокЗначений;
		
		Для Сч= (Ит-1)*20+1 По Мин(СтруктураНовогоПисьма.Кому.Количество(),Ит*20) Цикл
			ЭлСп=СтруктураНовогоПисьма.Кому[Сч-1];
			МассивАдресов=Справочники.Контрагенты.РазложитьСтрокуВМассивПодстрок(ЭлСп.Значение,";");	
			Для каждого Эл Из МассивАдресов Цикл
				Если ЗначениеЗаполнено(Эл) Тогда
					СпАдресов.Добавить(Сокрлп(Эл));
				КонецЕсли; 
			КонецЦикла; 
		КонецЦикла;
		Письмо = Новый ИнтернетПочтовоеСообщение;
		
		Письмо.Тема = СтруктураНовогоПисьма.Тема;
		Письмо.ИмяОтправителя = ""+УчетнаяЗапись+"";
		Письмо.ИмяОтправителя  = ""+СокрЛП(УчетнаяЗапись)+"";
		Письмо.Отправитель     = ""+СокрЛП(УчетнаяЗапись)+"";
		
		ТабДок=СтруктураНовогоПисьма.Тело;
		
		ТекстСообщения = Письмо.Тексты.Добавить();
		ТекстСообщения.Текст     = 	ТабДок;
		ТекстСообщения.ТипТекста = ТипТекстаПочтовогоСообщения.ПростойТекст;
		
		//+++АК LAGP 2018.04.05 Добавлена работа с параметром "ТипТекста" из структуры
		Если СтруктураНовогоПисьма.Свойство("ТипТекста") Тогда
			ТекстСообщения.ТипТекста = СтруктураНовогоПисьма.ТипТекста;	
		КонецЕсли;	
		//---АК LAGP
		
		Если СтруктураНовогоПисьма.Свойство("СписокФайловВложений") Тогда //+++АК LAGP 2018.07.13 б/н Добавлена проверка на наличие свойства
			Для каждого Эл1 Из СтруктураНовогоПисьма.СписокФайловВложений Цикл
				Письмо.Вложения.Добавить(Эл1.Значение.ИмяФайла);
			КонецЦикла;
		КонецЕсли;	
		
		Для каждого Адрес Из СпАдресов Цикл
			Получатель = Письмо.Получатели.Добавить();
			Получатель.Адрес           = Адрес.Значение;
		КонецЦикла;
		Почта.Послать(Письмо);
	КонецЦикла; 	
	Почта.Отключиться();
КонецПроцедуры

Функция ПолучитьТаблицуСчетовУчетаНоменклатур(МассивТовары = Неопределено, ДатаСреза = Неопределено) Экспорт
	
	Запрос = Новый Запрос();
	Если МассивТовары = Неопределено Тогда
		Запрос.УстановитьПараметр("ДатаСреза", ?(НЕ ЗначениеЗаполнено(ДатаСреза), ТекущаяДата(), ДатаСреза));
		Запрос.Текст = "ВЫБРАТЬ
		               |	СчетаУчетаНоменклатурыСрезПоследних.Номенклатура,
		               |	СчетаУчетаНоменклатурыСрезПоследних.СчетУчета
		               |ИЗ
		               |	РегистрСведений.СчетаУчетаНоменклатуры.СрезПоследних(&ДатаСреза, ) КАК СчетаУчетаНоменклатурыСрезПоследних";
	Иначе	
		Запрос.УстановитьПараметр("ДатаСреза", ?(НЕ ЗначениеЗаполнено(ДатаСреза), ТекущаяДата(), ДатаСреза));
		Запрос.УстановитьПараметр("Товары", МассивТовары);
		Запрос.Текст = "ВЫБРАТЬ
		               |	СчетаУчетаНоменклатурыСрезПоследних.Номенклатура,
		               |	СчетаУчетаНоменклатурыСрезПоследних.СчетУчета
		               |ИЗ
		               |	РегистрСведений.СчетаУчетаНоменклатуры.СрезПоследних(&ДатаСреза, Номенклатура В (&Товары)) КАК СчетаУчетаНоменклатурыСрезПоследних";
	КонецЕсли;				   
				   
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции	

#КонецЕсли

//+++АК SHEP 2018.01.25 ИП-00017665.02
Функция ПросуммироватьВремяИзМассива(МассивВремён) Экспорт
Перем ОбщееВремя;
	
	ОбщееВремя = Дата(1,1,1);
	Если ТипЗнч(МассивВремён) = Тип("Массив") Тогда
		Для Каждого ТекВремя Из МассивВремён Цикл
			Если НЕ ЗначениеЗаполнено(ТекВремя) Тогда Продолжить; КонецЕсли;
			ОбщееВремя = ОбщееВремя + ТекВремя;
		КонецЦикла;
	КонецЕсли;
	
	Если ОбщееВремя = Дата(1,1,1) Тогда Возврат ""; КонецЕсли;
	
	ФорматЧасов = Формат(ОбщееВремя, "ДФ=ЧЧ:мм:сс");
	ФорматЧасов = ?(Лев(ФорматЧасов, 2) = "00", "" + Символы.НПП + Символы.НПП + Символы.НПП + Символы.НПП + Символы.НПП + Сред(ФорматЧасов, 4), ФорматЧасов);
	Если НачалоДня(ОбщееВремя) = Дата(1,1,1) Тогда
		Возврат ФорматЧасов;
	КонецЕсли;
	
	// преобразуем к дням
	Дней = Цел((ОбщееВремя - Дата(1,1,1)) / 86400);
	Возврат "" + СтрокаСЧислом(";%1 день;;%1 дня;%1 дней;%1 дня", Дней, ВидЧисловогоЗначения.Количественное, "L=ru") + " " + ФорматЧасов;
	
КонецФункции

// Создает массив и помещает в него переданное значение.
Функция ЗначениеВМассиве(Значение) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Значение);
	
	Возврат Массив;
	
КонецФункции

// Процедура управляет состояние поля табличного документа.
//
// Параметры:
//  ПолеТабличногоДокумента - ПолеФормы - поле формы с видом ПолеТабличногоДокумента,
//                            для которого необходимо установить состояние.
//  Состояние               - Строка - задает вид состояния.
//
Процедура УстановитьСостояниеПоляТабличногоДокумента(ПолеТабличногоДокумента, Состояние = "НеИспользовать") Экспорт
	
	Если ТипЗнч(ПолеТабличногоДокумента) = Тип("ПолеФормы") 
		И ПолеТабличногоДокумента.Вид = ВидПоляФормы.ПолеТабличногоДокумента Тогда
		ОтображениеСостояния = ПолеТабличногоДокумента.ОтображениеСостояния;
		Если ВРег(Состояние) = "НЕИСПОЛЬЗОВАТЬ" Тогда
			ОтображениеСостояния.Видимость                      = Ложь;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.НеИспользовать;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = "";
		ИначеЕсли ВРег(Состояние) = "НЕАКТУАЛЬНОСТЬ" Тогда
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Отчет не сформирован. Нажмите ""Сформировать"" для получения отчета.'");;
		ИначеЕсли ВРег(Состояние) = "ФОРМИРОВАНИЕОТЧЕТА" Тогда  
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = БиблиотекаКартинок.ДлительнаяОперация48;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Отчет формируется...'");
		Иначе
			ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра (параметр номер ''2'')'"));
		КонецЕсли;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра (параметр номер ''1'')'"));
	КонецЕсли;
	
КонецПроцедуры

// Возвращает код основного языка конфигурации, например "ru".
//
// Возвращаемое значение:
//  Строка - код языка.
//
Функция КодОсновногоЯзыка() Экспорт
	#Если НЕ ТонкийКлиент И НЕ ВебКлиент Тогда
		Возврат Метаданные.ОсновнойЯзык.КодЯзыка;
	#Иначе
		Возврат "ru";
	#КонецЕсли
КонецФункции

// Возвращает Истина, если включен режим отладки.
//
// Возвращаемое значение:
//  Булево - Истина, если включен режим отладки.
Функция РежимОтладки() Экспорт

	//LATV: нет возможности перенести функциональность БСП. Для удобства отладки можно менять значение переменной
	РежимОтладки = Ложь;
	Возврат РежимОтладки;

КонецФункции

// Вызывает исключение с текстом Сообщение, если Условие не равно Истина.
// Применяется для самодиагностики кода.
//
// Параметры:
//   Условие                - Булево - если не равно Истина, то вызывается исключение.
//   КонтекстПроверки       - Строка - например, имя процедуры или функции, в которой выполняется проверка.
//   Сообщение              - Строка - текст сообщения. Если не задан, то исключение вызывается с сообщением по
//                                     умолчанию.
//
Процедура Проверить(Знач Условие, Знач Сообщение = "", Знач КонтекстПроверки = "") Экспорт
	
	Если Условие <> Истина Тогда
		Если ПустаяСтрока(Сообщение) Тогда
			ТекстИсключения = НСтр("ru = 'Недопустимая операция'"); // Assertion failed
		Иначе
			ТекстИсключения = Сообщение;
		КонецЕсли;
		Если Не ПустаяСтрока(КонтекстПроверки) Тогда
			ТекстИсключения = ТекстИсключения + " " + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'в %1'"), КонтекстПроверки);
		КонецЕсли;
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
	
КонецПроцедуры

// Вызывает исключение, если тип значения параметра ИмяПараметра процедуры или функции ИмяПроцедурыИлиФункции
// отличается от ожидаемого.
// Для диагностики типов параметров, передаваемых в процедуры и функции программного интерфейса.
//
// Параметры:
//   ИмяПроцедурыИлиФункции - Строка             - имя процедуры или функции, параметр которой проверяется.
//   ИмяПараметра           - Строка             - имя проверяемого параметра процедуры или функции.
//   ЗначениеПараметра      - Произвольный       - фактическое значение параметра.
//   ОжидаемыеТипы  - ОписаниеТипов, Тип, Массив - тип(ы) параметра процедуры или функции.
//   ОжидаемыеТипыСвойств   - Структура          - если ожидаемый тип - структура, то 
//                                                 в этом параметре можно указать типы ее свойств.
//
Процедура ПроверитьПараметр(Знач ИмяПроцедурыИлиФункции, Знач ИмяПараметра, Знач ЗначениеПараметра, 
	Знач ОжидаемыеТипы, Знач ОжидаемыеТипыСвойств = Неопределено) Экспорт
	
	Контекст = "ОбщегоНазначенияКлиентСервер.ПроверитьПараметр";
	Проверить(ТипЗнч(ИмяПроцедурыИлиФункции) = Тип("Строка"), 
		НСтр("ru = 'Недопустимо значение параметра ИмяПроцедурыИлиФункции'"), Контекст);
	Проверить(ТипЗнч(ИмяПараметра) = Тип("Строка"), 
		НСтр("ru = 'Недопустимо значение параметра ИмяПараметра'"), Контекст);
		
	ЭтоКорректныйТип = ЗначениеОжидаемогоТипа(ЗначениеПараметра, ОжидаемыеТипы);
	Проверить(ЭтоКорректныйТип <> Неопределено, 
		НСтр("ru = 'Недопустимо значение параметра ОжидаемыеТипы'"), Контекст);
		
	НедопустимыйПараметр = НСтр("ru = 'Недопустимое значение параметра %1 в %2. 
		|Ожидалось: %3; передано значение: %4 (тип %5).'");
	Проверить(ЭтоКорректныйТип, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НедопустимыйПараметр,
		ИмяПараметра,
		ИмяПроцедурыИлиФункции,
		ПредставлениеТипов(ОжидаемыеТипы), 
		?(ЗначениеПараметра <> Неопределено, ЗначениеПараметра, НСтр("ru = 'Неопределено'")),
		ТипЗнч(ЗначениеПараметра)));
			
	Если ТипЗнч(ЗначениеПараметра) = Тип("Структура") И ОжидаемыеТипыСвойств <> Неопределено Тогда
		
		Проверить(ТипЗнч(ОжидаемыеТипыСвойств) = Тип("Структура"), 
			НСтр("ru = 'Недопустимо значение параметра ИмяПроцедурыИлиФункции'"), Контекст);
			
		НетСвойства = НСтр("ru = 'Недопустимое значение параметра %1 (Структура) в %2. 
			|В структуре ожидалось свойство %3 (тип %4).'");
		НедопустимоеСвойство = НСтр("ru = 'Недопустимое значение свойства %1 в параметре %2 (Структура) в %3. 
			|Ожидалось: %4; передано значение: %5 (тип %6).'");
		Для каждого Свойство Из ОжидаемыеТипыСвойств Цикл
			
			ОжидаемоеИмяСвойства = Свойство.Ключ;
			ОжидаемыйТипСвойства = Свойство.Значение;
			ЗначениеСвойства = Неопределено;
			
			Проверить(ЗначениеПараметра.Свойство(ОжидаемоеИмяСвойства, ЗначениеСвойства), 
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НетСвойства, ИмяПараметра, ИмяПроцедурыИлиФункции, ОжидаемоеИмяСвойства, ОжидаемыйТипСвойства));
				
			ЭтоКорректныйТип = ЗначениеОжидаемогоТипа(ЗначениеСвойства, ОжидаемыйТипСвойства);
			Проверить(ЭтоКорректныйТип, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НедопустимоеСвойство, 
				ОжидаемоеИмяСвойства,
				ИмяПараметра,
				ИмяПроцедурыИлиФункции,
				ПредставлениеТипов(ОжидаемыеТипы), 
				?(ЗначениеСвойства <> Неопределено, ЗначениеСвойства, НСтр("ru = 'Неопределено'")),
				ТипЗнч(ЗначениеСвойства)));
		КонецЦикла;
	КонецЕсли;		
	
КонецПроцедуры

Функция ЗначениеОжидаемогоТипа(Значение, ОжидаемыеТипы)
	ТипЗначения = ТипЗнч(Значение);
	Если ТипЗнч(ОжидаемыеТипы) = Тип("ОписаниеТипов") Тогда
		Возврат ОжидаемыеТипы.Типы().Найти(ТипЗначения) <> Неопределено;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип("Тип") Тогда
		Возврат ТипЗначения = ОжидаемыеТипы;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип("Массив") Или ТипЗнч(ОжидаемыеТипы) = Тип("ФиксированныйМассив") Тогда
		Возврат ОжидаемыеТипы.Найти(ТипЗначения) <> Неопределено;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип("Соответствие") Или ТипЗнч(ОжидаемыеТипы) = Тип("ФиксированноеСоответствие") Тогда
		Возврат ОжидаемыеТипы.Получить(ТипЗначения) <> Неопределено;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

Функция ПредставлениеТипов(ОжидаемыеТипы)
	Если ТипЗнч(ОжидаемыеТипы) = Тип("Массив") Тогда
		Результат = "";
		Индекс = 0;
		Для Каждого Тип Из ОжидаемыеТипы Цикл
			Если Не ПустаяСтрока(Результат) Тогда
				Результат = Результат + ", ";
			КонецЕсли;
			Результат = Результат + ПредставлениеТипа(Тип);
			Индекс = Индекс + 1;
			Если Индекс > 10 Тогда
				Результат = Результат + ",... "
					+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='(всего %1 типов)'"), ОжидаемыеТипы.Количество());
				Прервать;	
			КонецЕсли;	
		КонецЦикла;
		Возврат Результат;
	Иначе
		Возврат ПредставлениеТипа(ОжидаемыеТипы);
	КонецЕсли;
КонецФункции

Функция ПредставлениеТипа(Тип)
	Если Тип = Неопределено Тогда
		Возврат "Неопределено";
	ИначеЕсли ТипЗнч(Тип) = Тип("ОписаниеТипов") Тогда
		ТипСтрокой = Строка(Тип);
		Возврат ?(СтрДлина(ТипСтрокой) > 150, Лев(ТипСтрокой, 150) + "..." 
			+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='(всего %1 типов)'"), Тип.Типы().Количество()), 
			ТипСтрокой);
	Иначе	
		ТипСтрокой = Строка(Тип);
		Возврат ?(СтрДлина(ТипСтрокой) > 150, Лев(ТипСтрокой, 150) + "...", ТипСтрокой);
	КонецЕсли;	
КонецФункции	

Функция СкопироватьСписокЗначений(СписокИсточник) Экспорт
	
	СписокРезультат = Новый СписокЗначений;
	
	Для Каждого ЭлементСписка Из СписокИсточник Цикл
		СписокРезультат.Добавить(
			ЭлементСписка.Значение, 
			ЭлементСписка.Представление, 
			ЭлементСписка.Пометка, 
			ЭлементСписка.Картинка);
	КонецЦикла;
	
	Возврат СписокРезультат;
	
КонецФункции

// Возвращает значение свойства структуры.
//
// Параметры:
//   Структура - Структура, ФиксированнаяСтруктура - Объект, из которого необходимо прочитать значение ключа.
//   Ключ - Строка - Имя свойства структуры, для которого необходимо прочитать значение.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный. Возвращается когда в структуре нет значения по указанному
//                                        ключу.
//       Для скорости рекомендуется передавать только быстро вычисляемые значения (например примитивные типы),
//       а инициализацию более тяжелых значений выполнять после проверки полученного значения (только если это
//       требуется).
//
// Возвращаемое значение:
//   Произвольный - Значение свойства структуры. ЗначениеПоУмолчанию если в структуре нет указанного свойства.
//
Функция СвойствоСтруктуры(Структура, Ключ, ЗначениеПоУмолчанию = Неопределено) Экспорт
	
	Если Структура = Неопределено Тогда
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Результат = ЗначениеПоУмолчанию;
	Если Структура.Свойство(Ключ, Результат) Тогда
		Возврат Результат;
	Иначе
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
КонецФункции

//+++АК SHEP 2018.10.04 ИП-00020060
Функция ЭтоСторонняяРозница(Получатель) Экспорт
	
	МассивСтороннихТипов = Новый Массив;
	МассивСтороннихТипов.Добавить(ПредопределенноеЗначение("Перечисление.ТипыСтруктурныхЕдиниц.СторонняяРозница"));
	МассивСтороннихТипов.Добавить(ПредопределенноеЗначение("Перечисление.ТипыСтруктурныхЕдиниц.СкладСтороннейРозницы"));
	
	Возврат (ТипЗнч(Получатель) = Тип("СправочникСсылка.СтруктурныеЕдиницы")
		И МассивСтороннихТипов.Найти(ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Получатель, "ТипСтруктурнойЕдиницы")) <> Неопределено);
	
КонецФункции

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//     СтрокаURI - Строка - ссылка на ресурс в формате: <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>
//
// Возвращаемое значение:
//     Структура - составные части URI согласно формату:
//         * Схема         - Строка
//         * Логин         - Строка
//         * Пароль        - Строка
//         * ИмяСервера    - Строка - часть <хост>:<порт> входного параметра
//         * Хост          - Строка
//         * Порт          - Строка
//         * ПутьНаСервере - Строка - часть <путь>?<параметры>#<якорь> входного параметра
//
Функция СтруктураURI(Знач СтрокаURI) Экспорт
	
	СтрокаURI = СокрЛП(СтрокаURI);
	
	// схема
	Схема = "";
	Позиция = Найти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;

	// строка соединения и путь на сервере
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = "";
	Позиция = Найти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
		
	// информация пользователя и имя сервера
	СтрокаАвторизации = "";
	ИмяСервера = СтрокаСоединения;
	Позиция = Найти(СтрокаСоединения, "@");
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = Найти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = Найти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("Хост", Хост);
	Результат.Вставить("Порт", ?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
	Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
	
	Возврат Результат;
	
КонецФункции
